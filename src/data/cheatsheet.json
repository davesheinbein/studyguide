[
	{
		"topic": "Array / String",
		"code": "// Initialization\nlet arr = Array(n).fill(0);\n// Array of size n filled with 0\nlet str = \"example\";\n// Find Duplicates\nlet seen = new Set();\nfor (let num of arr) {\n if (seen.has(num)) return true;\n seen.add(num);\n}"
	},
	{
		"topic": "Two Pointers",
		"code": "let left = 0, right = arr.length - 1;\nwhile (left < right) {\n if (arr[left] + arr[right] === target) {\n  return [left, right];\n } else if (arr[left] + arr[right] < target) {\n  left++;\n } else {\n  right--;\n }\n}"
	},
	{
		"topic": "Sliding Window",
		"code": "// Fixed Window\nfor (let i = 0; i <= arr.length - k; i++) {\n let windowSum = arr.slice(i, i + k).reduce((a, b) => a + b, 0);\n}\n// Dynamic Window\nlet left = 0, maxLen = 0, charSet = new Set();\nfor (let right = 0; right < s.length; right++) {\n while (charSet.has(s[right])) {\n  charSet.delete(s[left]);\n  left++;\n }\n charSet.add(s[right]);\n maxLen = Math.max(maxLen, right - left + 1);\n}"
	},
	{
		"topic": "Matrix",
		"code": "// Traversal\nlet rows = matrix.length, cols = matrix[0].length;\nfor (let r = 0; r < rows; r++) {\n for (let c = 0; c < cols; c++) {\n  console.log(matrix[r][c]);\n }\n}\n// Directions (e.g., for BFS in 4 directions)\nlet directions = [[0,1], [1,0], [0,-1], [-1,0]];\nfor (let [dr, dc] of directions) {\n let nr = r + dr, nc = c + dc;\n if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\n  console.log(matrix[nr][nc]);\n }\n}"
	},
	{
		"topic": "Hashmap",
		"code": "// Initialization and Operations\nlet hashmap = new Map();\nhashmap.set(key, value);\nhashmap.get(key, defaultValue);\n// Retrieve or default value\nhashmap.delete(key);\n// Remove key"
	},
	{
		"topic": "Intervals",
		"code": "// Merge Intervals\nintervals.sort((a, b) => a[0] - b[0]);\nlet merged = [intervals[0]];\nfor (let i = 1; i < intervals.length; i++) {\n let [start, end] = intervals[i];\n let last = merged[merged.length - 1];\n if (start <= last[1]) {\n  last[1] = Math.max(last[1], end);\n } else {\n  merged.push([start, end]);\n }\n}"
	},
	{
		"topic": "Stack",
		"code": "// Initialization and Operations\nlet stack = [];\nstack.push(value);\n// Push\nstack.pop();   \n// Pop\nif (stack.length > 0) { /* Stack is not empty */ }"
	},
	{
		"topic": "Linked List",
		"code": "// Node Definition\nclass ListNode {\n constructor(value = 0, next = null) {\n  this.value = value;\n  this.next = next;\n }\n}\n// Traversal\nlet node = head;\nwhile (node) {\n console.log(node.value);\n node = node.next;\n}"
	},
	{
		"topic": "Binary Tree General",
		"code": "// TreeNode Definition\nclass TreeNode {\n constructor(value = 0, left = null, right = null) {\n  this.value = value;\n  this.left = left;\n  this.right = right;\n }\n}\n// DFS Recursive\nfunction dfs(node) {\n if (!node) return;\n dfs(node.left);\n dfs(node.right);\n}"
	},
	{
		"topic": "Binary Tree BFS",
		"code": "// BFS Level Order\nlet queue = [root];\nwhile (queue.length) {\n let node = queue.shift();\n if (node.left) queue.push(node.left);\n if (node.right) queue.push(node.right);\n}"
	},
	{
		"topic": "Binary Search Tree",
		"code": "// Insert in BST\nfunction insert(root, value) {\n if (!root) return new TreeNode(value);\n if (value < root.value) root.left = insert(root.left, value);\n else root.right = insert(root.right, value);\n return root;\n}"
	},
	{
		"topic": "Graph General",
		"code": "// Graph Representation (Adjacency List)\nlet graph = {};\ngraph[node1] = [node2];"
	},
	{
		"topic": "Graph BFS",
		"code": "// BFS\nlet visited = new Set();\nlet queue = [start];\nwhile (queue.length) {\n let node = queue.shift();\n for (let neighbor of graph[node]) {\n  if (!visited.has(neighbor)) {\n   visited.add(neighbor);\n   queue.push(neighbor);\n  }\n }\n}"
	},
	{
		"topic": "Trie",
		"code": "// Insert & Search\nclass TrieNode {\n constructor() {\n  this.children = {};\n  this.isEnd = false;\n }\n}\n\nclass Trie {\n constructor() {\n  this.root = new TrieNode();\n }\n\n insert(word) {\n  let node = this.root;\n  for (let char of word) {\n   if (!node.children[char]) \n    node.children[char] = new TrieNode();\n   node = node.children[char];\n  }\n  node.isEnd = true;\n }\n\n search(word) {\n  let node = this.root;\n  for (let char of word) {\n   if (!node.children[char]) return false;\n   node = node.children[char];\n  }\n  return node.isEnd;\n }\n}"
	},
	{
		"topic": "Backtracking",
		"code": "// Backtracking Template\nfunction backtrack(path, choices) {\n if (valid(path)) result.push([...path]);\n for (let choice of choices) {\n  path.push(choice);\n  backtrack(path, choices);\n  path.pop();\n }\n}"
	},
	{
		"topic": "Divide & Conquer",
		"code": "// Template\nfunction divideAndConquer(arr) {\n if (arr.length <= 1) return arr;\n let mid = Math.floor(arr.length / 2);\n let left = divideAndConquer(arr.slice(0, mid));\n let right = divideAndConquer(arr.slice(mid));\n return merge(left, right);\n}"
	},
	{
		"topic": "Kadane's Algorithm",
		"code": "// Max Subarray Sum\nlet maxSum = -Infinity, currSum = 0;\nfor (let num of arr) {\n currSum = Math.max(num, currSum + num);\n maxSum = Math.max(maxSum, currSum);\n}"
	},
	{
		"topic": "Binary Search",
		"code": "// Template\nlet left = 0, right = arr.length - 1;\nwhile (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (arr[mid] === target) return mid;\n else if (arr[mid] < target) left = mid + 1;\n else right = mid - 1;\n}"
	},
	{
		"topic": "Heap",
		"code": "// Min-Heap\nclass MinHeap {\n constructor() {\n  this.heap = [];\n }\n push(value) {\n  this.heap.push(value);\n  this.heap.sort((a, b) => a - b);\n }\n pop() {\n  return this.heap.shift();\n }\n}"
	},
	{
		"topic": "Bit Manipulation",
		"code": "// Basic Bitwise Operations\nx & y; \n// AND\nx | y; \n// OR\nx ^ y; \n// XOR\nx << 1;\n// Left Shift\nx >> 1;\n// Right Shift\n~x;  \n// NOT"
	},
	{
		"topic": "Math",
		"code": "// Factorial\nfunction factorial(n) {\n return n <= 1 ? 1 : n * factorial(n - 1);\n}"
	},
	{
		"topic": "1D DP",
		"code": "// Fibonacci\nlet dp = Array(n + 1).fill(0);\ndp[1] = 1;\nfor (let i = 2; i <= n; i++) {\n dp[i] = dp[i - 1] + dp[i - 2];\n}"
	},
	{
		"topic": "Multidimensional DP",
		"code": "// Knapsack Problem\nlet dp = Array(rows).fill().map(\n() => Array(cols).fill(0));\nfor (let i = 1; i < rows; i++) {\n for (let w = 1; w < cols; w++) {\n  if (items[i - 1].weight <= w) {\n   dp[i][w] = Math.max(dp[i - 1][w],\n    items[i - 1].value + \n   dp[i - 1][w - items[i - 1].weight]);\n  } else {\n   dp[i][w] = dp[i - 1][w];\n  }\n }\n}"
	}
]
