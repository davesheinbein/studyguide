[
	{
		"id": 26,
		"topic": "Is Subsequence",
		"code": "// Check if s is a subsequence of t\nvar isSubsequence = function(s, t) {\n let i = 0, j = 0;\n \n // Traverse string t to find characters of string s in order\n while (i < s.length && j < t.length) {\n console.log(`Comparing s[${i}] = '${s[i]}' with t[${j}] = '${t[j]}'`);\n \n if (s[i] === t[j]) {\n console.log(`Match found! Incrementing i to ${i + 1}`);\n i++; // Move pointer for s when there's a match\n }\n \n // Always move pointer for t\n j++;\n console.log(`Incrementing j to ${j}`);\n }\n \n // If all characters in s are found in order in t, return true\n console.log(`Final value of i: ${i}, length of s: ${s.length}`);\n return i === s.length;\n};\n\n// Optimized solution\n// Preprocess t and store the positions of each character\n// var preprocess = function(t) {\n// const positions = new Map();\n// for (let i = 0; i < t.length; i++) {\n// if (!positions.has(t[i])) {\n// positions.set(t[i], []);\n// }\n// positions.get(t[i]).push(i);\n// }\n// return positions;\n// };\n\n// // Check if s is a subsequence of t using binary search\n// var isSubsequence = function(s, t) {\n// const positions = preprocess(t);\n// let prevIndex = -1;\n\n// // Traverse each character in s\n// for (let char of s) {\n// if (!positions.has(char)) {\n// return false; // If t doesn't contain this character, return false\n// }\n\n// const indices = positions.get(char);\n\n// // Use binary search to find the smallest index in indices that is greater than prevIndex\n// let left = 0, right = indices.length - 1;\n// let found = false;\n\n// while (left <= right) {\n// const mid = Math.floor((left + right) / 2);\n// if (indices[mid] > prevIndex) {\n// found = true;\n// prevIndex = indices[mid];\n// right = mid - 1;\n// } else {\n// left = mid + 1;\n// }\n// }\n\n// // If no valid index is found, return false\n// if (!found) {\n// return false;\n// }\n// }\n\n// return true;\n// };\n",
		"explanation": "Explanation:\n\n- We start by initializing two pointers: `i` for string `s` and `j` for string `t`.\n- We loop through string `t` using the pointer `j`. For each character in `t`, we check if it matches the current character in `s` (pointed to by `i`).\n- If a match is found (`s[i] === t[j]`), we increment `i` to check the next character in `s`.\n- Regardless of a match, we always increment `j` to continue traversing `t`.\n- If we manage to find all characters of `s` in order within `t`, `i` will reach the end of `s`, and we return `true`.\n- If not, we return `false`.\n\nTime Complexity:\n- The time complexity is O(n), where `n` is the length of string `t`, since we only traverse string `t` once.\n\nSpace Complexity:\n- The space complexity is O(1), since we only use a few variables (`i` and `j`) for the pointers.\n\n\nOptimized Explanation:\n\n1. We preprocess `t` into a map where the key is the character and the value is a list of indices where that character appears in `t`.\n2. For each string `s`, we use binary search to find the next available position in `t` where each character in `s` appears after the previously found character.\n3. If we can't find a character in the required order, return `false`.\n4. If we find all characters of `s` in order, return `true`.\n\nTime Complexity:\n- Preprocessing `t`: O(n), where `n` is the length of `t`.\n- For each string `s`, checking if itâ€™s a subsequence takes O(m * log n), where `m` is the length of `s` and `n` is the length of `t`. This is because we use binary search on the list of indices for each character of `s`.\n\nSpace Complexity:\n- O(n), where `n` is the length of `t`, for storing the positions of characters.",
		"category": "Two Pointers"
	}
]
