[
	{
		"id": 29,
		"topic": "3Sum",
		"code": "var threeSum = function(nums) {\n    console.log(\"Input array:\", nums);\n    \n    // Sort the array to simplify finding duplicates and using the two-pointer approach\n    nums.sort((a, b) => a - b);\n    console.log(\"Sorted array:\", nums);\n\n    const result = [];\n    const n = nums.length;\n\n    // Iterate through the array, fixing the first number of the triplet\n    for (let i = 0; i < n - 2; i++) {\n        // Explanation: We use `i < n - 2` because we need at least two numbers after `nums[i]`\n        // to form a triplet. If `i` were to reach `n - 2`, there wouldn't be enough numbers \n        // remaining in the array to form a valid triplet.\n        \n        // Skip duplicates for the first number\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            // console.log(`Skipping duplicate for nums[${i}] = ${nums[i]}`);\n            continue;\n        }\n\n        // Create two pointers: one at the element right after the current one (left)\n        // and one at the last element (right). These pointers will be used to find pairs\n        // that, together with nums[i], sum up to zero.\n        let left = i + 1;\n        let right = n - 1;\n\n        // console.log(`Processing nums[${i}] = ${nums[i]}`);\n\n        while (left < right) {\n            // Combination of current triplet\n            const sum = nums[i] + nums[left] + nums[right];\n            // console.log(`Checking combination: ${nums[i]}, ${nums[left]}, ${nums[right]} (sum = ${sum})`);\n\n            if (sum === 0) {\n                // console.log(`Found triplet: [${nums[i]}, ${nums[left]}, ${nums[right]}]`);\n                \n                // Found a valid triplet: add it to the result array\n                result.push([nums[i], nums[left], nums[right]]);\n                // Move the left pointer to the right, skipping any duplicates\n                left++;\n                // Move the right pointer to the left, skipping any duplicates\n                right--;\n\n                // Skip duplicates for the second number\n                while (left < right && nums[left] === nums[left - 1]) {\n                    // console.log(`Skipping duplicate for nums[${left}] = ${nums[left]}`);\n                    left++;\n                }\n                \n                // Skip duplicates for the third number\n                while (left < right && nums[right] === nums[right + 1]) {\n                    // console.log(`Skipping duplicate for nums[${right}] = ${nums[right]}`);\n                    right--;\n                }\n            } else if (sum < 0) {\n                // console.log(`Sum < 0, incrementing left pointer from ${left} to ${left + 1}`);\n                \n                // If the sum is less than 0, we need a larger number to increase the sum\n                // So, move the left pointer to the right (left++)\n                left++;\n            } else {\n                // console.log(`Sum > 0, decrementing right pointer from ${right} to ${right - 1}`);\n                \n                // If the sum is greater than 0, we need a smaller number to decrease the sum\n                // So, move the right pointer to the left (right--)\n                right--;\n            }\n        }\n    }\n\n    console.log(\"Final result:\", result);\n    return result;\n};\n",
		"explanation": "Explanation:<br/><br/>1. Input array: [-1, 0, 1, 2, -1, -4]<br/>   After sorting: [-4, -1, -1, 0, 1, 2]<br/><br/>2. Iterate through the array and fix the first number of the triplet.<br/><br/>3. Use two pointers (left and right) to find pairs of numbers that, when added to the first number, result in zero:<br/>   - Left pointer:<br/>     - Starts just after the current index `i` (`left = i + 1`).<br/>     - Moves forward (`left++`) if the sum of the triplet is less than zero, since the sorted order means larger numbers are needed to increase the sum.<br/>   - Right pointer:<br/>     - Starts at the last index (`right = n - 1`).<br/>     - Moves backward (`right--`) if the sum of the triplet is greater than zero, since the sorted order means smaller numbers are needed to decrease the sum.<br/>   - Together:<br/>     - `left` and `right` explore all possible pairs for the current `nums[i]`.<br/>     - If the sum of the triplet matches zero, the combination is valid, and both pointers adjust to skip duplicates.<br/>     - The process continues until `left` and `right` pointers overlap, completing all pair possibilities for the current `nums[i]`.<br/><br/>4. If a triplet is found, store it in the result array and adjust the pointers while skipping duplicates.<br/><br/>5. If the sum is less than zero, increment the left pointer to increase the sum.<br/><br/>6. If the sum is greater than zero, decrement the right pointer to decrease the sum.<br/><br/>7. Repeat this process for all elements in the array.<br/><br/>8. Return the final list of unique triplets: [[-1, -1, 2], [-1, 0, 1]].",
		"category": "Two Pointers"
	}
]
