{
	"id": 142,
	"topic": "Triangle",
	"code": "// Find the minimum path sum from top to bottom\n/**\n * @param {number[][]} triangle\n * @return {number}\n */\nvar minimumTotal = function(triangle) {\n    // Start from the second-to-last row and move upwards\n    for (let row = triangle.length - 2; row >= 0; row--) {\n        for (let col = 0; col < triangle[row].length; col++) {\n            // Update the current cell with the minimum path sum\n            triangle[row][col] += Math.min(\n                triangle[row + 1][col],      // Path to the same index in the next row\n                triangle[row + 1][col + 1]  // Path to the next index in the next row\n            );\n        }\n    }\n\n    // The top element contains the minimum path sum\n    return triangle[0][0];\n};\n\n// Example Usage\nconsole.log(minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]])); // Output: 11\nconsole.log(minimumTotal([[-10]])); // Output: -10\n",
	"explanation": "The problem requires calculating the minimum path sum from the top of a triangle to its base. At each step, you can only move to adjacent numbers in the row below. To solve this efficiently, we use a bottom-up dynamic programming approach. Here's how:<br/><br/>1. Start from the bottom of the triangle:<br/>   - Instead of starting from the top and working down, we begin from the second-to-last row and calculate the minimum path sum for each element by considering the two possible paths in the row below. This avoids the need for recursion and redundant calculations.<br/><br/>2. Iterative Updates:<br/>   - For each element in the current row, we compute the minimum path sum by adding the current value to the minimum of the two adjacent values in the row below. This effectively reduces the problem size row by row.<br/><br/>3. In-Place Modification:<br/>   - The `triangle` array is updated directly during the computation. This avoids the need for extra space to store intermediate results, making the solution space-efficient.<br/><br/>4. Final Result:<br/>   - By the time we process all rows, the top element of the triangle (`triangle[0][0]`) will contain the minimum path sum.<br/><br/>Why Bottom-Up?<br/>This approach is efficient because:<br/>   - It avoids recomputation: Each subproblem is solved once, and its result is reused.<br/>   - It uses the triangle itself for storing intermediate results, saving space.<br/><br/>Time and Space Complexity:<br/>- Time Complexity: O(n^2), where n is the number of rows. We iterate over every element in the triangle.<br/>- Space Complexity: O(1), as the triangle is updated in place without using additional memory."
}
