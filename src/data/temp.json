{
	"id": 114,
	"topic": "Search Insert Position",
	"code": "// Find the index where a target should be inserted\nvar searchInsert = function(nums, target) {\n console.log(\"nums:\", nums);\n console.log(\"target:\", target);\n // Initializing two pointers, left and right, which will define the search range\n let left = 0;\n let right = nums.length - 1;\n\n // Binary search loop: Continue until the left pointer exceeds the right pointer\n while (left <= right) {\n // Find the middle index in the current search range\n const mid = Math.floor((left + right) / 2);\n\n // Case 1: If the target is found at mid, return the mid index\n if (nums[mid] === target) {\n return mid;\n }\n // Case 2: If the target is greater than the mid value, search in the right half\n else if (nums[mid] < target) {\n left = mid + 1;  // Move the left pointer to mid + 1\n }\n // Case 3: If the target is smaller than the mid value, search in the left half\n else {\n right = mid - 1;  // Move the right pointer to mid - 1\n }\n }\n\n // If the target is not found, left will be the position where the target should be inserted\n // This ensures the array remains sorted if the target were to be inserted\n return left;\n};\n\n// Example usage:\nconsole.log(searchInsert([1, 3, 5, 6], 5)); // Output: 2\nconsole.log(searchInsert([1, 3, 5, 6], 2)); // Output: 1\nconsole.log(searchInsert([1, 3, 5, 6], 7)); // Output: 4\nconsole.log(searchInsert([1, 3, 5, 6], 0)); // Output: 0\nconsole.log(searchInsert([1, 3, 5, 6], 4)); // Output: 2\n",
	"explanation": "- `left` and `right` represent the current search boundaries within the array. Initially, `left` is at the start (0) and `right` is at the end (nums.length - 1).\n\n- `mid` is the middle index of the current search range and is calculated by `(left + right) / 2`. It is used to compare the target with the element at that index.\n\n- The three cases inside the while loop handle different situations:\n - If the element at `nums[mid]` equals the target, we return the `mid` index immediately, as we have found the target.\n - If `nums[mid]` is less than the target, the target must be on the right side of `mid`, so we move the `left` pointer to `mid + 1`.\n - If `nums[mid]` is greater than the target, the target must be on the left side of `mid`, so we move the `right` pointer to `mid - 1`.\n\n- Once the binary search is complete and the target is not found, the `left` pointer will be positioned at the index where the target should be inserted to keep the array sorted. This is the key idea: if the target isn't present, `left` will point to the first position where the target can be inserted without disrupting the order.\n\nTime Complexity:\n\n- O(log n): The binary search halves the search range in each step, leading to a logarithmic time complexity. This is optimal for searching in a sorted array.\n\nSpace Complexity:\n\n- O(1): The algorithm uses a constant amount of extra space, as it only stores a few variables (left, right, mid) and does not use any additional data structures.",
	"category": "Binary Search"
}
