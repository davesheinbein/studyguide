{
	"id": 33,
	"topic": "Minimum Window Substring",
	"code": "// Find the minimum window substring\nvar minWindow = function (s, t) {\n // If `s` is shorter than `t`, it is impossible to form a valid substring.\n if (s.length < t.length) return '';\n // Create a frequency map for characters in `t`\n const tMap = new Map();\n for (let char of t) {\n tMap.set(char, (tMap.get(char) || 0) + 1);\n }\n // Variables for sliding window technique\n let left = 0, right = 0;\n let required = tMap.size;\n let formed = 0;\n const windowCounts = new Map();\n let minLength = Infinity;\n let result = [0, 0];\n // Expand the sliding window by moving the `right` pointer\n while (right < s.length) {\n const char = s[right];\n windowCounts.set(char, (windowCounts.get(char) || 0) + 1);\n if (tMap.has(char) && windowCounts.get(char) === tMap.get(char)) {\n formed++;\n }\n // Shrink the window from the left while it contains all required characters\n while (formed === required) {\n const windowSize = right - left + 1;\n if (windowSize < minLength) {\n minLength = windowSize;\n result = [left, right];\n }\n const leftChar = s[left];\n windowCounts.set(leftChar, windowCounts.get(leftChar) - 1);\n if (tMap.has(leftChar) && windowCounts.get(leftChar) < tMap.get(leftChar)) {\n formed--;\n }\n left++;\n }\n right++;\n }\n return minLength === Infinity ? '' : s.slice(result[0], result[1] + 1);\n};\n\n// Examples:\nconsole.log(minWindow('ADOBECODEBANC', 'ABC')); // Output: \"BANC\"\nconsole.log(minWindow('a', 'a')); // Output: \"a\"\nconsole.log(minWindow('a', 'aa')); // Output: \"\"\n",
	"explanation": "1. Goal:<br/>   - Find the smallest substring in `s` that contains all characters of `t` (including duplicates).<br/><br/>2. Approach:<br/>   - Use the sliding window technique with two pointers (`left` and `right`).<br/>   - Maintain a frequency map (`tMap`) for characters in `t`.<br/>   - Track the number of unique characters in the current window that match the required frequency using `formed`.<br/><br/>3. Steps:<br/>   - Expand the window by moving the `right` pointer.<br/>   - When all characters in `t` are present in the window (`formed === required`), try shrinking the window by moving the `left` pointer.<br/>   - Update the result when a smaller valid window is found.<br/><br/>4. Time Complexity:<br/>   - \\(O(m + n)\\): Iterating over `s` with `right` and at most once with `left`, plus constructing `tMap`.<br/><br/>5. Space Complexity:<br/>   - \\(O(m + n)\\): Space for `tMap` and `windowCounts`.<br/><br/>6. Edge Cases:<br/>   - If `s` is shorter than `t`, return an empty string.<br/>   - If characters in `t` are not in `s`, return an empty string.<br/><br/>7. Walkthrough:<br/>   - Input: `s = \"ADOBECODEBANC\", t = \"ABC\"`<br/>   - Initial `tMap`: `{A: 1, B: 1, C: 1}`<br/>   - Sliding window:<br/>     - Expand: `ADOBE` (not valid)<br/>     - Expand: `ADOBEC` (valid, size = 6)<br/>     - Shrink: `DOBEC` (still valid, size = 5)<br/>     - Expand: Continue until finding `BANC` (size = 4).<br/>   - Output: `\"BANC\"`.",
	"category": "Sliding Window"
}
