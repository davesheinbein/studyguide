{
	"id": 99,
	"topic": "Design Add and Search Words Data Structure",
	"code": "var WordDictionary = function () {\n this.root = {}; // The root of the Trie, starting point for all words\n};\n\n/**\n * Adds a word to the WordDictionary data structure.\n * \n * @param {string} word - The word to be added to the dictionary.\n * @return {void}\n * \n * This function inserts each character of the word into the Trie, creating new nodes as necessary.\n * The last node is marked as the end of the word using the `isEnd` flag.\n */\nWordDictionary.prototype.addWord = function (word) {\n let currentNode = this.root;\n\n // Insert each character of the word into the Trie\n for (const char of word) {\n // If the current character doesn't exist in the Trie, create a new node\n if (!currentNode[char]) {\n currentNode[char] = {}; // Create an empty object for the character node\n }\n // Move to the next node in the Trie (the current character's child)\n currentNode = currentNode[char];\n }\n\n // After inserting all characters of the word, mark the last node as the end of the word\n // This flag indicates that this node completes a valid word in the Trie\n currentNode.isEnd = true;\n};\n\n/**\n * Searches for a word in the WordDictionary, where dots (.) can match any letter.\n * \n * @param {string} word - The word to be searched, may contain dots (.) to match any character.\n * @return {boolean} - Returns true if the word or pattern is found, false otherwise.\n * \n * This function uses a helper function for recursive backtracking to search for the word,\n * supporting wildcard dots (.) that can match any character in the Trie.\n */\nWordDictionary.prototype.search = function (word) {\n // Helper function to perform recursive search, starting from the root\n const searchHelper = (node, index) => {\n // If we've reached the end of the word, check if the current node represents the end of a valid word\n if (index === word.length) {\n return node.isEnd === true; // Return true if this node is the end of a valid word\n }\n\n const char = word[index]; // Get the current character to search for\n\n // If the current character is a dot, we need to explore all possible children at this level\n if (char === '.') {\n // Iterate through all child nodes (i.e., all possible characters that could match the dot)\n for (const key in node) {\n // We skip the `isEnd` property since it is not a child node and avoid infinite recursion\n if (key !== 'isEnd' && searchHelper(node[key], index + 1)) {\n return true; // If any child node matches, return true\n }\n }\n } else {\n // If the character is a regular letter, check if it exists in the current node\n if (node[char] && searchHelper(node[char], index + 1)) {\n return true; // If the character exists and the rest of the word matches, return true\n }\n }\n\n return false; // If no match is found, return false\n };\n\n // Start the search from the root of the Trie, at the beginning of the word\n return searchHelper(this.root, 0);\n};\n",
	"explanation": "- The Trie is a tree-like structure where each node represents a character in the word.<br/>- Each word is added by inserting its characters as nodes into the Trie.<br/>- The `isEnd` flag marks the end of a valid word.<br/>- The `search` function uses a recursive helper function (`searchHelper`) to search for a word.<br/>- The recursive function handles both regular characters and wildcard dots (`.`) by checking possible children nodes or directly matching characters.<br/><br/>Examples:<br/>var obj = new WordDictionary();<br/>obj.addWord(\"bad\");<br/>obj.addWord(\"dad\");<br/>obj.addWord(\"mad\");<br/>console.log(obj.search(\"pad\")); // Output: false (no word \"pad\" in the dictionary)<br/>console.log(obj.search(\"bad\")); // Output: true (word \"bad\" exists in the dictionary)<br/>console.log(obj.search(\".ad\")); // Output: true (matches \"bad\", \"dad\", \"mad\")<br/>console.log(obj.search(\"b..\")); // Output: true (matches \"bad\")<br/><br/>Explanation of each search:<br/>1. `search(\"pad\")`: The word \"pad\" doesn't exist in the Trie, so it returns `false`.<br/>2. `search(\"bad\")`: The exact match of \"bad\" exists, so it returns `true`.<br/>3. `search(\".ad\")`: The dot can match any letter, so it matches \"bad\", \"dad\", and \"mad\", returning `true`.<br/>4. `search(\"b..\")`: The first character \"b\" matches \"bad\", and the two dots match any characters, returning `true`.<br/><br/>Key Points:<br/>- The Trie is constructed where each node corresponds to a character.<br/>- We mark the end of a word by setting `isEnd = true` at the last character node.<br/>- During search, the dot (`.`) wildcard allows us to match any character, and we recursively explore all possible matches at each position in the word.",
	"category": "Trie"
}
