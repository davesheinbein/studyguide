{
	"id": 112,
	"topic": "Maximum Subarray",
	"code": "// Find the contiguous subarray with the maximum sum\nvar maxSubArray = function(nums) {\n let maxSum = nums[0];  // Initialize maxSum with the first element\n let currentSum = 0;    // Initialize currentSum to 0\n\n // Iterate through the array\n for (let num of nums) {\n // Decide whether to start a new subarray or continue adding the current number\n currentSum = Math.max(num, currentSum + num);\n\n // Update maxSum if currentSum is greater\n maxSum = Math.max(maxSum, currentSum);\n }\n\n return maxSum;  // Return the largest sum found\n};\n\n// Example\nconst nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4];\nconsole.log('Maximum Subarray Sum:', maxSubArray(nums)); // Output: Maximum Subarray Sum: 6\n",
	"explanation": "The problem at hand is to find the contiguous subarray within an integer array `nums` that has the largest sum. This problem is efficiently solved using `Kadane’s Algorithm`, which operates in linear time.<br/><br/>### Key Steps in Kadane’s Algorithm:<br/><br/>1. Initialization:<br/> - We start by initializing `maxSum` with the first element of the array (`nums[0]`) since the subarray must have at least one element. This is also our starting point for comparison.<br/> - `currentSum` is initialized to 0, which will be used to track the sum of the current subarray as we iterate through the array.<br/><br/>2. Iterate through the array:<br/> - For each number in the array (`num`), we decide whether to:<br/> - Start a new subarray with the current number (`num`), or<br/> - Add the current number to the ongoing subarray sum (`currentSum + num`).<br/> - The decision is made by comparing `num` with `currentSum + num` and taking the larger value using `Math.max(num, currentSum + num)`. This allows us to effectively \"reset\" the sum if adding the current number leads to a smaller sum than just starting fresh with the current number.<br/><br/>3. Update `maxSum`:<br/> - After adjusting `currentSum` for each number, we check if `currentSum` is greater than the current `maxSum`. If it is, we update `maxSum` to be `currentSum`.<br/><br/>4. Return the result:<br/> - After iterating through the array, the `maxSum` will contain the largest sum of any contiguous subarray, which is our desired result.<br/><br/>### Example Walkthrough:<br/>Given the input `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`:<br/>- Initially, `maxSum` is `-2` (the first element) and `currentSum` is `0`.<br/>- We begin iterating:<br/> - When `1` is encountered, `currentSum` becomes `1` (since `1 > 0 + 1`).<br/> - Next, when `-3` is encountered, `currentSum` becomes `-2` (since `1 + (-3)` is less than `-3`).<br/> - When `4` is encountered, `currentSum` becomes `4` (since `4 > -2 + 4`), and so on.<br/>- The algorithm identifies the subarray `[4, -1, 2, 1]` with the maximum sum of `6`.<br/><br/>### Time Complexity:<br/>- O(n) where `n` is the length of the array, because we only need to make one pass through the array.<br/><br/>### Space Complexity:<br/>- O(1) since we only use a constant amount of extra space (`maxSum` and `currentSum`).",
	"category": "Kadane's Algorithm"
}
