{
	"id": 125,
	"topic": "Add Binary",
	"code": "// Add two binary numbers\nvar addBinary = function(a, b) {\n let result = ''; // To store the resulting binary string, initially empty\n let carry = 0;   // To keep track of carry during addition (like in decimal addition)\n let i = a.length - 1; // Pointer for the last character (bit) in string a\n let j = b.length - 1; // Pointer for the last character (bit) in string b\n\n // Loop until all bits of both strings are processed, or there is a carry left\n while (i >= 0 || j >= 0 || carry > 0) {\n // Extract the current bit from a or b, or default to 0 if the index is out of bounds\n // parseInt converts the character ('0' or '1') to its integer value (0 or 1)\n const bitA = i >= 0 ? parseInt(a[i]) : 0; // Get the ith bit of a, or 0 if i < 0\n const bitB = j >= 0 ? parseInt(b[j]) : 0; // Get the jth bit of b, or 0 if j < 0\n\n // Sum the current bits and the carry from the previous addition\n const sum = bitA + bitB + carry;\n\n // Calculate the bit to add to the result\n // Binary addition produces a result bit that is either 0 or 1\n // sum % 2 gives the remainder when sum is divided by 2, which is the current result bit\n result = (sum % 2) + result;\n\n // Update the carry for the next addition\n // When sum >= 2, there is a carry. For example:\n // - If sum is 2 (1 + 1 + 0), carry = 1 and result bit = 0\n // - If sum is 3 (1 + 1 + 1), carry = 1 and result bit = 1\n carry = Math.floor(sum / 2);\n\n // Move to the next (previous in the string) bits in a and b\n i--; // Decrement the pointer for string a\n j--; // Decrement the pointer for string b\n }\n\n // At this point, the entire binary sum is stored in result\n return result;\n};\n\n// Example usage:\nconsole.log(addBinary('11', '1'));    // Output: '100'\nconsole.log(addBinary('1010', '1011')); // Output: '10101'\n",
	"explanation": "Why use `sum % 2` for the result bit?<br/>- Binary addition follows modulo-2 arithmetic:<br/>  - 0 + 0 = 0 → result = 0, carry = 0<br/>  - 1 + 0 = 1 → result = 1, carry = 0<br/>  - 1 + 1 = 10 (binary) → result = 0, carry = 1<br/>  - 1 + 1 + 1 = 11 (binary) → result = 1, carry = 1<br/>- `sum % 2` extracts the current result bit because it gives the remainder of sum when divided by 2. This works because binary is base-2 arithmetic.<br/><br/>Why use `Math.floor(sum / 2)` for the carry?<br/>- Dividing the sum by 2 and taking the floor gives the carry:<br/>  - When sum < 2, the result of sum / 2 is < 1, so carry is 0.<br/>  - When sum >= 2, the result of sum / 2 is ≥ 1, so carry is 1.<br/><br/>Why prepend the result bit to the string?<br/>- Since we process the binary strings from the least significant bit (rightmost) to the most significant bit (leftmost), we prepend each result bit to build the final binary sum.<br/><br/>Time Complexity:<br/>- O(n), where n is the length of the longer input string (a or b). We process each bit of the longer string once.<br/><br/>Space Complexity:<br/>- O(n), for storing the result binary string.",
	"category": "Bit Manipulation"
}
