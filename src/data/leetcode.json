[
	{
		"id": 1,
		"topic": "Merge Sorted Array",
		"code": "// Define a function to merge two sorted integer arrays\nvar merge = function(nums1, m, nums2, n) {\n    // Initialize pointers for the last elements of nums1 and nums2\n    let i = m - 1; // Pointer for the last element in the first part of nums1\n    let j = n - 1; // Pointer for the last element in nums2\n    let k = m + n - 1; // Pointer for the last position in nums1 (the merged array)\n\n    // While there are still elements to merge from nums2\n    while (j >= 0) {\n        // If there are remaining elements in nums1 and the current element in nums1 is greater than in nums2\n        if (i >= 0 && nums1[i] > nums2[j]) {\n            nums1[k] = nums1[i]; // Place the element from nums1 into the correct position in nums1\n            i--; // Move the pointer in nums1 left\n        } else {\n            // If nums2's current element is greater or nums1 is exhausted\n            nums1[k] = nums2[j]; // Place the element from nums2 into nums1\n            j--; // Move the pointer in nums2 left\n        }\n        // Move the pointer for the merged position left\n        k--;\n    }\n    // No need to return anything since we modify nums1 in place\n};\n",
		"explanation": "1. Function Purpose: The merge function is designed to combine two sorted arrays, nums1 and nums2, into a single sorted array stored in nums1.<br/>2. Input Specification: <br/>   - nums1 is an array of integers that contains m elements followed by n zeros. <br/>   - nums2 is an array of integers containing n elements.<br/>   - m represents the number of actual elements in nums1.<br/>   - n represents the number of elements in nums2.<br/>3. Output Specification: <br/>   - The merged sorted array is stored in nums1.<br/>   - No return value is necessary as the result modifies nums1 in place.<br/>4. Example Walkthrough:<br/>   - Example 1: For the input nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3:<br/>     - Start merging from the end of both arrays, comparing elements and placing them in the correct position.<br/>     - Final output in nums1 will be [1, 2, 2, 3, 5, 6].<br/>   - Example 2: For the input nums1 = [1], m = 1, nums2 = [], n = 0:<br/>     - Since nums2 is empty, nums1 remains [1].<br/>   - Example 3: For the input nums1 = [0], m = 0, nums2 = [1], n = 1:<br/>     - All elements from nums2 are placed in nums1, resulting in [1].<br/>5. Constraints:<br/>   - The function handles constraints ensuring both arrays are of appropriate lengths, with -10^9 <= nums1[i], nums2[j] <= 10^9.<br/>   - The overall length of the combined arrays does not exceed 200 elements, ensuring efficient performance.<br/>6. In-Place Modification: <br/>   - This approach modifies nums1 directly, utilizing its extra space to accommodate the merged result without needing additional arrays, thus achieving O(1) extra space complexity.",
		"category": "Array / String"
	},
	{
		"id": 2,
		"topic": "Remove Element",
		"code": "var removeElement = function(nums, val) {\n    // Initialize k to track the position for the next element that isn’t equal to val.\n    let k = 0;\n\n    // Loop through each element in the nums array\n    for (let i = 0; i < nums.length; i++) {\n        // Check if the current element nums[i] is not equal to val\n        if (nums[i] !== val) {\n            // Place the current element at index k, then increment k\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    \n    // Return k, which now represents the number of elements not equal to val\n    return k;\n};\n",
		"explanation": "Explanation:<br/> - Two-Pointer Approach: We use two pointers, one iterating through the array (`i`)<br/>   and one (`k`) to store the position of the next non-val element.<br/> - Place Non-Val Elements: If an element isn’t equal to `val`, we place it at the<br/>   current position of `k` and then increment `k`.<br/> - Final Result: By the end of the loop, the first `k` elements in `nums` will contain<br/>   all elements except `val`. `k` is returned, representing the count of elements in `nums`<br/>   that are not equal to `val`.<br/> ### Example Walkthroughs:<br/> 1. Example 1:<br/>    - Input: `nums = [3, 2, 2, 3]`, `val = 3`<br/>    - Output: `2`, `nums = [2, 2, _, _]`<br/>    - Explanation: After removing all occurrences of `val = 3`, the array has two elements<br/>      `[2, 2]` and `k = 2`.<br/> <br/> 2. Example 2:<br/>    - Input: `nums = [0, 1, 2, 2, 3, 0, 4, 2]`, `val = 2`<br/>    - Output: `5`, `nums = [0, 1, 4, 0, 3, _, _, _]`<br/>    - Explanation: After removing all occurrences of `val = 2`, the array has five elements<br/>      `[0, 1, 4, 0, 3]` and `k = 5`.<br/> <br/> ### Complexity:<br/> - Time Complexity: `O(n)`, where `n` is the length of `nums`, as we make a single pass through the array.<br/> - Space Complexity: `O(1)`, as the operation is performed in-place with no additional storage.",
		"category": "Array / String"
	},
	{
		"id": 3,
		"topic": "Remove Duplicates from Sorted Array",
		"code": "var removeDuplicates = function(nums) {\n    // Log the initial state of the input array\n    console.log(`Initial nums: ${nums}`);\n    // Log the length of the input array\n    console.log(`nums.length: ${nums.length}`);\n\n    // Check if the input array is empty\n    if (nums.length === 0) {\n        // If empty, log a message and return 0 as there are no unique elements\n        console.log(\"Input array is empty.\");\n        return 0;\n    }\n\n    // Initialize a pointer `k` to track the position of the last unique element\n    // Since the first element is always unique, we start with k = 1\n    let k = 1; \n\n    // Start iterating through the array from the second element (index 1)\n    for (let i = 1; i < nums.length; i++) {\n        // Log the current element being checked and the previous unique element\n        console.log(`Checking nums[${i}]: ${nums[i]} against nums[${i - 1}]: ${nums[i - 1]}`);\n        \n        // Compare the current element with the last unique element\n        if (nums[i] !== nums[i - 1]) {\n            // If they are different, we found a new unique element\n            console.log(`Found new unique element: ${nums[i]}`);\n            // Assign the current unique element to the position k in the array\n            nums[k] = nums[i]; \n            // Increment k to point to the next position for any future unique elements\n            k++; \n            // Log the updated state of the array containing unique elements so far\n            console.log(`Updated nums: ${nums.slice(0, k)} (unique count: ${k})`);\n        } else {\n            // If they are the same, it's a duplicate; log that a duplicate was found\n            console.log(`Duplicate element found: ${nums[i]}`);\n        }\n    }\n\n    // Log the final count of unique elements found\n    console.log(`Final unique count: ${k}`);\n    // Log the modified array which now contains only the unique elements in the first k positions\n    console.log(`Final modified nums: ${nums.slice(0, k)} (remaining elements are not important)`);\n    \n    // Return the count of unique elements\n    return k;\n};\n",
		"explanation": "Explanation of the Code Logic:<br/><br/>1. Function Declaration: The removeDuplicates function takes an array nums as input and is designed to modify it in place to remove duplicates.<br/><br/>2. Initial Checks: It first logs the input array and its length. If the array is empty, it returns 0, indicating there are no unique elements.<br/><br/>3. Pointer Initialization: The variable `k` is initialized to 1 because the first element is always considered unique.<br/><br/>4. Iterative Comparison: A for loop starts at index 1 and iterates through the array:<br/>   - It compares the current element (nums[i]) with the previous element (nums[i - 1]).<br/>   - If they are different, it identifies the current element as unique, assigns it to nums[k], and increments k.<br/>   - If they are the same, it logs that a duplicate has been found.<br/>5. Final Output: After processing all elements, it logs the count of unique elements and the modified array, which contains only the unique elements up to index k.",
		"category": "Array / String"
	},
	{
		"id": 4,
		"topic": "Remove Duplicates from Sorted Array II",
		"code": "var removeDuplicates = function(nums) {\n    console.log(\"Initial array:\", nums);\n    // Initialize a pointer 'k' to keep track of the position where the next allowable element should be placed.\n    let k = 0;\n\n    // Loop through each element in the input array 'nums' using the index 'i'.\n    for (let i = 0; i < nums.length; i++) {\n        console.log(`Current index i = ${i}, value nums[i] = ${nums[i]}`);\n\n        // Check the conditions to decide if nums[i] can be added.\n        if (k < 2 || nums[i] !== nums[k - 2]) {\n            console.log(`Adding nums[i] = ${nums[i]} at index k = ${k}`);\n            \n            // Place the current element 'nums[i]' at the position 'k' in the array.\n            nums[k] = nums[i];\n            k++;  // Increment 'k' for the next valid placement.\n            \n            console.log(`Updated array: ${nums.slice(0, k)} (length = ${k})`);\n        } else {\n            console.log(`Skipping nums[i] = ${nums[i]} to prevent more than two occurrences`);\n        }\n    }\n\n    // Final state of the modified array.\n    console.log(\"Final modified array:\", nums.slice(0, k));\n    console.log(\"Final length of modified array:\", k);\n\n    return k;\n};\n",
		"explanation": "Detailed Explanation Summary:<br/>1. 'k' is used as both a pointer and a counter:<br/>   - It keeps track of the position in 'nums' where the next valid element should be placed.<br/>   - By the end, 'k' will represent the length of the modified array.<br/>2. As we iterate through each element 'nums[i]', we use two conditions to decide if it should be added to the result:<br/>   - If 'k < 2', we are in the initial phase of the result array where any element is allowed.<br/>   - If 'k >= 2', we add 'nums[i]' only if it’s different from 'nums[k - 2]'.<br/>3. The check 'nums[i] !== nums[k - 2]' ensures that each unique element appears at most twice, by comparing with the element two places back.<br/>4. The function finally returns 'k', the length of the modified array, where each unique element appears at most twice.<br/>   - Elements from 'nums[0]' up to 'nums[k - 1]' represent the final modified array.",
		"category": "Array / String"
	},
	{
		"id": 5,
		"topic": "Majority Element",
		"code": "// Find majority element\nconst majorityElement = function(nums) {\n let count = 0; // Tracks the current \"weight\" of the candidate element.\n let candidate = null; // Stores the potential majority element.\n\n // Phase 1: Find a candidate for the majority element\n for (let i = 0; i < nums.length; i++) {\n if (count === 0) { // If count reaches zero, we choose a new candidate.\n candidate = nums[i];\n }\n // Increment or decrement the count based on whether the current number matches the candidate.\n count += (nums[i] === candidate) ? 1 : -1;\n }\n\n // At this point, `candidate` is the element that could potentially be the majority element.\n\n // Phase 2: Verify if the candidate is indeed the majority element\n count = 0; // Reset count to verify the candidate.\n for (let i = 0; i < nums.length; i++) {\n if (nums[i] === candidate) { // Count occurrences of the candidate in the array.\n count++;\n }\n }\n\n // Check if the candidate occurs more than ⌊n/2⌋ times.\n if (count > Math.floor(nums.length / 2)) {\n return candidate; // Candidate is the majority element.\n }\n // Throw an error if no majority element is found.\n // (Should not happen if the input meets the problem's guarantee.)\n throw new Error(\"No majority element found\");\n};\n\nconsole.log(majorityElement([3, 2, 3])); // Output: 3\n// Explanation: The majority element is 3, as it appears twice (more than 3/2 = 1.5 times).\n\nconsole.log(majorityElement([2, 2, 1, 1, 1, 2, 2])); // Output: 2\n// Explanation: The majority element is 2, as it appears four times (more than 7/2 = 3.5 times).\n",
		"explanation": "Explanation:<br/><br/>1. The algorithm is based on the Boyer-Moore Voting Algorithm.<br/>2. Phase 1:<br/>   - Iterates through the array to identify a potential majority element (`candidate`).<br/>   - Keeps a `count` which increases when the current number matches `candidate` and decreases otherwise.<br/>   - If `count` becomes zero, a new `candidate` is selected.<br/>   - By the end of this phase, `candidate` is guaranteed to be the majority element if one exists.<br/>3. Phase 2:<br/>   - Verifies if the `candidate` appears more than ⌊n/2⌋ times in the array.<br/>   - If yes, it returns the candidate. Otherwise, it throws an error.<br/>4. Time complexity: O(n) - Linear, as the array is traversed twice.<br/>5. Space complexity: O(1) - Constant, as no additional data structures are used.",
		"category": "Array / String"
	},
	{
		"id": 6,
		"topic": "Rotate Array",
		"code": "const rotate = function(nums, k) {\n    // Display the original array and k value to track changes.\n    console.log(\"Original array:\", nums);\n    console.log(\"Original k:\", k);\n\n    // Adjust k if it's greater than the array length:\n    // k % nums.length gives the effective number of rotations needed, \n    // since rotating by the length of the array results in the same array.\n    k = k % nums.length;\n\n    console.log(\"Rotation steps (k):\", k); // Show adjusted k value after modulo operation\n    \n    // Step 1: Reverse the entire array to start the rotation process.\n    // This brings the elements to the \"right-rotated\" positions but in reverse order.\n    reverse(nums, 0, nums.length - 1);\n    console.log(\"After reversing the entire array:\", nums);\n\n    // Step 2: Reverse the first `k` elements to place the rotated part in the correct order.\n    reverse(nums, 0, k - 1);\n    console.log(`After reversing the first ${k} elements:`, nums);\n\n    // Step 3: Reverse the elements from `k` to the end of the array.\n    // This step restores the remaining elements to their original order following the rotated segment.\n    reverse(nums, k, nums.length - 1);\n    console.log(`After reversing the elements from index ${k} to end:`, nums);\n};\n\nfunction reverse(nums, start, end) {\n    while (start < end) {\n        [nums[start], nums[end]] = [nums[end], nums[start]];\n        start++;\n        end--;\n    }\n}\n",
		"explanation": "Explanation of Key Parts:<br/><br/>1. Modulo Operation:<br/>   - `k = k % nums.length` reduces the rotation count by removing unnecessary full-length rotations. For example, rotating an array of length 7 by 7 or any multiple results in no change.<br/><br/>2. Reverse Function:<br/>   - `reverse` swaps elements between the `start` and `end` indices, iterating inward until `start` meets or exceeds `end`. This in-place swap operation reverses the specified segment of the array.<br/><br/>3. Three-Step Array Manipulation:<br/>   - Step 1: Reverse the entire array, setting up the array for a \"right rotation\" by bringing the last `k` elements to the beginning (in reverse order).<br/>   - Step 2: Reverse the first `k` elements, putting the rotated segment in its final, correct order.<br/>   - Step 3: Reverse the remaining elements to restore the rest of the array to its original sequence after the rotated portion.",
		"category": "Array / String"
	},
	{
		"id": 7,
		"topic": "Best Time to Buy and Sell Stock",
		"code": "// Find the maximum profit\nvar maxProfit = function(prices) {\n let minPrice = Infinity; // Initialize the minimum price as Infinity. This will be used to find the lowest price seen so far.\n let maxProfit = 0; // Initialize the maximum profit as 0. This will store the highest profit we can achieve.\n\n // Iterate through each price in the array\n for (let price of prices) {\n if (price < minPrice) {\n minPrice = price; // If the current price is lower than the minimum price seen so far, update minPrice.\n } else {\n // If the current price is not lower than minPrice, calculate the potential profit\n // by subtracting minPrice from the current price.\n maxProfit = Math.max(maxProfit, price - minPrice);\n // Update maxProfit only if the calculated profit is greater than the current maxProfit.\n }\n }\n\n return maxProfit; // After iterating through the array, return the maximum profit found.\n};\n\nlet prices1 = [7, 1, 5, 3, 6, 4];\nconsole.log(maxProfit(prices1)); // Output: 5\n// Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5.\n\nlet prices2 = [7, 6, 4, 3, 1];\nconsole.log(maxProfit(prices2)); // Output: 0\n// Explanation: No transactions are possible since prices keep decreasing. Profit = 0.\n",
		"explanation": "Explanation:<br/>1. We iterate through the `prices` array to simulate buying and selling the stock.<br/>2. `minPrice` keeps track of the lowest price seen so far, ensuring that we always \"buy\" at the lowest possible price.<br/>3. For each price in the array:<br/>   - If it is lower than `minPrice`, update `minPrice` (simulate finding a better day to buy).<br/>   - Otherwise, calculate the profit if we \"sell\" on the current day. Compare this profit with the current `maxProfit` and update it if the new profit is higher.<br/>4. If no profit is possible (prices keep decreasing), `maxProfit` remains 0.<br/>5. The algorithm ensures we only traverse the array once, making it efficient with O(n) time complexity.",
		"category": "Array / String"
	},
	{
		"id": 8,
		"topic": "Best Time to Buy and Sell Stock II",
		"code": "// Find the maximum profit with multiple transactions\nvar maxProfit = function(prices) {\n let maxProfit = 0;\n\n for (let i = 1; i < prices.length; i++) {\n // If the price today is higher than the price yesterday,\n // it means we can make a profit by selling the stock.\n if (prices[i] > prices[i - 1]) {\n // Add the difference between today's price and yesterday's price to maxProfit\n maxProfit += prices[i] - prices[i - 1];\n }\n }\n\n // Return the total profit achieved from all profitable transactions\n return maxProfit;\n};\n\n// Example 1:\nconsole.log(maxProfit([7,1,5,3,6,4])); // Output: 7\n// Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5 - 1 = 4.\n// Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6 - 3 = 3.\n// Total profit = 4 + 3 = 7.\n\n// Example 2:\nconsole.log(maxProfit([1,2,3,4,5])); // Output: 4\n// Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5 - 1 = 4.\n// Total profit = 4.\n\n// Example 3:\nconsole.log(maxProfit([7,6,4,3,1])); // Output: 0\n// Explanation: No profitable opportunities since prices keep decreasing.\n// Total profit = 0.\n",
		"explanation": "Explanation:<br/><br/>- We are given an array 'prices' where each element represents the price of a stock on a given day.<br/>- The goal is to maximize profit by buying and selling the stock at the right times.<br/>- The key observation is that you can make a profit if the stock price increases from one day to the next.<br/>- On each day, if the price is higher than the previous day's price, we \"buy\" on the previous day and \"sell\" on the current day. The profit from this transaction is the difference between the two prices.<br/>- We repeat this for all days, adding the profits from each transaction, to get the total maximum profit.<br/>- The approach runs in linear time O(n), where n is the number of days in the 'prices' array.",
		"category": "Array / String"
	},
	{
		"id": 9,
		"topic": "Jump Game",
		"code": "// Determine if you can reach the last index\nvar canJump = function(nums) {\n // Initialize the farthest index that can be reached.\n let farthest = 0;\n\n // Iterate through the array.\n for (let i = 0; i < nums.length; i++) {\n // If the current index is greater than the farthest index reachable, return false.\n if (i > farthest) {\n return false;\n }\n\n // Update the farthest reachable index.\n farthest = Math.max(farthest, i + nums[i]);\n\n // If we can reach or exceed the last index, return true.\n if (farthest >= nums.length - 1) {\n return true;\n }\n }\n\n // If the loop completes, we return true.\n return true;\n};\n\n// Example usage:\nconsole.log(canJump([2, 3, 1, 1, 4])); // Output: true\nconsole.log(canJump([3, 2, 1, 0, 4])); // Output: false\n",
		"explanation": "The goal is to determine whether we can jump from the first index to the last index in the array. Each element in the array represents the maximum jump length from that position.<br/><br/>Key Idea:<br/>- Use a greedy approach to track the farthest index we can reach (`farthest`) as we iterate through the array.<br/>- At each step, calculate how far we can jump from the current position and update `farthest` with the maximum possible value.<br/>- If `farthest` becomes greater than or equal to the last index (`nums.length - 1`), return `true`. If the current index (`i`) exceeds `farthest`, return `false` because it's not reachable.<br/><br/>### Why `Math.max(farthest, i + nums[i])` is used:<br/><br/>- `i + nums[i]`:<br/> - Represents the farthest index you can jump to from the current position `i`.<br/> - For example:<br/> - At `i = 2` with `nums[2] = 3`, you can jump to index `2 + 3 = 5`.<br/> - This is the maximum jump length starting from the current position.<br/><br/>- `Math.max(farthest, i + nums[i])`:<br/> - Ensures we always keep track of the farthest point reachable so far as we iterate.<br/> - For example:<br/> - If `farthest = 4` and at `i = 2` you can reach index 5 (`i + nums[i] = 5`), update `farthest` to 5.<br/> - However, if at `i = 3` you can only reach index 4 (`i + nums[i] = 4`), `farthest` remains 5 because it’s the maximum of `farthest` and `i + nums[i]`.<br/><br/>This allows us to dynamically track the farthest position we can reach without needing additional checks or backtracking.<br/><br/>### Steps in the Algorithm:<br/>1. Initialize `farthest`:<br/> - Start with `farthest = 0`, representing the maximum index reachable initially.<br/><br/>2. Iterate Through the Array:<br/> - For each index `i`:<br/> - If the current index `i` exceeds `farthest`, return `false` because we cannot proceed further.<br/> - Otherwise, calculate the farthest position reachable so far with `farthest = Math.max(farthest, i + nums[i])`.<br/><br/>3. Check for Success:<br/> - If at any point `farthest >= nums.length - 1`, return `true` because we can reach the last index.<br/><br/>4. Complete Iteration:<br/> - If the loop completes without returning `true` or `false`, return `true` as the last index is reachable.<br/><br/>Examples:<br/><br/>Example 1:<br/>Input: `nums = [2, 3, 1, 1, 4]`<br/>1. Start: `farthest = 0`<br/>2. At index 0: `farthest = Math.max(0, 0 + 2) = 2`.<br/>3. At index 1: `farthest = Math.max(2, 1 + 3) = 4`.<br/>4. Since `farthest (4) >= nums.length - 1 (4)`, return `true`.<br/><br/>Example 2:<br/>Input: `nums = [3, 2, 1, 0, 4]`<br/>1. Start: `farthest = 0`<br/>2. At index 0: `farthest = Math.max(0, 0 + 3) = 3`.<br/>3. At index 1: `farthest = Math.max(3, 1 + 2) = 3`.<br/>4. At index 2: `farthest = Math.max(3, 2 + 1) = 3`.<br/>5. At index 3: `farthest = Math.max(3, 3 + 0) = 3`.<br/>6. At index 4: `i (4) > farthest (3)`, return `false`.<br/><br/>Why `Math.max` is Crucial:<br/>- Without it, we would only consider the current jump (`i + nums[i]`) without accounting for previously calculated maximum jumps.<br/>- This would lead to incorrect results, as we’d lose track of the longest reachable index from earlier iterations.<br/><br/>Complexity:<br/><br/>Time Complexity: O(n)<br/>- We traverse the array once, making the algorithm linear in time.<br/><br/>Space Complexity: O(1)<br/>- No additional space is used beyond the variables for tracking indices.",
		"category": "Array / String"
	},
	{
		"id": 10,
		"topic": "Jump Game II",
		"code": "// Find the minimum number of jumps to reach the last index\nvar jump = function(nums) {\n // If the array has only one element, no jumps are needed.\n if (nums.length === 1) return 0;\n\n // Initialize variables to track the current range of reachable indices and jumps.\n let jumps = 0;\n let currentEnd = 0; // The farthest index we can reach within the current jump.\n let farthest = 0; // The farthest index we can reach with the next jump.\n\n // Iterate through the array up to the second-to-last index (since reaching the last index ends the process).\n for (let i = 0; i < nums.length - 1; i++) {\n // Update the farthest reachable index. \n // Math.max returns the larger of the two numbers x and y\n farthest = Math.max(farthest, i + nums[i]); // greedy part of the algorithm\n\n // If we reach the end of the current range (currentEnd), increment the jump counter.\n if (i === currentEnd) {\n jumps++;\n currentEnd = farthest;\n\n // If the farthest index covers the last index, we can exit early.\n if (currentEnd >= nums.length - 1) break;\n }\n }\n\n return jumps;\n};\n\n\nconsole.log(jump([2, 3, 1, 1, 4])); // expected output 2\nconsole.log(jump([2, 3, 0, 1, 4])); // expected output 2\n",
		"explanation": "This problem can be solved using a greedy approach to minimize the number of jumps.<br/><br/>Key Concepts:<br/>1. Tracking the Current Range:<br/>   - We maintain a variable `currentEnd` to track the range of indices reachable with the current jump.<br/>   - If we reach `currentEnd`, we increment the jump counter and update `currentEnd` to the `farthest` index reachable.<br/><br/>2. Farthest Reachable Index:<br/>   - At each step, we calculate the farthest index we can jump to from the current position using `Math.max(farthest, i + nums[i])`.<br/><br/>3. Stopping Early:<br/>   - Once `currentEnd` (the range of indices reachable with the current jump) reaches or exceeds the last index, we can stop.<br/><br/>Steps in the Algorithm:<br/>1. Edge Case:<br/>   - If `nums.length === 1`, no jumps are needed (`return 0`).<br/><br/>2. Initialize Variables:<br/>   - `jumps` starts at 0 to count the number of jumps.<br/>   - `currentEnd` starts at 0 to represent the range of indices reachable with the current jump.<br/>   - `farthest` starts at 0 to calculate the farthest reachable index in the next jump.<br/><br/>3. Iterate Through the Array:<br/>   - For each index `i` up to `nums.length - 2`:<br/>     - Update `farthest` to the maximum of the current `farthest` and `i + nums[i]`.<br/>     - If `i === currentEnd`:<br/>       - Increment `jumps` because the current range is exhausted.<br/>       - Update `currentEnd` to `farthest`.<br/><br/>4. Return Jumps:<br/>   - When the loop completes, `jumps` contains the minimum number of jumps needed.<br/><br/>Examples:<br/><br/>Example 1:<br/>Input: `nums = [2, 3, 1, 1, 4]`<br/>1. Start: `jumps = 0, currentEnd = 0, farthest = 0`<br/>2. At index 0: `farthest = max(0, 0 + 2) = 2`.<br/>   - `i === currentEnd`: Increment `jumps` to 1, update `currentEnd = 2`.<br/>3. At index 1: `farthest = max(2, 1 + 3) = 4`.<br/>   - `i === currentEnd`: Increment `jumps` to 2, update `currentEnd = 4`.<br/>   - Since `currentEnd >= nums.length - 1`, stop early.<br/>Output: `2`<br/><br/>Example 2:<br/>Input: `nums = [2, 3, 0, 1, 4]`<br/>1. Start: `jumps = 0, currentEnd = 0, farthest = 0`<br/>2. At index 0: `farthest = max(0, 0 + 2) = 2`.<br/>   - `i === currentEnd`: Increment `jumps` to 1, update `currentEnd = 2`.<br/>3. At index 1: `farthest = max(2, 1 + 3) = 4`.<br/>   - `i === currentEnd`: Increment `jumps` to 2, update `currentEnd = 4`.<br/>   - Since `currentEnd >= nums.length - 1`, stop early.<br/>Output: `2`<br/><br/>Complexity:<br/><br/>Time Complexity: O(n)<br/>- We iterate through the array once.<br/><br/>Space Complexity: O(1)<br/>- Only a few variables are used for tracking indices.",
		"category": "Array / String"
	},
	{
		"id": 11,
		"topic": "H-Index",
		"code": "// Calculate H-Index\nvar hIndex = function(citations) {\n    // Sort the citations array in descending order to arrange papers from most to least cited.\n    citations.sort((a, b) => b - a);\n    \n    let h = 0; // Initialize h-index to 0. This will hold the highest possible h-index found.\n    \n    // Iterate through the sorted citations array to determine the h-index.\n    for (let i = 0; i < citations.length; i++) {\n        // Check if the current paper's citations are greater than or equal to the index+1 (papers with >= i+1 citations).\n        if (citations[i] >= i + 1) {\n            h = i + 1; // Update the h-index to reflect that we have at least (i+1) papers with >= (i+1) citations.\n        } else {\n            break; // If we find a paper with fewer than (i+1) citations, we can stop as the remaining papers will have even fewer.\n        }\n    }\n    \n    return h; // Return the computed h-index.\n};\n\n// Example usage:\nconsole.log(hIndex([3, 0, 6, 1, 5])); // Output: 3\nconsole.log(hIndex([1, 3, 1]));       // Output: 1\n",
		"explanation": "1. Sorting the citations array:<br/>   - We begin by sorting the citations in descending order to easily compare papers with high citations first.<br/>   - Example: Given citations = [3, 0, 6, 1, 5], after sorting, it becomes [6, 5, 3, 1, 0].<br/><br/>2. Finding the h-index:<br/>   - We iterate through the sorted array, where each index `i` represents the number of papers (indexed from 0) that have at least `i+1` citations.<br/>   - For each paper at index `i`:<br/>     - If the citations at index `i` are greater than or equal to `i + 1`, this means that there are at least `i+1` papers with `i+1` or more citations. We update the h-index to `i + 1`.<br/>     - If the condition fails, we stop the iteration because subsequent papers will have fewer citations, making it impossible to increase the h-index further.<br/><br/>3. Example Breakdown:<br/>   - For citations = [3, 0, 6, 1, 5], after sorting, the array becomes [6, 5, 3, 1, 0].<br/>   - At index 0: citations[0] = 6, 1 paper has at least 6 citations, so h = 1.<br/>   - At index 1: citations[1] = 5, 2 papers have at least 5 citations, so h = 2.<br/>   - At index 2: citations[2] = 3, 3 papers have at least 3 citations, so h = 3.<br/>   - At index 3: citations[3] = 1, but we need at least 4 papers with 4 or more citations, which is not the case, so we stop.<br/><br/>   Final h-index = 3, because there are 3 papers with at least 3 citations each.<br/><br/>Time Complexity:<br/>- Sorting the array takes O(n log n), where `n` is the length of the `citations` array.<br/>- Iterating through the array takes O(n).<br/>- Overall time complexity is O(n log n).<br/><br/>Space Complexity:<br/>- We are sorting the array in-place, so the space complexity is O(1) for additional space (aside from the input).",
		"category": "Array / String"
	},
	{
		"id": 12,
		"topic": "Insert Delete GetRandom O(1)",
		"code": "// Class to implement a randomized set\nvar RandomizedSet = function() {\n    this.map = new Map(); // Maps each value to its index in the 'list' array for O(1) lookups\n    this.list = [];       // Stores values for efficient random access\n};\n\n/** \n * Inserts a value into the set.\n * @param {number} val - The value to insert.\n * @return {boolean} - Returns true if the value was inserted, false if it already exists.\n */\n\nRandomizedSet.prototype.insert = function(val) {\n    // Check if the value already exists in the map\n    if (this.map.has(val)) return false;\n\n    // Add value to the list\n    this.list.push(val);\n\n    // Store the index of the newly added value in the map\n    this.map.set(val, this.list.length - 1);\n\n    return true; // Successfully inserted\n};\n\n/** \n * Removes a value from the set.\n * @param {number} val - The value to remove.\n * @return {boolean} - Returns true if the value was removed, false if it doesn't exist.\n */\n\nRandomizedSet.prototype.remove = function(val) {\n    // Check if the value exists in the map\n    if (!this.map.has(val)) return false;\n\n    // Retrieve the index of the value to be removed\n    const index = this.map.get(val);\n\n    // Get the last value in the list\n    const lastValue = this.list[this.list.length - 1];\n\n    // Replace the value at the index with the last value (swap)\n    this.list[index] = lastValue;\n\n    // Update the map to reflect the new index of the last value\n    this.map.set(lastValue, index);\n\n    // Remove the last element from the list (constant-time removal)\n    this.list.pop();\n\n    // Delete the value from the map\n    this.map.delete(val);\n\n    return true; // Successfully removed\n};\n\n/**\n * Returns a random value from the set.\n * @return {number} - A randomly selected value.\n */\n\nRandomizedSet.prototype.getRandom = function() {\n    // Generate a random index between 0 and list.length - 1\n    const randomIndex = Math.floor(Math.random() * this.list.length);\n\n    // Return the value at the generated index\n    return this.list[randomIndex];\n};\n\n/** \n * Usage Example:\n * var obj = new RandomizedSet();\n * var param_1 = obj.insert(val);\n * var param_2 = obj.remove(val);\n * var param_3 = obj.getRandom();\n */\n\n// Testing the functionality\nvar randomizedSet = new RandomizedSet();\nconsole.log(randomizedSet.insert(1));    // true: Adds 1 to the set\nconsole.log(randomizedSet.remove(2));    // false: 2 is not in the set\nconsole.log(randomizedSet.insert(2));    // true: Adds 2 to the set\nconsole.log(randomizedSet.getRandom());  // 1 or 2: Randomly selects one of the values\nconsole.log(randomizedSet.remove(1));    // true: Removes 1 from the set\nconsole.log(randomizedSet.insert(2));    // false: 2 is already in the set\nconsole.log(randomizedSet.getRandom());  // 2: 2 is the only value in the set\n",
		"explanation": "The `RandomizedSet` class is a data structure that supports the following operations in average O(1) time:<br/>1. `insert(val)`: Inserts a value into the set if it is not already present. Returns `true` if the value was added, and `false` if it already exists.<br/>2. `remove(val)`: Removes a value from the set if it exists. Returns `true` if the value was removed, and `false` if it does not exist.<br/>3. `getRandom()`: Returns a random value from the set. Each value has an equal probability of being selected.<br/><br/>Implementation Details:<br/><br/>1. Constructor (`RandomizedSet`):<br/>   - `this.map`: A `Map` object that maps values to their indices in the `list` array. This allows for constant-time lookup of values.<br/>   - `this.list`: An array that stores all the values. This array supports fast access for random selection.<br/><br/>2. Insert Operation (`insert(val)`):<br/>   - Checks if `val` is already in the `map` using `this.map.has(val)`. If it exists, return `false`.<br/>   - If not, appends `val` to `this.list` and updates the `map` with the value's index (`this.list.length - 1`).<br/>   - Returns `true` to indicate the value was successfully added.<br/><br/>3. Remove Operation (`remove(val)`):<br/>   - Checks if `val` exists in `this.map`. If not, return `false`.<br/>   - Retrieves the index of `val` from the `map`.<br/>   - Swaps the value at this index with the last value in `this.list` to maintain efficient removal.<br/>     - Updates the `map` to reflect the new index of the last value.<br/>   - Removes the last element of the `list` using `pop()` and deletes the entry for `val` in `this.map`.<br/>   - Returns `true` to indicate the value was successfully removed.<br/><br/>4. Get Random Operation (`getRandom()`):<br/>   - Generates a random index using `Math.random()` and the length of the `list`.<br/>   - Returns the value at the random index in `this.list`.<br/><br/>Example Walkthrough:<br/><br/>- `randomizedSet.insert(1)`:<br/>  - Adds `1` to the set. Updates `map` to `{1: 0}` and `list` to `[1]`.<br/>  - Returns `true`.<br/><br/>- `randomizedSet.remove(2)`:<br/>  - Fails because `2` is not in the set.<br/>  - Returns `false`.<br/><br/>- `randomizedSet.insert(2)`:<br/>  - Adds `2` to the set. Updates `map` to `{1: 0, 2: 1}` and `list` to `[1, 2]`.<br/>  - Returns `true`.<br/><br/>- `randomizedSet.getRandom()`:<br/>  - Randomly returns either `1` or `2`, as both have equal probability.<br/><br/>- `randomizedSet.remove(1)`:<br/>  - Removes `1`. Swaps `1` with the last value (`2`) in the `list`.<br/>  - Updates `map` to `{2: 0}` and `list` to `[2]`.<br/>  - Returns `true`.<br/><br/>- `randomizedSet.insert(2)`:<br/>  - Fails because `2` is already in the set.<br/>  - Returns `false`.<br/><br/>- `randomizedSet.getRandom()`:<br/>  - Returns `2`, as it is the only value in the set.<br/><br/>Time Complexity:<br/>1. `insert(val)`: O(1), as it performs constant-time operations on the `map` and `list`.<br/>2. `remove(val)`: O(1), as it swaps and pops elements in the `list` and updates the `map`.<br/>3. `getRandom()`: O(1), as it accesses a random index in the `list`.<br/><br/>Space Complexity:<br/>- The space complexity is O(n), where `n` is the number of elements in the set. The `list` and `map` both store references to the elements.",
		"category": "Array / String"
	},
	{
		"id": 13,
		"topic": "Product of Array Except Self",
		"code": "// Calculate product of array except self\nvar productExceptSelf = function(nums) {\n const length = nums.length; // Get the length of the input array\n const result = new Array(length).fill(1); // Initialize the result array with 1s\n\n // Step 1: Calculate the prefix product for each element\n let cumulativeProductFromLeft = 1;\n for (let i = 0; i < length; i++) {\n result[i] = cumulativeProductFromLeft; // Store the product of elements to the left of nums[i]\n cumulativeProductFromLeft *= nums[i]; // Update the cumulative product from the left\n // The '*=' operator multiplies the variable by the value on the right and reassigns the result.\n // Equivalent to: cumulativeProductFromLeft = cumulativeProductFromLeft * nums[i]\n }\n\n // Step 2: Calculate the suffix product and update the result array\n let cumulativeProductFromRight = 1;\n for (let i = length - 1; i >= 0; i--) {\n result[i] *= cumulativeProductFromRight;  // Update result[i] by multiplying with cumulativeProductFromRight\n cumulativeProductFromRight *= nums[i];   // Update the cumulative product from the right\n // The '*=' operator multiplies the current value of result[i] \n // by cumulativeProductFromRight and updates result[i] with the product.\n // Equivalent to: result[i] = result[i] * cumulativeProductFromRight\n }\n\n return result; // Return the result array\n};\n\n// Examples:\nconsole.log(productExceptSelf([1, 2, 3, 4])); // Output: [24, 12, 8, 6]\nconsole.log(productExceptSelf([-1, 1, 0, -3, 3])); // Output: [0, 0, 9, 0, 0]\n",
		"explanation": "1. Initialization:<br/>   - Create an array `result` of the same size as `nums`, initialized with 1s.<br/>   - Use two variables, `cumulativeProductFromLeft` and `cumulativeProductFromRight`, to store the running product of elements from the left and right of the current element.<br/><br/>2. First Loop (Prefix Products):<br/>   - Traverse the array from left to right.<br/>   - For each index `i`, store the product of all elements to the left of `nums[i]` in `result[i]`.<br/>   - Update `cumulativeProductFromLeft` by multiplying it with the current element `nums[i]`.<br/>     - The `*=` operator is shorthand for multiplying a variable by a value and assigning the result back to the variable.<br/>       - Example: `x *= y` is equivalent to `x = x * y`.<br/><br/>3. Second Loop (Suffix Products):<br/>   - Traverse the array from right to left.<br/>   - For each index `i`, multiply `result[i]` (which already contains the prefix product) by the cumulative product of all elements to the right of `nums[i]`.<br/>   - Update `cumulativeProductFromRight` by multiplying it with the current element `nums[i]`.<br/>     - Again, `*=` updates the variable with the result of the multiplication.<br/><br/>4. Key Idea:<br/>   - The final value at `result[i]` is the product of all elements to the left of `nums[i]` (calculated in the first loop) and all elements to the right of `nums[i]` (calculated in the second loop).<br/>   - By avoiding division and performing two passes, the algorithm achieves O(n) time complexity.<br/><br/>5. Space Complexity:<br/>   - The algorithm uses O(1) additional space (excluding the output array) as it only requires two variables, `cumulativeProductFromLeft` and `cumulativeProductFromRight`.<br/><br/>6. Example Walkthrough:<br/>   - Input: `nums = [1, 2, 3, 4]`<br/>   <br/>   Prefix Pass:<br/>   - i = 0:<br/>     - result[0] = 1 (No elements to the left)<br/>     - cumulativeProductFromLeft = 1 * 1 = 1<br/>   - i = 1:<br/>     - result[1] = 1 (Product of elements to the left of 2: 1)<br/>     - cumulativeProductFromLeft = 1 * 2 = 2<br/>   - i = 2:<br/>     - result[2] = 2 (Product of elements to the left of 3: 1 * 2)<br/>     - cumulativeProductFromLeft = 2 * 3 = 6<br/>   - i = 3:<br/>     - result[3] = 6 (Product of elements to the left of 4: 1 * 2 * 3)<br/>     - cumulativeProductFromLeft = 6 * 4 = 24<br/>   <br/>   After the first loop (Prefix Pass):<br/>   - result = [1, 1, 2, 6]<br/>   <br/>   Suffix Pass:<br/>   - i = 3:<br/>     - result[3] = 6 * 1 (No elements to the right)<br/>     - cumulativeProductFromRight = 1 * 4 = 4<br/>   - i = 2:<br/>     - result[2] = 2 * 4 = 8 (Product of elements to the right of 3: 4)<br/>     - cumulativeProductFromRight = 4 * 3 = 12<br/>   - i = 1:<br/>     - result[1] = 1 * 12 = 12 (Product of elements to the right of 2: 3 * 4)<br/>     - cumulativeProductFromRight = 12 * 2 = 24<br/>   - i = 0:<br/>     - result[0] = 1 * 24 = 24 (Product of elements to the right of 1: 2 * 3 * 4)<br/>     - cumulativeProductFromRight = 24 * 1 = 24<br/>   <br/>   After the second loop (Suffix Pass):<br/>   - result = [24, 12, 8, 6]<br/>   - Output: `[24, 12, 8, 6]`<br/><br/>7. Edge Cases:<br/>   - Input: `nums = [-1, 1, 0, -3, 3]`<br/>     - Prefix Pass: `result = [1, -1, 0, 0, 0]`<br/>     - Suffix Pass: `result = [0, 0, 9, 0, 0]`<br/>     - Output: `[0, 0, 9, 0, 0]`<br/>   - Handles cases with zeros and negative numbers correctly.",
		"category": "Array / String"
	},
	{
		"id": 14,
		"topic": "Gas Station",
		"code": "// Find the starting gas station\nvar canCompleteCircuit = function(gas, cost) {\n const numStations = gas.length;  // Number of gas stations\n let totalGas = 0;  // Total gas available from all stations\n let totalCost = 0;  // Total cost to travel around the circuit\n let currentGas = 0;  // Current gas level while traveling\n let startIndex = 0;  // Index of the current potential starting station\n\n // Traverse through all stations and calculate the total gas and cost\n for (let station = 0; station < numStations; station++) {\n totalGas += gas[station];  // Accumulate total available gas\n totalCost += cost[station];  // Accumulate total cost to travel\n\n // Update the current gas level after traveling to the next station\n currentGas += gas[station] - cost[station];\n\n // If the current gas level becomes negative, it means we cannot start from 'startIndex'\n if (currentGas < 0) {\n // Reset the starting station to the next station\n startIndex = station + 1;\n currentGas = 0;  // Reset the current gas level for the next start attempt\n }\n }\n\n // If the total gas available is less than the total cost required, return -1 (impossible to complete the circuit)\n if (totalGas < totalCost) {\n return -1;\n }\n\n // Return the index of the station from where the circuit can be completed\n return startIndex;\n};\n\n// Example 1\nlet gas1 = [1, 2, 3, 4, 5];\nlet cost1 = [3, 4, 5, 1, 2];\nconsole.log(canCompleteCircuit(gas1, cost1));  // Output: 3\n\n// Example 2\nlet gas2 = [2, 3, 4];\nlet cost2 = [3, 4, 3];\nconsole.log(canCompleteCircuit(gas2, cost2));  // Output: -1\n\n// Example 3\nlet gas3 = [5, 1, 2, 3, 4];\nlet cost3 = [4, 4, 4, 4, 5];\nconsole.log(canCompleteCircuit(gas3, cost3));  // Output: 0\n\n// Example 4\nlet gas4 = [2, 3, 4, 5, 6];\nlet cost4 = [3, 4, 5, 6, 7];\nconsole.log(canCompleteCircuit(gas4, cost4));  // Output: -1\n",
		"explanation": "The problem asks to determine if a car can travel around a circular route consisting of `n` gas stations. The car has an unlimited gas tank, but each station provides a certain amount of gas (`gas[i]`), and traveling from one station to the next requires a specific amount of gas (`cost[i]`). You need to find the starting gas station index from where the car can complete the full circuit, or return -1 if no such station exists.<br/><br/>Approach:<br/><br/>1. Initialization:<br/> - We start by defining some variables:<br/>   - `numStations`: The number of gas stations.<br/>   - `totalGas`: The sum of gas available at all stations.<br/>   - `totalCost`: The total gas required to travel through all stations.<br/>   - `currentGas`: The amount of gas the car currently has while trying to make the trip.<br/>   - `startIndex`: The index of the station that might be the valid starting point.<br/><br/>2. Iterating Through the Stations:<br/> - We loop over each station to compute the total gas and total cost required for the circuit. We also track the `currentGas` while attempting to travel from one station to the next.<br/> - At each station, we add the gas available at the station to `totalGas` and subtract the cost of traveling to the next station from `totalCost`.<br/> - We update `currentGas` by adding the available gas at the current station and subtracting the travel cost to the next station.<br/><br/>3. Checking Feasibility of Starting from Current Station:<br/> - If at any point `currentGas` becomes negative, it means we cannot complete the circuit starting from the current `startIndex`. In this case, we reset `startIndex` to the next station (`station + 1`) and reset `currentGas` to 0. This is because if we can't reach the next station from the current starting point, any station before it will also fail.<br/><br/>4. Final Check:<br/> - After the loop, we check if the total gas available (`totalGas`) is less than the total cost required (`totalCost`). If it is, then completing the circuit is impossible, and we return -1.<br/> - If `totalGas` is greater than or equal to `totalCost`, the circuit is possible, and we return `startIndex`, which represents the first station from which the car can complete the circuit.<br/><br/>Time Complexity:<br/>- O(n): We only loop through the stations once, making the time complexity linear.<br/><br/>Space Complexity:<br/>- O(1): We use a constant amount of space for the variables, regardless of the input size.",
		"category": "Array / String"
	},
	{
		"id": 15,
		"topic": "Candy",
		"code": "var candy = function (ratings) {\n const numChildren = ratings.length;  // Get the number of children\n\n // Initialize an array with one candy for each child.\n let candyDistribution = new Array(numChildren).fill(1);  // Start with 1 candy per child\n\n // Left to right pass to ensure children with higher ratings get more candies.\n for (let i = 1; i < numChildren; i++) {  // Loop through the ratings\n if (ratings[i] > ratings[i - 1]) {  // If the current rating is higher\n candyDistribution[i] = candyDistribution[i - 1] + 1;  // Give more candy than the previous child\n }\n }\n\n // Right to left pass to adjust candy for children with higher ratings than the next one.\n for (let i = numChildren - 2; i >= 0; i--) {  // Loop backwards through the ratings\n if (ratings[i] > ratings[i + 1]) {  // If the current rating is higher\n candyDistribution[i] = Math.max(  // Take the higher candy count\n candyDistribution[i],  // Keep the current count if higher\n candyDistribution[i + 1] + 1  // Otherwise, add one more than the next child\n );\n }\n }\n\n // Sum up the total candies.\n return candyDistribution.reduce(  // Add up all the candies\n (totalCandies, currentCandies) => totalCandies + currentCandies,  // Accumulate the total\n 0  // Start the sum at 0\n );\n};\n\n// Example \nlet ratings1 = [1, 0, 2];\nconsole.log(\"Example 1 - Ratings:\", ratings1);\nconsole.log(\"Total Candies:\", candy(ratings1));  // Output should be 5\n\n// Example 2\nlet ratings2 = [1, 2, 2];\nconsole.log(\"Example 2 - Ratings:\", ratings2);\nconsole.log(\"Total Candies:\", candy(ratings2));  // Output should be 4\n\n// Example 3\nlet ratings3 = [3, 2, 1, 4, 5, 2];\nconsole.log(\"Example 3 - Ratings:\", ratings3);\nconsole.log(\"Total Candies:\", candy(ratings3));  // Output should be 11\n\n// Example 4\nlet ratings4 = [1, 3, 2, 2, 1];\nconsole.log(\"Example 4 - Ratings:\", ratings4);\nconsole.log(\"Total Candies:\", candy(ratings4));  // Output should be 7\n",
		"explanation": "This problem is a typical greedy approach where we need to distribute candies to children based on their ratings while satisfying certain conditions. The conditions are:<br/><br/>1. Each child must receive at least one candy.<br/>2. Children with higher ratings should receive more candies than their neighbors.<br/><br/>The solution is broken down into two passes over the ratings array:<br/><br/>1. Left to Right Pass:<br/> - We start by giving each child one candy.<br/> - As we iterate through the list, we check if the current child has a higher rating than the previous one.<br/> - If so, we increase their candy count to be one more than the previous child’s candy count.<br/> - This ensures that children with higher ratings than their left neighbor receive more candies.<br/><br/>2. Right to Left Pass:<br/> - After the left to right pass, we perform another pass from right to left.<br/> - This ensures that children with higher ratings than their right neighbor get more candies, while respecting the candy distribution from the first pass.<br/> - If a child has a higher rating than the next one, we update their candy count to be the maximum of their current candy count or one more than the next child's candy count.<br/><br/>Finally, the total number of candies is the sum of all elements in the `candyDistribution` array.<br/><br/>Time Complexity:<br/> - O(n): We make two passes through the array, where `n` is the number of children (i.e., the length of the `ratings` array).<br/><br/>Space Complexity:<br/> - O(n): We use an array `candyDistribution` to store the candy count for each child, which requires space proportional to the number of children.",
		"category": "Array / String"
	},
	{
		"id": 16,
		"topic": "Trapping Rain Water",
		"code": "// Calculate trapped rain water\nvar trap = function (height) {\n let left = 0,\n right = height.length - 1; // Initialize two pointers\n let left_max = 0,\n right_max = 0; // Initialize the max heights from left and right\n let waterTrapped = 0; // Variable to accumulate the water trapped\n while (left <= right) {\n if (height[left] <= height[right]) {\n if (height[left] >= left_max) {\n left_max = height[left]; // Update left_max\n } else {\n waterTrapped += left_max - height[left];\n }\n left++; // Move the left pointer to the right\n } else {\n if (height[right] >= right_max) {\n right_max = height[right]; // Update right_max\n } else {\n waterTrapped += right_max - height[right];\n }\n right--; // Move the right pointer to the left\n }\n }\n return waterTrapped; // Return the total trapped water\n};\n\n// Example 1\nlet height1 = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1];\nconsole.log('Example 1 - Trapped Water:', trap(height1)); // Output should be 6\n\n// Example 2\nlet height2 = [4, 2, 0, 3, 2, 5];\nconsole.log('Example 2 - Trapped Water:', trap(height2)); // Output should be 9\n",
		"explanation": "This problem involves calculating the amount of water that can be trapped between bars after raining, given an array representing the heights of the bars. The goal is to find how much water can be trapped between the bars after a rainfall.<br/><br/>We use a two-pointer approach to solve this problem efficiently:<br/><br/>1. Two Pointers:<br/> - We initialize two pointers, `left` at the beginning of the array and `right` at the end. These pointers will move towards each other as we calculate the trapped water.<br/><br/>2. Tracking Max Heights:<br/> - We keep track of the maximum heights encountered so far from both the left (`left_max`) and the right (`right_max`). These values help determine how much water can be trapped at each position.<br/><br/>3. Water Trapping Logic:<br/> - We compare the heights at the `left` and `right` pointers:<br/> - If the height at `left` is smaller than or equal to the height at `right`, we check if the current height at `left` is smaller than `left_max`. If it is, water is trapped, and we add the difference between `left_max` and `height[left]` to the total trapped water. If not, we update `left_max` and move the `left` pointer to the right.<br/> - If the height at `right` is smaller, we perform the same logic but for the `right` pointer, updating `right_max` and moving the `right` pointer to the left.<br/><br/>4. Summing the Water:<br/> - The total trapped water is accumulated as we traverse the array from both ends to the center, ensuring that we calculate the trapped water based on the highest possible barriers on either side.<br/><br/>5. Termination:<br/> - The process continues until the `left` and `right` pointers meet, and the total trapped water is returned.<br/><br/>Time Complexity:<br/> - O(n), where `n` is the number of elements in the input array. We only need to make a single pass through the array.<br/><br/>Space Complexity:<br/> - O(1), since we only use a constant amount of extra space for the `left_max`, `right_max`, and `waterTrapped` variables.<br/><br/>The algorithm efficiently computes the total trapped water using a greedy approach with two pointers.",
		"category": "Array / String"
	},
	{
		"id": 17,
		"topic": "Roman to Integer",
		"code": "// Convert Roman numeral to integer\nvar romanToInt = function (s) {\n // Define a mapping of Roman numerals to their integer values.\n const romanMap = {\n I: 1,\n V: 5,\n X: 10,\n L: 50,\n C: 100,\n D: 500,\n M: 1000,\n };\n let total = 0; // Initialize total to 0.\n // Iterate through the string, checking each numeral.\n for (let i = 0; i < s.length; i++) {\n const current = romanMap[s[i]]; // Get the value of the current Roman numeral.\n const next = romanMap[s[i + 1]]; // Get the value of the next Roman numeral (if it exists).\n // If the current numeral is smaller than the next, subtract it. Otherwise, add it.\n if (next && current < next) {\n total -= current; // Subtract current from total.\n } else {\n total += current; // Add current to total.\n }\n }\n return total; // Return the computed total.\n};\n\nconsole.log(romanToInt(\"III\")); \n// Output: 3\n// Explanation: I = 1, I = 1, I = 1. Total = 3.\n\nconsole.log(romanToInt(\"LVIII\")); \n// Output: 58\n// Explanation: L = 50, V = 5, I = 1, I = 1, I = 1. Total = 58.\n\nconsole.log(romanToInt(\"MCMXCIV\")); \n// Output: 1994\n// Explanation: \n// M = 1000, C = 100 (subtracted, because 100 < M),\n// M = 1000 (add), X = 10 (subtracted, because 10 < C),\n// C = 100 (add), I = 1 (subtracted, because 1 < V), V = 5 (add). \n// Total = 1994.\n\nconsole.log(romanToInt(\"IX\")); \n// Output: 9\n// Explanation: I = 1, X = 10 (subtracted, because 1 < 10). Total = 9.\n\nconsole.log(romanToInt(\"XL\")); \n// Output: 40\n// Explanation: X = 10, L = 50 (subtracted, because 10 < 50). Total = 40.\n\nconsole.log(romanToInt(\"CDXLIV\")); \n// Output: 444\n// Explanation:\n// C = 100, D = 500 (subtracted, because 100 < 500),\n// X = 10, L = 50 (subtracted, because 10 < 50),\n// I = 1, V = 5 (subtracted, because 1 < 5). Total = 444.\n",
		"explanation": "The function `romanToInt` converts a Roman numeral string into its integer representation by following these steps:<br/><br/>1. Mapping Roman Numerals to Values:<br/> - A dictionary `romanMap` is used to map each Roman numeral to its corresponding integer value.<br/><br/>2. Iterating Through the Input String:<br/> - The function loops through each character in the Roman numeral string.<br/> - For each character, it retrieves the value of the current numeral (`current`) and the value of the next numeral (`next`).<br/><br/>3. Handling Subtractive Notation:<br/> - If the current numeral is smaller than the next numeral (e.g., `I` before `V` in \"IV\"), it represents a subtractive case.<br/> - In such cases, subtract the `current` value from the total.<br/><br/>4. Adding Standard Values:<br/> - If the current numeral is not part of a subtractive pair, add its value to the total.<br/><br/>5. Returning the Result:<br/> - After completing the loop, the accumulated total is returned, representing the integer value of the Roman numeral.<br/><br/>Example Walkthrough:<br/><br/>Example 1:<br/>Input: `\"III\"`<br/><br/>- `current = 1`, `next = 1`. Add `1`.<br/>- `current = 1`, `next = 1`. Add `1`.<br/>- `current = 1`, no `next`. Add `1`.<br/><br/>Output: `3`.<br/><br/>Example 2:<br/>Input: `\"LVIII\"`<br/><br/>- `L = 50`, `V = 5`. Add `50`.<br/>- `V = 5`, `I = 1`. Add `5`.<br/>- `I = 1`, `I = 1`. Add `1`.<br/>- `I = 1`, no `next`. Add `1`.<br/><br/>Output: `58`.<br/><br/>Example 3:<br/>Input: `\"MCMXCIV\"`<br/><br/>- `M = 1000`, `C = 100`. Add `1000`.<br/>- `C = 100`, `M = 1000`. Subtract `100`.<br/>- `M = 1000`, `X = 10`. Add `900`.<br/>- `X = 10`, `C = 100`. Subtract `10`.<br/>- `C = 100`, `I = 1`. Add `90`.<br/>- `I = 1`, `V = 5`. Subtract `1`.<br/>- `V = 5`, no `next`. Add `4`.<br/><br/>Output: `1994`.<br/><br/>Complexity:<br/><br/>- Time Complexity: O(n), where n is the length of the input string, as we iterate through it once.<br/>- Space Complexity: O(1), since the memory usage is constant regardless of input size (only the `romanMap` and a few variables are used).",
		"category": "Array / String"
	},
	{
		"id": 18,
		"topic": "Integer to Roman",
		"code": "// Convert integer to Roman numeral\nvar intToRoman = function(num) {\n    // Define the Roman numeral values and symbols\n    const romanValues = [\n        [1000, \"M\"],\n        [900, \"CM\"],\n        [500, \"D\"],\n        [400, \"CD\"],\n        [100, \"C\"],\n        [90, \"XC\"],\n        [50, \"L\"],\n        [40, \"XL\"],\n        [10, \"X\"],\n        [9, \"IX\"],\n        [5, \"V\"],\n        [4, \"IV\"],\n        [1, \"I\"]\n    ];\n    \n    let result = \"\";\n\n    // Loop through each value in the romanValues array\n    for (const [value, symbol] of romanValues) {\n        // Check how many times the symbol can be used\n        while (num >= value) {\n            result += symbol;  // Append the Roman numeral symbol\n            num -= value;      // Subtract the value from the number\n        }\n    }\n    \n    return result;\n};\n\n// Example usage\nconsole.log(intToRoman(3749)); // Output: \"MMMDCCXLIX\"\nconsole.log(intToRoman(58));   // Output: \"LVIII\"\nconsole.log(intToRoman(1994)); // Output: \"MCMXCIV\"\nconsole.log(intToRoman(9));    // Output: \"IX\"\nconsole.log(intToRoman(40));   // Output: \"XL\"\n",
		"explanation": "This function converts an integer to its Roman numeral equivalent.<br/><br/>1. Roman Numeral Values: <br/>   The `romanValues` array contains pairs of integer values and their corresponding Roman numeral symbols. The array is ordered from the largest value (1000, \"M\") to the smallest (1, \"I\") to ensure that the conversion starts with the largest possible Roman numeral.<br/><br/>2. Main Loop:<br/>   The function iterates through each pair of integer and Roman numeral symbol. For each pair:<br/>   - It checks how many times the Roman numeral symbol can be used by comparing the integer `num` with the current value in the `romanValues` array.<br/>   - If `num` is greater than or equal to the value, it appends the corresponding symbol to the result string and subtracts the value from `num`.<br/><br/>3. Result Construction:<br/>   This continues until `num` is reduced to 0. The result string will contain the Roman numeral representation of the integer.<br/><br/>4. Final Output:<br/>   Once the loop completes, the function returns the constructed Roman numeral as a string.<br/><br/>For example:<br/>- If the input is `num = 3749`, the function produces `\"MMMDCCXLIX\"`.<br/>- For `num = 58`, it returns `\"LVIII\"`.<br/><br/>The time complexity is O(1) because the number of Roman numeral symbols is fixed and the function loops through them at most once.",
		"category": "Array / String"
	},
	{
		"id": 19,
		"topic": "Length of Last Word",
		"code": "// Find length of last word\nvar lengthOfLastWord = function(s) {\n    // Trim any trailing spaces from the string to handle cases with extra spaces at the end.\n    s = s.trim(); // \"   Hello world!   \" ==> \"Hello world!\"\n\n    // Find the last space in the trimmed string.\n    let lastSpaceIndex = s.lastIndexOf(' ');\n\n    // The length of the last word is the difference between the string length and the index of the last space.\n    return s.length - lastSpaceIndex - 1;\n};\n\n// Examples\nconsole.log(lengthOfLastWord(\" Hello World \"));\n// Output: 5\n// Explanation: Last word is \"World\", length = 5.\n\nconsole.log(lengthOfLastWord(\"   fly me   to   the moon  \"));\n// Output: 4\n// Explanation: Last word is \"moon\", length = 4.\n\nconsole.log(lengthOfLastWord(\"luffy is still joyboy\"));\n// Output: 6\n// Explanation: Last word is \"joyboy\", length = 6.\n\nconsole.log(lengthOfLastWord(\"a\"));\n// Output: 1\n// Explanation: Single word \"a\", length = 1.\n\nconsole.log(lengthOfLastWord(\"a \"));\n// Output: 1\n// Explanation: Last word is \"a\", trailing space is ignored.\n",
		"explanation": "1. Trim the String:<br/>   - Use `s.trim()` to remove leading and trailing spaces, ensuring we only consider meaningful content.<br/><br/>2. Find the Last Space:<br/>   - Use `s.lastIndexOf(' ')` to locate the position of the last space in the string. If no space is found, it returns `-1`.<br/><br/>3. Calculate the Last Word's Length:<br/>   - Subtract the index of the last space (`lastSpaceIndex`) from the total string length (`s.length`) and subtract one more to exclude the space itself.<br/><br/>4. Return the Result:<br/>   - The result represents the length of the last word.<br/><br/>Complexity:<br/><br/>- Time Complexity: O(n), where n is the length of the string. The `trim` and `lastIndexOf` operations both iterate through the string.<br/>- Space Complexity: O(1), as no additional data structures are used.",
		"category": "Array / String"
	},
	{
		"id": 20,
		"topic": "Longest Common Prefix",
		"code": "// Find longest common prefix\nvar longestCommonPrefix = function (strs) {\n if (strs.length === 0) return '';\n let prefix = strs[0];\n for (let i = 1; i < strs.length; i++) {\n while (strs[i].indexOf(prefix) !== 0) {\n prefix = prefix.slice(0, -1);\n if (prefix === '') return '';\n }\n }\n return prefix;\n};\n\n// Examples:\nconsole.log(longestCommonPrefix(['flower', 'flow', 'flight']));\n// Output: \"fl\"\n\nconsole.log(longestCommonPrefix(['dog', 'racecar', 'car']));\n// Output: \"\"\n\nconsole.log(longestCommonPrefix(['interstellar', 'internet', 'interval']));\n// Output: \"inte\"\n\nconsole.log(longestCommonPrefix(['a']));\n// Output: \"a\"\n\nconsole.log(longestCommonPrefix(['']));\n// Output: \"\"\n\nconsole.log(longestCommonPrefix(['prefix', 'prefixing', 'prefecture']));\n// Output: \"prefix\"\n",
		"explanation": "1. Start with the First String:<br/>   - Assume the first string in the array is the longest common prefix.<br/><br/>2. Compare the Prefix with Each String:<br/>   - Use `indexOf(prefix) === 0` to check if the current string starts with the prefix.<br/><br/>3. Adjust the Prefix:<br/>   - If a string does not start with the prefix, remove the last character from the prefix (`prefix.slice(0, -1)`) until a match is found.<br/><br/>4. Stop Early:<br/>   - If the prefix becomes empty during any comparison, return `\"\"`, as there is no common prefix.<br/><br/>Example Walkthrough:<br/><br/>Example 1:<br/>Input: `[\"flower\", \"flow\", \"flight\"]`<br/>- Start with `prefix = \"flower\"`.<br/>  - Compare with `\"flow\"`. `\"flow\".indexOf(\"flower\") !== 0`, so reduce:<br/>    - Remove \"r\" → `prefix = \"flowe\"`.<br/>    - Remove \"e\" → `prefix = \"flow\"`.<br/>  - `\"flow\".indexOf(\"flow\") === 0`, so keep `\"flow\"`.<br/>- Compare with `\"flight\"`. `\"flight\".indexOf(\"flow\") !== 0`, so reduce:<br/>    - Remove \"w\" → `prefix = \"flo\"`.<br/>    - Remove \"o\" → `prefix = \"fl\"`.<br/>  - `\"flight\".indexOf(\"fl\") === 0`, so keep `\"fl\"`.<br/>Output: `\"fl\"`.<br/><br/>Example 2:<br/>Input: `[\"dog\", \"racecar\", \"car\"]`<br/>- Start with `prefix = \"dog\"`.<br/>  - Compare with `\"racecar\"`. `\"racecar\".indexOf(\"dog\") !== 0`, so reduce:<br/>    - Remove \"g\" → `prefix = \"do\"`.<br/>    - Remove \"o\" → `prefix = \"d\"`.<br/>    - Remove \"d\" → `prefix = \"\"`.<br/>Output: `\"\"`.<br/><br/>Example 3:<br/>Input: `[\"interstellar\", \"internet\", \"interval\"]`<br/>- Start with `prefix = \"interstellar\"`.<br/>  - Compare with `\"internet\"`. Reduce:<br/>    - Remove \"r\" → `prefix = \"interstella\"`.<br/>    - Remove \"a\" → `prefix = \"interstell\"`.<br/>    - Continue reducing until `prefix = \"inter\"`.<br/>  - Compare with `\"interval\"`. `\"interval\".indexOf(\"inter\") === 0`, so keep `\"inter\"`.<br/>Output: `\"inter\"`.<br/><br/>Complexity:<br/><br/>- Time Complexity: O(n \\cdot m), where n is the number of strings and m is the length of the shortest string. Each string may require up to m reductions.<br/>- Space Complexity: O(1), as no additional data structures are used.",
		"category": "Array / String"
	},
	{
		"id": 21,
		"topic": "Reverse Words in a String",
		"code": "var reverseWords = function(s) {\n    // Step 1: Trim the string to remove leading and trailing spaces\n    // This ensures we don't have extra spaces that could affect our word separation.\n    // Example: \"  hello world  \" becomes \"hello world\"\n    const trimmedString = s.trim();\n\n    // Step 2: Split the string into words based on spaces\n    // We use the split() method with a regular expression that matches one or more whitespace characters.\n    // The regex /\\s+/ will handle multiple spaces and convert them into an array of words,\n    // effectively filtering out empty strings that might result from consecutive spaces.\n    // Example: \"a good   example\" becomes [\"a\", \"good\", \"example\"]\n    const words = trimmedString.split(/\\s+/);\n\n    // Step 3: Reverse the array of words\n    // By calling reverse(), we change the order of elements in the array,\n    // so the last word becomes the first and vice versa.\n    // Example: [\"a\", \"good\", \"example\"] becomes [\"example\", \"good\", \"a\"]\n    const reversedWords = words.reverse();\n\n    // Step 4: Join the reversed array back into a string with a single space\n    // Using join(\" \"), we concatenate the elements of the array into a single string,\n    // ensuring that words are separated by exactly one space.\n    // Example: [\"example\", \"good\", \"a\"] becomes \"example good a\"\n    return reversedWords.join(\" \");\n};\n\n// Example usage:\nconst input1 = \"the sky is blue\";\nconst output1 = reverseWords(input1);\nconsole.log(output1); // Output: \"blue is sky the\"\n",
		"explanation": "Function Definition: The function `reverseWords` takes a single parameter `s`, which is the input string containing words separated by spaces.<br/>- Trimming the String: <br/>  - We use the `trim()` method to remove any extra spaces from the start and end of the string. <br/>  - This is crucial because leading or trailing spaces do not contribute to the meaningful content of the string and would result in incorrect word splitting.<br/>- Splitting into Words:<br/>  - The `split(/\\s+/)` method takes advantage of a regular expression that matches one or more whitespace characters.<br/>  - This means that any sequence of spaces (including tabs or multiple spaces) between words is treated as a single delimiter.<br/>  - The result is an array of words, with no empty strings, even if there were multiple spaces between them.<br/>- Reversing the Words:<br/>  - The `reverse()` method modifies the original array in place, reversing the order of its elements.<br/>  - This effectively turns the last word into the first one, aligning with the requirement of returning the words in reverse order.<br/>- Joining the Words:<br/>  - Finally, we use `join(\" \")` to combine the elements of the reversed array into a single string, inserting a single space between each word.<br/>  - This ensures that the output format is correct, with only one space separating the words and no extra spaces at the beginning or end.<br/>### Example Cases:<br/>- For the input `\"the sky is blue\"`, the function first trims the string (no change here), splits it into `[\"the\", \"sky\", \"is\", \"blue\"]`, reverses it to `[\"blue\", \"is\", \"sky\", \"the\"]`, and joins it to form `\"blue is sky the\"`.<br/>  <br/>- For the input `\"  hello world  \"`, trimming results in `\"hello world\"`, which splits into `[\"hello\", \"world\"]`, reverses to `[\"world\", \"hello\"]`, and finally joins to produce `\"world hello\"`.<br/>- For the input `\"a good   example\"`, trimming yields `\"a good   example\"`, which splits into `[\"a\", \"good\", \"example\"]`, reverses to `[\"example\", \"good\", \"a\"]`, and joins to give `\"example good a\"`.<br/>This approach is efficient, leveraging built-in JavaScript methods to manipulate strings and arrays while maintaining clarity and conciseness in the code.",
		"category": "Array / String"
	},
	{
		"id": 22,
		"topic": "Zigzag Conversion",
		"code": "// Convert string to zigzag pattern\nvar convert = function (s, numRows) {\n if (numRows === 1 || s.length <= numRows) return s; // Handle edge cases.\n const rows = Array.from({ length: numRows }, () => '');\n let currentRow = 0;\n let goingDown = false;\n for (let char of s) {\n rows[currentRow] += char;\n if (currentRow === 0 || currentRow === numRows - 1) {\n goingDown = !goingDown;\n }\n currentRow += goingDown ? 1 : -1;\n }\n return rows.join('');\n};\n\n// Examples:\nconsole.log(convert('PAYPALISHIRING', 3));\n// Output: \"PAHNAPLSIIGYIR\"\n\nconsole.log(convert('PAYPALISHIRING', 4));\n// Output: \"PINALSIGYAHRPI\"\n\nconsole.log(convert('A', 1));\n// Output: \"A\"\n\nconsole.log(convert('HELLO', 2));\n// Output: \"HLOEL\"\n\nconsole.log(convert('ABCDEF', 5));\n// Output: \"ABDFC\"\n",
		"explanation": "1. Handle Edge Cases:<br/>   - If `numRows` is 1 or the string length is less than or equal to `numRows`, return the string directly.<br/><br/>2. Create Row Storage:<br/>   - Use an array of strings, where each string corresponds to a row in the zigzag pattern.<br/><br/>3. Traverse the String:<br/>   - Iterate through each character in the input string.<br/>   - Append the character to the appropriate row based on the current row index.<br/><br/>4. Adjust Row Direction:<br/>   - Use a flag `goingDown` to track whether the row index should increase or decrease.<br/>   - Flip the direction at the topmost (`currentRow === 0`) and bottommost (`currentRow === numRows - 1`) rows.<br/><br/>5. Combine the Rows:<br/>   - After constructing the zigzag pattern, concatenate all rows to produce the final result.<br/><br/>Example Walkthrough:<br/><br/>Example 1:<br/>Input: `s = \"PAYPALISHIRING\"`, `numRows = 3`<br/>- Rows: [\"P   A   H   N\", \"A P L S I I G\", \"Y   I   R\"]<br/>- Output: `\"PAHNAPLSIIGYIR\"`<br/><br/>Example 2:<br/>Input: `s = \"PAYPALISHIRING\"`, `numRows = 4`<br/>- Rows: [\"P     I    N\", \"A   L S  I G\", \"Y A   H R\", \"P     I\"]<br/>- Output: `\"PINALSIGYAHRPI\"`<br/><br/>Example 3:<br/>Input: `s = \"A\"`, `numRows = 1`<br/>- Rows: [\"A\"]<br/>- Output: `\"A\"`<br/><br/>Complexity:<br/>- Time Complexity: O(n), where n is the length of the string. Each character is visited once.<br/>- Space Complexity: O(n), for storing the rows.",
		"category": "Array / String"
	},
	{
		"id": 23,
		"topic": "Find the Index of the First Occurrence in a String",
		"code": "// Find the index of the first occurrence in a string\nvar strStr = function (haystack, needle) {\n const haystackLength = haystack.length;\n const needleLength = needle.length;\n if (needleLength === 0) return 0;\n for (let i = 0; i <= haystackLength - needleLength; i++) {\n if (haystack.substring(i, i + needleLength) === needle) {\n return i;\n }\n }\n return -1;\n};\n\n// Examples:\nconsole.log(strStr(\"sadbutsad\", \"sad\"));\n// Output: 0\n\nconsole.log(strStr(\"leetcode\", \"leeto\"));\n// Output: -1\n\nconsole.log(strStr(\"hello\", \"ll\"));\n// Output: 2\n\nconsole.log(strStr(\"aaaaa\", \"bba\"));\n// Output: -1\n\nconsole.log(strStr(\"a\", \"a\"));\n// Output: 0\n",
		"explanation": "1. Length Variables:<br/>   - Define `haystackLength` and `needleLength` to avoid redundant `length` property calls.<br/><br/>2. Edge Case:<br/>   - If `needle` is empty, return `0` as per the problem description.<br/><br/>3. Iterate Through `haystack`:<br/>   - Start from index `0` and go up to `haystackLength - needleLength` because a valid `needle` cannot exist beyond this range.<br/><br/>4. Substring Comparison:<br/>   - Use the `substring` method to extract a substring from `haystack` with the same length as `needle` and compare it to `needle`.<br/><br/>5. Return the Index:<br/>   - If a match is found, return the starting index `i`.<br/><br/>6. Return `-1`:<br/>   - If the loop completes without finding a match, return `-1`.<br/><br/>Complexity:<br/>- Time Complexity: O(n \\cdot m), where n is `haystackLength` and m is `needleLength`. For each position in `haystack`, a substring of length m is compared to `needle`.<br/>- Space Complexity: O(1), as no additional space is used beyond the variables.",
		"category": "Array / String"
	},
	{
		"id": 24,
		"topic": "Text Justification",
		"code": "// Justify text\nvar fullJustify = function (words, maxWidth) {\n const result = [];\n let line = [];\n let lineLength = 0;\n for (let word of words) {\n if (lineLength + line.length + word.length > maxWidth) {\n for (let i = 0; i < maxWidth - lineLength; i++) {\n line[i % (line.length - 1 || 1)] += ' ';\n }\n result.push(line.join(''));\n line = [];\n lineLength = 0;\n }\n line.push(word);\n lineLength += word.length;\n }\n result.push(line.join(' ') + ' '.repeat(maxWidth - lineLength - (line.length - 1)));\n return result;\n};\n\n// Examples:\nconsole.log(fullJustify(['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 16));\n// Output:\n// [\n//   \"This    is    an\",\n//   \"example  of text\",\n//   \"justification.  \"\n// ]\n\nconsole.log(fullJustify(['What', 'must', 'be', 'acknowledgment', 'shall', 'be'], 16));\n// Output:\n// [\n//   \"What   must   be\",\n//   \"acknowledgment  \",\n//   \"shall be        \"\n// ]\n\nconsole.log(fullJustify(['Science', 'is', 'what', 'we', 'understand', 'well', 'enough', 'to', 'explain', 'to', 'a', 'computer.', 'Art', 'is', 'everything', 'else', 'we', 'do'], 20));\n// Output:\n// [\n//   \"Science  is  what we\",\n//   \"understand      well\",\n//   \"enough to explain to\",\n//   \"a  computer.  Art is\",\n//   \"everything  else  we\",\n//   \"do                  \"\n// ]\n",
		"explanation": "1. Line Construction:<br/>   - Words are added to a line until adding another word would exceed `maxWidth`.<br/>   - `lineLength` tracks the total number of characters in the current line, excluding spaces.<br/><br/>2. Space Distribution:<br/>   - For fully justified lines:<br/>     - Calculate the total extra spaces needed: `maxWidth - lineLength`.<br/>     - Distribute these spaces evenly between words:<br/>       - Use the `%` operator to cycle through gaps when distributing unevenly.<br/>     - For lines with only one word, all extra spaces are added to the end.<br/><br/>3. Last Line:<br/>   - The last line is left-justified:<br/>     - Words are joined with a single space.<br/>     - Remaining spaces are added to the end to match `maxWidth`.<br/><br/>4. Output:<br/>   - Once all words are processed, the `result` contains all justified lines.<br/><br/>Complexity:<br/><br/>- Time Complexity: O(n), where n is the total number of characters in `words`. Each word is processed once.<br/>- Space Complexity: O(1) additional space, excluding the output array.",
		"category": "Array / String"
	},
	{
		"id": 25,
		"topic": "Valid Palindrome",
		"code": "var isPalindrome = function(s) {\n    // Remove non-alphanumeric characters and convert to lowercase\n    let cleaned = s.replace(/[^a-z0-9]/gi, '').toLowerCase();\n    \n    // Check if the cleaned string is the same as its reverse\n    return cleaned === cleaned.split('').reverse().join('');\n};\n",
		"explanation": "Explanation:<br/><br/>1. Cleaning the String:<br/>   - The function removes all non-alphanumeric characters using the regular expression /[^a-z0-9]/gi and converts the string to lowercase.<br/>   - /[^a-z0-9]/: Matches any character that is not a letter (a-z) or digit (0-9).<br/>   - g: Global flag ensures all matches are replaced.<br/>   - i: Case-insensitive flag ensures both uppercase and lowercase characters are matched.<br/><br/>2. Palindrome Check:<br/>   - The cleaned string is compared with its reversed version.<br/>   - cleaned.split(''): Splits the string into an array of characters.<br/>   - .reverse(): Reverses the order of characters in the array.<br/>   - .join(''): Joins the reversed characters back into a string.<br/>   - The function returns true if the cleaned string matches its reverse; otherwise, it returns false.",
		"category": "Two Pointers"
	},
	{
		"id": 26,
		"topic": "Is Subsequence",
		"code": "// Check if s is a subsequence of t\nvar isSubsequence = function(s, t) {\n let i = 0, j = 0;\n \n // Traverse string t to find characters of string s in order\n while (i < s.length && j < t.length) {\n console.log(`Comparing s[${i}] = '${s[i]}' with t[${j}] = '${t[j]}'`);\n \n if (s[i] === t[j]) {\n console.log(`Match found! Incrementing i to ${i + 1}`);\n i++; // Move pointer for s when there's a match\n }\n \n // Always move pointer for t\n j++;\n console.log(`Incrementing j to ${j}`);\n }\n \n // If all characters in s are found in order in t, return true\n console.log(`Final value of i: ${i}, length of s: ${s.length}`);\n return i === s.length;\n};\n\n// Optimized solution\n// Preprocess t and store the positions of each character\nvar preprocess = function(t) {\nconst positions = new Map();\nfor (let i = 0; i < t.length; i++) {\nif (!positions.has(t[i])) {\npositions.set(t[i], []);\n}\npositions.get(t[i]).push(i);\n}\nreturn positions;\n};\n\n// Check if s is a subsequence of t using binary search\nvar isSubsequence = function(s, t) {\nconst positions = preprocess(t);\nlet prevIndex = -1;\n\nTraverse each character in s\nfor (let char of s) {\nif (!positions.has(char)) {\nreturn false; // If t doesn't contain this character, return false\n// }\n\nconst indices = positions.get(char);\n\n// Use binary search to find the smallest index in indices that is greater than prevIndex\nlet left = 0, right = indices.length - 1;\nlet found = false;\n\nwhile (left <= right) {\nconst mid = Math.floor((left + right) / 2);\nif (indices[mid] > prevIndex) {\nfound = true;\nprevIndex = indices[mid];\nright = mid - 1;\n} else {\nleft = mid + 1;\n}\n}\n\n// If no valid index is found, return false\nif (!found) {\nreturn false;\n}\n}\n\nreturn true;\n};\n",
		"explanation": "Explanation:<br/><br/>- We start by initializing two pointers: `i` for string `s` and `j` for string `t`.<br/>- We loop through string `t` using the pointer `j`. For each character in `t`, we check if it matches the current character in `s` (pointed to by `i`).<br/>- If a match is found (`s[i] === t[j]`), we increment `i` to check the next character in `s`.<br/>- Regardless of a match, we always increment `j` to continue traversing `t`.<br/>- If we manage to find all characters of `s` in order within `t`, `i` will reach the end of `s`, and we return `true`.<br/>- If not, we return `false`.<br/><br/>Time Complexity:<br/>- The time complexity is O(n), where `n` is the length of string `t`, since we only traverse string `t` once.<br/><br/>Space Complexity:<br/>- The space complexity is O(1), since we only use a few variables (`i` and `j`) for the pointers.<br/><br/><br/>Optimized Explanation:<br/><br/>1. We preprocess `t` into a map where the key is the character and the value is a list of indices where that character appears in `t`.<br/>2. For each string `s`, we use binary search to find the next available position in `t` where each character in `s` appears after the previously found character.<br/>3. If we can't find a character in the required order, return `false`.<br/>4. If we find all characters of `s` in order, return `true`.<br/><br/>Time Complexity:<br/>- Preprocessing `t`: O(n), where `n` is the length of `t`.<br/>- For each string `s`, checking if it’s a subsequence takes O(m * log n), where `m` is the length of `s` and `n` is the length of `t`. This is because we use binary search on the list of indices for each character of `s`.<br/><br/>Space Complexity:<br/>- O(n), where `n` is the length of `t`, for storing the positions of characters.",
		"category": "Two Pointers"
	},
	{
		"id": 27,
		"topic": "Two Sum II - Input Array Is Sorted",
		"code": "// Find two numbers that add up to a specific target\nvar twoSum = function(numbers, target) {\n // Initialize two pointers: one at the start, one at the end of the array\n let left = 0;\n let right = numbers.length - 1;\n\n // Loop until the pointers meet\n while (left < right) {\n // Calculate the sum of the numbers at the two pointers\n const sum = numbers[left] + numbers[right];\n\n // Check if the sum matches the target\n if (sum === target) {\n // Return the indices (1-indexed)\n return [left + 1, right + 1];\n } else if (sum < target) {\n // If the sum is less than the target, move the left pointer to the right\n left++;\n } else {\n // If the sum is greater than the target, move the right pointer to the left\n right--;\n }\n }\n};\n\n// Examples\nconsole.log(twoSum([2,7,11,15], 9)); // Output: [1, 2]\nconsole.log(twoSum([2,3,4], 6));     // Output: [1, 3]\nconsole.log(twoSum([-1,0], -1));     // Output: [1, 2]\n",
		"explanation": "1. Two Pointers Approach:<br/> - Since the array is already sorted in non-decreasing order, we can use a two-pointer approach to find the pair efficiently.<br/> - The `left` pointer starts at the beginning of the array, and the `right` pointer starts at the end of the array.<br/><br/>2. Logic:<br/> - Calculate the sum of the numbers at the two pointers (`numbers[left]` and `numbers[right]`).<br/> - If the sum equals the target, return the indices (adding 1 to convert from 0-based to 1-based indexing).<br/> - If the sum is less than the target, move the `left` pointer to the right to increase the sum.<br/> - If the sum is greater than the target, move the `right` pointer to the left to decrease the sum.<br/><br/>3. Optimal Solution:<br/> - This approach runs in O(n) time complexity, where `n` is the length of the array, as each element is visited at most once.<br/> - The space complexity is O(1), as no additional data structures are used.<br/><br/>4. Examples:<br/> - Input: `numbers = [2,7,11,15], target = 9`<br/>   - Start: `left = 0` (`2`), `right = 3` (`15`), sum = 17 (too large, move `right`).<br/>   - Next: `left = 0` (`2`), `right = 1` (`7`), sum = 9 (match, return `[1, 2]`).<br/> - Input: `numbers = [2,3,4], target = 6`<br/>   - Start: `left = 0` (`2`), `right = 2` (`4`), sum = 6 (match, return `[1, 3]`).<br/> - Input: `numbers = [-1,0], target = -1`<br/>   - Start: `left = 0` (`-1`), `right = 1` (`0`), sum = -1 (match, return `[1, 2]`).",
		"category": "Two Pointers"
	},
	{
		"id": 28,
		"topic": "Container With Most Water",
		"code": "// Find the container with the most water\nvar maxArea = function (height) {\n let left = 0; // Initialize the left pointer\n let right = height.length - 1; // Initialize the right pointer\n let maxArea = 0; // Variable to store the maximum area found\n while (left < right) {\n const currentHeight = Math.min(height[left], height[right]);\n const currentWidth = right - left;\n const currentArea = currentHeight * currentWidth;\n maxArea = Math.max(maxArea, currentArea);\n if (height[left] < height[right]) {\n left++;\n } else {\n right--;\n }\n }\n return maxArea;\n};\n\n// Examples:\nconsole.log(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]));\n// Output: 49\n\nconsole.log(maxArea([1, 1]));\n// Output: 1\n\nconsole.log(maxArea([4, 3, 2, 1, 4]));\n// Output: 16\n\nconsole.log(maxArea([1, 2, 1]));\n// Output: 2\n",
		"explanation": "1. Two-pointer Approach:<br/>   - Start with two pointers, one at the beginning (`left`) and one at the end (`right`) of the array.<br/>   - Calculate the area between the two lines as:<br/>     \\[<br/>     \\text{Area} = \\min(\\text{height}[left], \\text{height}[right]) \\times (\\text{right} - \\text{left})<br/>     \\]<br/><br/>2. Move the Pointer:<br/>   - To maximize the area, the shorter line is the limiting factor.<br/>   - Move the pointer pointing to the shorter line inward, as it might lead to a taller line and potentially a larger area.<br/><br/>3. Update maxArea:<br/>   - Keep track of the largest area found so far.<br/><br/>4. Stop Condition:<br/>   - The loop stops when the two pointers meet.<br/><br/>Complexity:<br/>- Time Complexity: \\(O(n)\\), where \\(n\\) is the length of the `height` array. Each element is processed at most once.<br/>- Space Complexity: \\(O(1)\\), as only a few variables are used.<br/><br/>Example Walkthrough:<br/><br/>Example 1:<br/>Input: `height = [1, 8, 6, 2, 5, 4, 8, 3, 7]`<br/>- Initial: `left = 0`, `right = 8`<br/>- Iterations:<br/>  - Calculate area between heights `1` and `7`: \\( \\min(1, 7) \\times 8 = 8 \\).<br/>  - Move `left` to `1`, as `height[left] < height[right]`.<br/>  - Calculate area between `8` and `7`: \\( \\min(8, 7) \\times 7 = 49 \\).<br/>  - Update `maxArea` to `49`.<br/>  - Continue shrinking the window.<br/>- Output: `49`<br/><br/>Example 2:<br/>Input: `height = [1, 1]`<br/>- Initial: `left = 0`, `right = 1`<br/>- Calculate area: \\( \\min(1, 1) \\times 1 = 1 \\).<br/>- Output: `1`",
		"category": "Two Pointers"
	},
	{
		"id": 29,
		"topic": "3Sum",
		"code": "var threeSum = function(nums) {\n    console.log(\"Input array:\", nums);\n    \n    // Sort the array to simplify finding duplicates and using the two-pointer approach\n    nums.sort((a, b) => a - b);\n    console.log(\"Sorted array:\", nums);\n\n    const result = [];\n    const n = nums.length;\n\n    // Iterate through the array, fixing the first number of the triplet\n    for (let i = 0; i < n - 2; i++) {\n        // Explanation: We use `i < n - 2` because we need at least two numbers after `nums[i]`\n        // to form a triplet. If `i` were to reach `n - 2`, there wouldn't be enough numbers \n        // remaining in the array to form a valid triplet.\n        \n        // Skip duplicates for the first number\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            // console.log(`Skipping duplicate for nums[${i}] = ${nums[i]}`);\n            continue;\n        }\n\n        // Create two pointers: one at the element right after the current one (left)\n        // and one at the last element (right). These pointers will be used to find pairs\n        // that, together with nums[i], sum up to zero.\n        let left = i + 1;\n        let right = n - 1;\n\n        // console.log(`Processing nums[${i}] = ${nums[i]}`);\n\n        while (left < right) {\n            // Combination of current triplet\n            const sum = nums[i] + nums[left] + nums[right];\n            // console.log(`Checking combination: ${nums[i]}, ${nums[left]}, ${nums[right]} (sum = ${sum})`);\n\n            if (sum === 0) {\n                // console.log(`Found triplet: [${nums[i]}, ${nums[left]}, ${nums[right]}]`);\n                \n                // Found a valid triplet: add it to the result array\n                result.push([nums[i], nums[left], nums[right]]);\n                // Move the left pointer to the right, skipping any duplicates\n                left++;\n                // Move the right pointer to the left, skipping any duplicates\n                right--;\n\n                // Skip duplicates for the second number\n                while (left < right && nums[left] === nums[left - 1]) {\n                    // console.log(`Skipping duplicate for nums[${left}] = ${nums[left]}`);\n                    left++;\n                }\n                \n                // Skip duplicates for the third number\n                while (left < right && nums[right] === nums[right + 1]) {\n                    // console.log(`Skipping duplicate for nums[${right}] = ${nums[right]}`);\n                    right--;\n                }\n            } else if (sum < 0) {\n                // console.log(`Sum < 0, incrementing left pointer from ${left} to ${left + 1}`);\n                \n                // If the sum is less than 0, we need a larger number to increase the sum\n                // So, move the left pointer to the right (left++)\n                left++;\n            } else {\n                // console.log(`Sum > 0, decrementing right pointer from ${right} to ${right - 1}`);\n                \n                // If the sum is greater than 0, we need a smaller number to decrease the sum\n                // So, move the right pointer to the left (right--)\n                right--;\n            }\n        }\n    }\n\n    console.log(\"Final result:\", result);\n    return result;\n};\n",
		"explanation": "Explanation:<br/><br/>1. Input array: [-1, 0, 1, 2, -1, -4]<br/>   After sorting: [-4, -1, -1, 0, 1, 2]<br/><br/>2. Iterate through the array and fix the first number of the triplet.<br/><br/>3. Use two pointers (left and right) to find pairs of numbers that, when added to the first number, result in zero:<br/>   - Left pointer:<br/>     - Starts just after the current index `i` (`left = i + 1`).<br/>     - Moves forward (`left++`) if the sum of the triplet is less than zero, since the sorted order means larger numbers are needed to increase the sum.<br/>   - Right pointer:<br/>     - Starts at the last index (`right = n - 1`).<br/>     - Moves backward (`right--`) if the sum of the triplet is greater than zero, since the sorted order means smaller numbers are needed to decrease the sum.<br/>   - Together:<br/>     - `left` and `right` explore all possible pairs for the current `nums[i]`.<br/>     - If the sum of the triplet matches zero, the combination is valid, and both pointers adjust to skip duplicates.<br/>     - The process continues until `left` and `right` pointers overlap, completing all pair possibilities for the current `nums[i]`.<br/><br/>4. If a triplet is found, store it in the result array and adjust the pointers while skipping duplicates.<br/><br/>5. If the sum is less than zero, increment the left pointer to increase the sum.<br/><br/>6. If the sum is greater than zero, decrement the right pointer to decrease the sum.<br/><br/>7. Repeat this process for all elements in the array.<br/><br/>8. Return the final list of unique triplets: [[-1, -1, 2], [-1, 0, 1]].",
		"category": "Two Pointers"
	},
	{
		"id": 30,
		"topic": "Minimum Size Subarray Sum",
		"code": "var minSubArrayLen = function(target, nums) {\n    // Start of the sliding window\n    let left = 0;\n    // Current sum of the numbers within the window\n    let sum = 0; \n    // To store the minimum length of a valid subarray\n    let minLength = Infinity; \n\n    // Iterate through the array with the right pointer\n    for (let right = 0; right < nums.length; right++) {\n        // Add the current element to the sum\n        sum += nums[right]; \n\n        // While the current sum is greater than or equal to the target\n        while (sum >= target) {\n            // Calculate the length of the current subarray\n            let currentLength = right - left + 1;\n            // Update minLength with the smaller value between currentLength and minLength\n            minLength = Math.min(minLength, currentLength);\n            // Shrink the window from the left\n            sum -= nums[left];\n            // Move the left pointer forward\n            left++; \n        }\n    }\n\n    // If no valid subarray was found, return 0; otherwise, return minLength\n    return minLength === Infinity ? 0 : minLength;\n};\n",
		"explanation": "Explanation:<br/><br/>1. **Definition of a window**:<br/>   - A **window** refers to a contiguous segment of the array defined by two pointers: the `left` pointer (start of the window) and the `right` pointer (end of the window).<br/>   - The elements within the window are those between the `left` and `right` indices, inclusive.<br/><br/>2. **How the window works**:<br/>   - The `right` pointer expands the window by including new elements from the array into the sum.<br/>   - The `left` pointer shrinks the window by excluding elements from the sum when the condition (sum >= target) is met.<br/>   - This dynamic adjustment ensures the algorithm considers all possible valid subarrays efficiently.<br/><br/>3. **Algorithm steps**:<br/>   - Start with an empty window (`left = 0` and `right = 0`) and a `sum = 0`.<br/>   - Expand the window by moving the `right` pointer and adding elements to `sum`.<br/>   - If the `sum` of the window meets or exceeds the `target`, calculate the window's length (`right - left + 1`).<br/>   - Update `minLength` if the current window is shorter than the previously found windows.<br/>   - Shrink the window by moving the `left` pointer forward and subtracting the excluded element from `sum`.<br/>   - Continue until the entire array is processed.<br/><br/>4. **Final result**:<br/>   - If no valid subarray is found (i.e., `minLength` remains `Infinity`), return 0.<br/>   - Otherwise, return the smallest length found.<br/><br/>Time Complexity: O(n) - Each element is visited at most twice (once by `right` and once by `left`).<br/>Space Complexity: O(1) - Only constant space is used.",
		"category": "Sliding Window"
	},
	{
		"id": 31,
		"topic": "Longest Substring Without Repeating Characters",
		"code": "// Find the length of the longest substring without repeating characters\nvar lengthOfLongestSubstring = function (s) {\n let charSet = new Set();\n let left = 0;\n let maxLength = 0;\n for (let right = 0; right < s.length; right++) {\n while (charSet.has(s[right])) {\n charSet.delete(s[left]);\n left++;\n }\n charSet.add(s[right]);\n maxLength = Math.max(maxLength, right - left + 1);\n }\n return maxLength;\n};\n\n// Examples:\nconsole.log(lengthOfLongestSubstring('abcabcbb')); // Output: 3\nconsole.log(lengthOfLongestSubstring('bbbbb')); // Output: 1\nconsole.log(lengthOfLongestSubstring('pwwkew')); // Output: 3\nconsole.log(lengthOfLongestSubstring('')); // Output: 0\nconsole.log(lengthOfLongestSubstring('au')); // Output: 2\n",
		"explanation": "1. What is the problem asking?<br/>   - The task is to find the longest substring in a given string `s` where no characters repeat.<br/><br/>2. How are we solving this?<br/>   - We'll use the sliding window technique:<br/>     - Two pointers (`left` and `right`) represent the boundaries of a window.<br/>     - A set (`charSet`) keeps track of the unique characters in the current window.<br/>     - Expand the window by moving the `right` pointer.<br/>     - If a duplicate is encountered, shrink the window by moving the `left` pointer.<br/><br/>3. Why does this work?<br/>   - By maintaining a set of unique characters in the current window, we ensure that each substring between the `left` and `right` pointers contains no duplicates.<br/>   - The window is adjusted efficiently, ensuring that each character is processed at most twice (once when added and once when removed).<br/><br/>4. Complexity Analysis:<br/>   - Time Complexity: \\(O(n)\\), where \\(n\\) is the length of the string. Each character is added and removed from the set at most once.<br/>   - Space Complexity: \\(O(k)\\), where \\(k\\) is the size of the character set (for ASCII, at most 128).<br/><br/>5. Example Walkthroughs:<br/><br/>   Example 1: `s = \"abcabcbb\"`<br/>   - `left = 0`, `right = 0`, `charSet = {}`<br/>   - Add `\"a\"`, `\"b\"`, `\"c\"` -> Current substring: `\"abc\"`, length = 3.<br/>   - Duplicate `\"a\"` is found. Shrink window: Remove characters until `\"a\"` is removed.<br/>   - Continue expanding the window.<br/>   - Max length = 3.<br/><br/>   Example 2: `s = \"bbbbb\"`<br/>   - Window always contains one `\"b\"`.<br/>   - Max length = 1.<br/><br/>   Example 3: `s = \"pwwkew\"`<br/>   - Expand the window to `\"pw\"`, then `\"wke\"`.<br/>   - Duplicate `\"w\"` is found. Shrink and continue.<br/>   - Max length = 3.<br/><br/>6. Edge Cases:<br/>   - Empty string: `\"\"` -> Output: `0`.<br/>   - Single character: `\"a\"` -> Output: `1`.",
		"category": "Sliding Window"
	},
	{
		"id": 32,
		"topic": "Substring with Concatenation of All Words",
		"code": "// Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once\nvar findSubstring = function (s, words) {\n if (!s || words.length === 0) return [];\n const wordLength = words[0].length;\n const wordCount = words.length;\n const substringLength = wordLength * wordCount;\n const wordMap = new Map();\n for (let word of words) {\n wordMap.set(word, (wordMap.get(word) || 0) + 1);\n }\n const result = [];\n for (let i = 0; i <= s.length - substringLength; i++) {\n const seen = new Map();\n let j = 0;\n while (j < wordCount) {\n const wordStart = i + j * wordLength;\n const word = s.substring(wordStart, wordStart + wordLength);\n if (!wordMap.has(word)) break;\n seen.set(word, (seen.get(word) || 0) + 1);\n if (seen.get(word) > wordMap.get(word)) break;\n j++;\n }\n if (j === wordCount) result.push(i);\n }\n return result;\n};\n\n// Examples:\nconsole.log(findSubstring('barfoothefoobarman', ['foo', 'bar'])); // Output: [0, 9]\nconsole.log(findSubstring('wordgoodgoodgoodbestword', ['word', 'good', 'best', 'word'])); // Output: []\nconsole.log(findSubstring('barfoofoobarthefoobarman', ['bar', 'foo', 'the'])); // Output: [6, 9, 12]\n",
		"explanation": "1. What is the problem asking?<br/>   - Find all starting indices of substrings in `s` that are concatenations of all strings in `words`.<br/><br/>2. How do we solve this?<br/>   - Use a sliding window approach:<br/>     - Calculate the total length of the concatenated substring.<br/>     - For each possible starting index `i`, check if the substring is a valid concatenation.<br/>     - Maintain a frequency map of the words in `words` and compare it with the frequency of words in the current substring.<br/><br/>3. Key steps:<br/>   - Calculate `wordLength` (length of a single word) and `substringLength` (length of all words concatenated).<br/>   - Slide through `s` in increments of `wordLength`.<br/>   - Use a `seen` map to track the frequency of words in the current window and compare with the `wordMap`.<br/><br/>4. Complexity Analysis:<br/>   - Time Complexity: \\(O(n \\cdot k)\\), where \\(n\\) is the length of the string and \\(k\\) is the number of words.<br/>     - For each starting index, we iterate over all words in `words`.<br/>   - Space Complexity: \\(O(k)\\), where \\(k\\) is the number of unique words in `words`.<br/><br/>5. Edge Cases:<br/>   - Empty string `s` or `words`: Return an empty array.<br/>   - No valid substrings: Return an empty array.<br/>   - Overlapping substrings: The algorithm handles overlapping cases correctly.<br/><br/>6. Walkthrough with Example:<br/>   - Input: `s = \"barfoothefoobarman\", words = [\"foo\", \"bar\"]`<br/>   - `wordLength = 3`, `substringLength = 6`.<br/>   - Valid substrings:<br/>     - At index `0`: Substring = `\"barfoo\"`.<br/>     - At index `9`: Substring = `\"foobar\"`.<br/>   - Result: `[0, 9]`.",
		"category": "Sliding Window"
	},
	{
		"id": 33,
		"topic": "Minimum Window Substring",
		"code": "// Find the minimum window substring\nvar minWindow = function (s, t) {\n // If `s` is shorter than `t`, it is impossible to form a valid substring.\n if (s.length < t.length) return '';\n // Create a frequency map for characters in `t`\n const tMap = new Map();\n for (let char of t) {\n tMap.set(char, (tMap.get(char) || 0) + 1);\n }\n // Variables for sliding window technique\n let left = 0, right = 0;\n let required = tMap.size;\n let formed = 0;\n const windowCounts = new Map();\n let minLength = Infinity;\n let result = [0, 0];\n // Expand the sliding window by moving the `right` pointer\n while (right < s.length) {\n const char = s[right];\n windowCounts.set(char, (windowCounts.get(char) || 0) + 1);\n if (tMap.has(char) && windowCounts.get(char) === tMap.get(char)) {\n formed++;\n }\n // Shrink the window from the left while it contains all required characters\n while (formed === required) {\n const windowSize = right - left + 1;\n if (windowSize < minLength) {\n minLength = windowSize;\n result = [left, right];\n }\n const leftChar = s[left];\n windowCounts.set(leftChar, windowCounts.get(leftChar) - 1);\n if (tMap.has(leftChar) && windowCounts.get(leftChar) < tMap.get(leftChar)) {\n formed--;\n }\n left++;\n }\n right++;\n }\n return minLength === Infinity ? '' : s.slice(result[0], result[1] + 1);\n};\n\n// Examples:\nconsole.log(minWindow('ADOBECODEBANC', 'ABC')); // Output: \"BANC\"\nconsole.log(minWindow('a', 'a')); // Output: \"a\"\nconsole.log(minWindow('a', 'aa')); // Output: \"\"\n",
		"explanation": "1. Goal:<br/>   - Find the smallest substring in `s` that contains all characters of `t` (including duplicates).<br/><br/>2. Approach:<br/>   - Use the sliding window technique with two pointers (`left` and `right`).<br/>   - Maintain a frequency map (`tMap`) for characters in `t`.<br/>   - Track the number of unique characters in the current window that match the required frequency using `formed`.<br/><br/>3. Steps:<br/>   - Expand the window by moving the `right` pointer.<br/>   - When all characters in `t` are present in the window (`formed === required`), try shrinking the window by moving the `left` pointer.<br/>   - Update the result when a smaller valid window is found.<br/><br/>4. Time Complexity:<br/>   - \\(O(m + n)\\): Iterating over `s` with `right` and at most once with `left`, plus constructing `tMap`.<br/><br/>5. Space Complexity:<br/>   - \\(O(m + n)\\): Space for `tMap` and `windowCounts`.<br/><br/>6. Edge Cases:<br/>   - If `s` is shorter than `t`, return an empty string.<br/>   - If characters in `t` are not in `s`, return an empty string.<br/><br/>7. Walkthrough:<br/>   - Input: `s = \"ADOBECODEBANC\", t = \"ABC\"`<br/>   - Initial `tMap`: `{A: 1, B: 1, C: 1}`<br/>   - Sliding window:<br/>     - Expand: `ADOBE` (not valid)<br/>     - Expand: `ADOBEC` (valid, size = 6)<br/>     - Shrink: `DOBEC` (still valid, size = 5)<br/>     - Expand: Continue until finding `BANC` (size = 4).<br/>   - Output: `\"BANC\"`.",
		"category": "Sliding Window"
	},
	{
		"id": 34,
		"topic": "Valid Sudoku",
		"code": "var isValidSudoku = function(board) {\n    // Create sets to track seen numbers in rows, columns, and sub-boxes\n    let rows = new Array(9).fill(null).map(() => new Set());\n    let cols = new Array(9).fill(null).map(() => new Set());\n    let boxes = new Array(9).fill(null).map(() => new Set());\n    \n    // Iterate through each cell in the 9x9 board\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            let num = board[i][j];\n            \n            // If the cell is not empty\n            if (num !== '.') {\n                // Calculate the index of the sub-box (0-8)\n                let boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);\n                \n                // Log the current number and its position\n                console.log(`Checking number ${num} at position [${i}, ${j}]`);\n                \n                // Check if the number has already appeared in the row, column, or sub-box\n                if (rows[i].has(num)) {\n                    console.log(`Duplicate found in row ${i}: ${num}`);\n                    return false;\n                }\n                if (cols[j].has(num)) {\n                    console.log(`Duplicate found in column ${j}: ${num}`);\n                    return false;\n                }\n                if (boxes[boxIndex].has(num)) {\n                    console.log(`Duplicate found in box ${boxIndex}: ${num}`);\n                    return false;\n                }\n                \n                // Add the number to the respective row, column, and sub-box sets\n                rows[i].add(num);\n                cols[j].add(num);\n                boxes[boxIndex].add(num);\n                \n                // Log the addition of the number\n                console.log(`Added number ${num} to row ${i}, column ${j}, box ${boxIndex}`);\n            }\n        }\n    }\n    \n    // If no duplicates are found, the board is valid\n    console.log('The board is valid');\n    return true;\n};\n\n// Test case 1: Valid Sudoku\nlet board1 = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n];\nconsole.log(isValidSudoku(board1));  // Expected output: true\n",
		"explanation": "Explanation:<br/><br/>1. Sets Creation:<br/>   - Creates sets for each row, column, and 3x3 sub-box to track seen numbers.<br/><br/>2. Loop through the Board:<br/>   - Iterates through each cell in the 9x9 Sudoku grid.<br/><br/>3. Check for Duplicates:<br/>   - For each non-empty cell, checks if the number has already appeared in the same row, column, or sub-box.<br/><br/>4. Return False on Duplicate:<br/>   - If a duplicate is found, logs the duplicate's position and returns false (indicating an invalid Sudoku board).<br/><br/>5. Track Seen Numbers:<br/>   - If no duplicates are found, adds the number to the respective row, column, and sub-box set.<br/><br/>6. Return True if Valid:<br/>   - If the entire board is checked without finding duplicates, returns true (indicating a valid Sudoku board).",
		"category": "Matrix"
	},
	{
		"id": 35,
		"topic": "Spiral Matrix",
		"code": "// Return all elements of the matrix in spiral order\nvar spiralOrder = function(matrix) {\n const result = [];\n if (!matrix || matrix.length === 0) return result;\n let top = 0, bottom = matrix.length - 1;\n let left = 0, right = matrix[0].length - 1;\n while (top <= bottom && left <= right) {\n for (let i = left; i <= right; i++) result.push(matrix[top][i]);\n top++;\n for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n right--;\n if (top <= bottom) {\n for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);\n bottom--;\n }\n if (left <= right) {\n for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n left++;\n }\n }\n return result;\n};\n\n// Examples:\nconsole.log(spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]])); // Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]\nconsole.log(spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])); // Output: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n",
		"explanation": "1. Define boundaries for the traversal: top, bottom, left, right.<br/>2. Use a loop to traverse the matrix in spiral order until the boundaries overlap.<br/>   - Traverse from left to right along the top boundary.<br/>   - Traverse from top to bottom along the right boundary.<br/>   - Traverse from right to left along the bottom boundary (if still within bounds).<br/>   - Traverse from bottom to top along the left boundary (if still within bounds).<br/>3. Shrink the boundaries after each traversal to move inward.<br/>4. Add each traversed element to the result array.<br/>5. Stop when all elements are traversed.<br/><br/>This approach ensures that all elements are visited once, and the boundaries dynamically adjust to focus on the remaining unvisited elements in the matrix.",
		"category": "Matrix"
	},
	{
		"id": 36,
		"topic": "Rotate Image",
		"code": "// Rotate the image by 90 degrees (clockwise)\nvar rotate = function(matrix) {\n const n = matrix.length;\n for (let i = 0; i < n; i++) {\n for (let j = i; j < n; j++) {\n [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n }\n }\n for (let i = 0; i < n; i++) {\n matrix[i].reverse();\n }\n};\n\n// Examples:\nconst matrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\nrotate(matrix1);\nconsole.log(matrix1); // Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\nconst matrix2 = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]];\nrotate(matrix2);\nconsole.log(matrix2); // Output: [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]\n",
		"explanation": "1. Transpose the matrix:<br/>   - Swap element matrix[i][j] with matrix[j][i] for all i < j.<br/>   - This step converts rows into columns. By transposing, the matrix starts to resemble a 90-degree rotation, but the rows are not yet in the correct order.<br/><br/>2. Reverse each row:<br/>   - Flip the elements of each row to achieve the 90-degree rotation. After transposing, each row needs to be reversed for the final transformation.<br/><br/>The transformation is done in-place, meaning no extra space is used for another matrix. This satisfies the problem's constraint of modifying the matrix in place.<br/><br/>This is a great problem to practice working with in-place transformations, which is a useful skill when optimizing memory usage in large applications or when working on performance-sensitive projects like optimizing user interfaces for responsiveness.",
		"category": "Matrix"
	},
	{
		"id": 37,
		"topic": "Set Matrix Zeroes",
		"code": "// Set matrix zeroes\nvar setZeroes = function(matrix) {\n const numRows = matrix.length;  // Number of rows in the matrix\n const numCols = matrix[0].length;  // Number of columns in the matrix\n let isFirstRowZero = false;  // Flag to check if the first row should be zeroed\n let isFirstColZero = false;  // Flag to check if the first column should be zeroed\n // Check if the first row contains any zeros.\n for (let col = 0; col < numCols; col++) {\n if (matrix[0][col] === 0) {\n isFirstRowZero = true;  // Mark the flag if the first row has any zero\n break;  // Exit the loop early once we find a zero in the first row\n }\n }\n // Check if the first column contains any zeros.\n for (let row = 0; row < numRows; row++) {\n if (matrix[row][0] === 0) {\n isFirstColZero = true;  // Mark the flag if the first column has any zero\n break;  // Exit the loop early once we find a zero in the first column\n }\n }\n // Use the first row and first column to mark the corresponding rows and columns that should be zeroed.\n for (let row = 1; row < numRows; row++) {\n for (let col = 1; col < numCols; col++) {\n if (matrix[row][col] === 0) {\n matrix[row][0] = 0;  // Mark the first column for this row (indicating this row needs to be zeroed)\n matrix[0][col] = 0;  // Mark the first row for this column (indicating this column needs to be zeroed)\n }\n }\n }\n // Set the cells to zero based on the marks in the first row and first column.\n for (let row = 1; row < numRows; row++) {\n for (let col = 1; col < numCols; col++) {\n if (matrix[row][0] === 0 || matrix[0][col] === 0) {\n matrix[row][col] = 0;  // Set the element to zero if its row or column is marked\n }\n }\n }\n // Zero out the first row if necessary.\n if (isFirstRowZero) {\n for (let col = 0; col < numCols; col++) {\n matrix[0][col] = 0;  // Set all values in the first row to zero if required\n }\n }\n // Zero out the first column if necessary.\n if (isFirstColZero) {\n for (let row = 0; row < numRows; row++) {\n matrix[row][0] = 0;  // Set all values in the first column to zero if required\n }\n }\n};\n",
		"explanation": "1. First, we check if the first row or first column contains any zeros. If they do, we store this information in the `isFirstRowZero` and `isFirstColZero` flags. This is done to handle these rows/columns separately later.<br/><br/>2. Next, we iterate through the rest of the matrix (excluding the first row and column) to identify which rows and columns contain zeros. For each zero element, we mark the corresponding first row and first column with zeros. This allows us to use the first row and column as markers for zeroing out other rows and columns.<br/><br/>3. After marking, we loop through the matrix again (starting from the second row and column) and set any element to zero if its corresponding row or column is marked (i.e., if the first row or first column at that index is zero).<br/><br/>4. Finally, we check the flags `isFirstRowZero` and `isFirstColZero`. If these flags are true, we set the entire first row or first column to zero, as needed.<br/><br/>This approach modifies the matrix in place and uses **constant space** (O(1) extra space), meaning it doesn't use any additional data structures. The time complexity is O(m * n), where m and n are the number of rows and columns in the matrix.",
		"category": "Matrix"
	},
	{
		"id": 38,
		"topic": "Game of Life",
		"code": "// Implement the Game of Life\nvar gameOfLife = function(board) {\n const m = board.length;  // Get the number of rows in the board.\n const n = board[0].length;  // Get the number of columns in the board.\n\n // Directions to check for all 8 neighbors: top-left, top, top-right, left, right, bottom-left, bottom, bottom-right\n const directions = [\n [-1, -1], [-1, 0], [-1, 1],\n [ 0, -1], [ 0, 1],\n [ 1, -1], [ 1, 0], [ 1, 1]\n ];\n\n // Count the live neighbors and encode the next state in place\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n let liveNeighbors = 0;\n\n // Count live neighbors by checking all 8 surrounding cells\n for (let [dx, dy] of directions) {\n const x = i + dx;  // x-coordinate of the neighbor\n const y = j + dy;  // y-coordinate of the neighbor\n\n // Check if the neighbor is within bounds and is alive (1) or will stay alive (3)\n if (x >= 0 && x < m && y >= 0 && y < n && (board[x][y] === 1 || board[x][y] === 3)) {\n liveNeighbors++;\n }\n }\n\n // Apply the rules to determine the next state of the cell\n if (board[i][j] === 1) {  // If the current cell is alive\n // Rule 1: Live cell with fewer than 2 or more than 3 live neighbors dies\n if (liveNeighbors < 2 || liveNeighbors > 3) {\n board[i][j] = 3;  // Mark the cell as dead in the next state\n }\n // Rule 2: Live cell with 2 or 3 live neighbors stays alive\n else {\n board[i][j] = 1;  // Keep the cell alive\n }\n } else if (board[i][j] === 0 && liveNeighbors === 3) {  \n // Rule 3: Dead cell with exactly 3 live neighbors becomes alive\n board[i][j] = 2;  // Mark the cell as alive in the next state\n }\n // Rule 4:Any dead cell with exactly three live neighbors becomes a live cell.  (Implicit in the logic) \n }\n }\n\n // Finalize the board by converting the encoded states back to the final state\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n // Convert the encoded states back to 0 (dead) or 1 (alive)\n if (board[i][j] === 2 || board[i][j] === 1) {\n board[i][j] = 1;  // Cells that are alive in the next state should be 1\n } else {\n board[i][j] = 0;  // Cells that are dead should be 0\n }\n }\n }\n};\n\n// Example 1: A \"blinker\" oscillator pattern in Game of Life\nlet board1 = [\n [0, 0, 0],\n [1, 1, 1],\n [0, 0, 0]\n];\nconsole.log(\"Initial board1:\");\nconsole.log(board1);\ngameOfLife(board1);\nconsole.log(\"After one step:\");\nconsole.log(board1);\n\n// Example 2: A \"block\" still life pattern in Game of Life\nlet board2 = [\n [0, 0, 0, 0],\n [0, 1, 1, 0],\n [0, 1, 1, 0],\n [0, 0, 0, 0]\n];\nconsole.log(\"Initial board2:\");\nconsole.log(board2);\ngameOfLife(board2);\nconsole.log(\"After one step:\");\nconsole.log(board2);\n\n// Example 3: A \"glider\" spaceship pattern in Game of Life\nlet board3 = [\n [0, 0, 0, 0, 0],\n [0, 1, 1, 0, 0],\n [1, 1, 0, 0, 0],\n [0, 0, 1, 0, 0],\n [0, 0, 0, 0, 0]\n];\nconsole.log(\"Initial board3:\");\nconsole.log(board3);\ngameOfLife(board3);\nconsole.log(\"After one step:\");\nconsole.log(board3);\n",
		"explanation": "The function `gameOfLife` simulates the next state of the Game of Life grid in place, modifying the `board` directly.<br/>- The grid has cells that can either be alive (1) or dead (0), and based on the state of the cell and its neighbors, the next state is determined.<br/>- The key steps are:<br/>  1. Counting live neighbors for each cell using the 8 possible neighboring directions.<br/>  2. Encoding the next state of the cell:<br/>     - '1' represents a live cell.<br/>     - '0' represents a dead cell.<br/>     - '2' represents a dead cell that will become alive in the next step.<br/>     - '3' represents a live cell that will die in the next step.<br/>  3. Finalizing the grid by converting the encoded values back to the final state: cells that remain alive (1 or 2) are set to 1, and cells that remain dead (0 or 3) are set to 0.",
		"category": "Matrix"
	},
	{
		"id": 39,
		"topic": "Ransom Note",
		"code": "// Check if ransom note can be constructed from magazine\nvar canConstruct = function(ransomNote, magazine) {\n // Create a frequency count for the letters in the magazine\n const letterCount = new Array(26).fill(0);  // Array to store the count of each letter (a to z)\n\n // Count the frequency of each letter in the magazine\n for (let char of magazine) {\n letterCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n }\n\n // Check if we can construct the ransomNote using letters from the magazine\n for (let char of ransomNote) {\n const index = char.charCodeAt(0) - 'a'.charCodeAt(0);  // Find the index of the letter\n\n // If the letter is not available or exhausted in the magazine, return false\n if (letterCount[index] === 0) {\n return false;  // Not enough letters to form the ransom note\n }\n\n // Decrease the count for the letter in the magazine as we use it\n letterCount[index]--;\n }\n\n // If we successfully go through all characters in the ransom note, return true\n return true;\n};\n",
		"explanation": "The function `canConstruct` checks whether the ransom note can be formed by using letters from the magazine.\n- A frequency count of the letters in the magazine is created using an array where each index represents a letter from 'a' to 'z'.\n- The function then iterates over the characters of the ransomNote and checks if there are enough available letters in the magazine (i.e., if the frequency count is greater than 0).\n- If any letter from the ransomNote can't be matched by a letter from the magazine (due to insufficient count), the function returns `false`. Otherwise, it returns `true`.\n\nTime Complexity:\n- Counting the letters in the magazine takes O(m), where m is the length of the magazine.\n- Checking the ransomNote takes O(n), where n is the length of the ransomNote.\n- Overall time complexity is O(m + n), which is efficient for the input size constraints.\n\nSpace Complexity:\n- The space complexity is O(1) as the letterCount array always has a fixed size of 26, regardless of the input size.",
		"category": "Hashmap"
	},
	{
		"id": 40,
		"topic": "Isomorphic Strings",
		"code": "// Check if two strings are isomorphic\nfunction isIsomorphic(s, t) {\n let mapS = new Map(), mapT = new Map();\n for (let i = 0; i < s.length; i++) {\n let charS = s[i], charT = t[i];\n if ((mapS.has(charS) && mapS.get(charS) !== charT) || (mapT.has(charT) && mapT.get(charT) !== charS)) return false;\n mapS.set(charS, charT);\n mapT.set(charT, charS);\n }\n return true;\n}\n",
		"explanation": "This function checks if two strings are isomorphic.",
		"category": "Hashmap"
	},
	{
		"id": 41,
		"topic": "Word Pattern",
		"code": "function wordPattern(pattern, s) {\n // Split the string s into an array of words. This creates an array where each element is a word from the input string.\n const words = s.split(' ');\n // If the number of elements in the pattern does not match the number of words, return false.\n // This is a quick check to ensure that the one-to-one mapping can exist.\n if (pattern.length !== words.length) { // If lengths are different, the pattern cannot match the words.\n return false; \n }\n // Initialize two maps to store the character-to-word and word-to-character correspondences.\n // These maps will help track what each character in the pattern maps to and vice versa.\n const charToWordMap = new Map();\n const wordToCharMap = new Map();\n // This loop goes through each character in the pattern and its corresponding word in the words array.\n for (let i = 0; i < pattern.length; ++i) {\n const char = pattern[i]; // Current character from the pattern.\n const word = words[i]; // Current word from the string.\n // Check if the current character is already associated with a different word. If the character is already in the charToWordMap and it maps \n // to a word different from the current one, it indicates a conflict in mapping and thus the pattern cannot match.\n if (charToWordMap.has(char)) {\n if (charToWordMap.get(char) !== word) {\n return false; // Mismatch found, return false.\n }\n }\n // Check if the current word is already associated with a different character. Similar to the previous check, if the word is already mapped \n // to a character different from the current one,this also indicates a conflict.\n if (wordToCharMap.has(word)) {\n if (wordToCharMap.get(word) !== char) {\n return false; // Mismatch found, return false.\n }\n }\n // Add the current character-to-word and word-to-character association to the maps. If no conflicts were found, we can safely set the \n //mapping for both the character and the word.\n charToWordMap.set(char, word);\n wordToCharMap.set(word, char);\n }\n // If no mismatch was found, return true. This means all characters and words have been successfully mapped without any conflicts.\n return true;\n}\n// Example usage\nconsole.log(wordPattern(\"abba\", \"dog cat cat dog\")); // Output: true\nconsole.log(wordPattern(\"abba\", \"dog cat cat fish\")); // Output: false\nconsole.log(wordPattern(\"aaaa\", \"dog cat cat dog\")); // Output: false\nconsole.log(wordPattern(\"abba\", \"dog constructor constructor dog\")); // Output: true\n",
		"explanation": "1. Input Parameters:<br/>   - `pattern`: A string where each character represents a pattern to match.<br/>   - `s`: A string where words are expected to correspond to characters in `pattern`.<br/><br/>2. Splitting the Input String:<br/>   - `s.split(' ')` splits the string `s` into an array of words using spaces as separators.<br/><br/>3. Quick Length Check:<br/>   - If the length of the `pattern` does not match the number of words in `s`, we return `false` immediately, as no one-to-one mapping can exist.<br/><br/>4. Maps for Mappings:<br/>   - `charToWordMap`: A map that tracks the mapping of characters from `pattern` to words.<br/>   - `wordToCharMap`: A map that tracks the reverse mapping, ensuring no word is assigned to more than one character.<br/><br/>5. Iteration over the Pattern:<br/>   - The function iterates through each character in `pattern` and its corresponding word in `words`:<br/>     - If the character is already mapped to a different word, it returns `false`.<br/>     - If the word is already mapped to a different character, it also returns `false`.<br/><br/>6. Returning the Result:<br/>   - If no conflicts are found after checking all the mappings, the function returns `true`, indicating a consistent one-to-one mapping exists between the pattern and the words.<br/><br/>7. Example Outputs:<br/>   - `\"abba\", \"dog cat cat dog\"` → `true`: The mapping is consistent (a → dog, b → cat).<br/>   - `\"abba\", \"dog cat cat fish\"` → `false`: The word \"fish\" doesn't match the expected \"dog\" for the first \"a\".<br/>   - `\"aaaa\", \"dog cat cat dog\"` → `false`: The word \"cat\" can't map to multiple characters.",
		"category": "Hashmap"
	},
	{
		"id": 42,
		"topic": "Valid Anagram",
		"code": "// Check if two strings are anagrams\nfunction isAnagram(s, t) {\n if (s.length !== t.length) return false;\n let map = new Map();\n for (let char of s) {\n map.set(char, (map.get(char) || 0) + 1);\n }\n for (let char of t) {\n if (!map.has(char) || map.get(char) === 0) return false;\n map.set(char, map.get(char) - 1);\n }\n return true;\n}\n",
		"explanation": "This function checks if two strings are anagrams.",
		"category": "Hashmap"
	},
	{
		"id": 43,
		"topic": "Group Anagrams",
		"code": "// Group anagrams\nfunction groupAnagrams(strs) {\n let map = new Map();\n for (let str of strs) {\n let sortedStr = str.split('').sort().join('');\n if (!map.has(sortedStr)) map.set(sortedStr, []);\n map.get(sortedStr).push(str);\n }\n return Array.from(map.values());\n}\n",
		"explanation": "This function groups anagrams together.",
		"category": "Hashmap"
	},
	{
		"id": 44,
		"topic": "Two Sum",
		"code": "var twoSum = function (nums, target) {\n    // Initialize a hash map to store elements and their indices\n    const map = new Map();\n\n    // Loop through the array with index `i`\n    for (let i = 0; i < nums.length; i++) {\n        // Calculate the complement that we need to reach the target\n        const complement = target - nums[i];\n\n        // Check if the complement is in the map\n        if (map.has(complement)) {\n            // If found, return the indices [map.get(complement), i]\n            return [map.get(complement), i];\n        }\n\n        // Store the current element with its index in the map\n        map.set(nums[i], i);\n    }\n\n    // Return an empty array if no solution is found (though the problem guarantees one solution exists)\n    return [];\n};\n",
		"explanation": "Explanation of Each Step:<br/><br/>1. Hash Map Initialization:<br/>   - We initialize an empty map to store each number and its index as we iterate through `nums`.<br/><br/>2. Looping Through nums:<br/>   - For each number `nums[i]`, we calculate the `complement`, which is the difference between the `target` and `nums[i]`.<br/>   - We check if this `complement` exists in the map. If it does, it means that we have previously encountered a number that pairs with `nums[i]` to reach the target.<br/><br/>3. Returning the Solution:<br/>   - If the complement is found in the map, we return the indices of the two numbers: `[map.get(complement), i]`.<br/>   - If the complement is not found, we store the current number and its index in the map to check against future elements.<br/><br/>4. Complexity:<br/>   - **Time Complexity**: O(n) since we only iterate through the array once.<br/>   - **Space Complexity**: O(n) due to the hash map storing up to n elements.",
		"category": "Hashmap"
	},
	{
		"id": 45,
		"topic": "Happy Number",
		"code": "var isHappy = function(n) {\n    // A set to track previously encountered numbers to detect cycles\n    let seen = new Set();\n\n    // Loop until n becomes 1 (happy) or we detect a cycle (repeated number)\n    while (n !== 1) {\n        console.log(`Current number: ${n}`);\n\n        // If the number has been seen before, it means we're in a cycle\n        if (seen.has(n)) {\n            console.log(`Cycle detected: ${n} has already been seen.`);\n            return false;\n        }\n\n        // Add the current number to the set to track it\n        seen.add(n);\n\n        // Calculate the sum of the squares of the digits of n\n        let sumOfSquares = 0;\n        let temp = n; // Temporary variable to calculate sum of squares\n        while (temp > 0) {\n            let digit = temp % 10;            // Extract the last digit of n\n            sumOfSquares += digit * digit;    // Add the square of the digit to the sum\n            temp = Math.floor(temp / 10);     // Remove the last digit from n\n        }\n\n        // Log the sum of squares of digits\n        console.log(`Sum of squares of digits: ${sumOfSquares}`);\n\n        // Update n to the sum of the squares of its digits\n        n = sumOfSquares;\n    }\n\n    // If n reaches 1, it's a happy number\n    console.log(`Happy number found: ${n}`);\n    return true;\n};\n",
		"explanation": "Explanation:<br/><br/>1. The set `seen` is used to track numbers we've already encountered, allowing us to detect cycles.<br/><br/>2. The number `n` is repeatedly replaced with the sum of the squares of its digits.<br/><br/>3. If `n` becomes 1, the function returns true, indicating it is a happy number.<br/><br/>4. If `n` repeats (cycle detected), the function returns false, indicating it's not a happy number.",
		"category": "Hashmap"
	},
	{
		"id": 46,
		"topic": "Contains Duplicate II",
		"code": "// Check if the array contains duplicates within k distance\nfunction containsNearbyDuplicate(nums, k) {\n let map = new Map();\n for (let i = 0; i < nums.length; i++) {\n if (map.has(nums[i]) && i - map.get(nums[i]) <= k) return true;\n map.set(nums[i], i);\n }\n return false;\n}\n",
		"explanation": "This function checks if the array contains duplicates within k distance.",
		"category": "Hashmap"
	},
	{
		"id": 47,
		"topic": "Longest Consecutive Sequence",
		"code": "// Find the length of the longest consecutive sequence\nfunction longestConsecutive(nums) {\n let set = new Set(nums);\n let maxLength = 0;\n for (let num of nums) {\n if (!set.has(num - 1)) {\n let length = 0;\n while (set.has(num + length)) length++;\n maxLength = Math.max(maxLength, length);\n }\n }\n return maxLength;\n}\n",
		"explanation": "This function finds the length of the longest consecutive sequence in an array.",
		"category": "Hashmap"
	},
	{
		"id": 48,
		"topic": "Summary Ranges",
		"code": "// Find summary ranges\nvar summaryRanges = function(nums) {\n    // Edge case: If the input array is empty, return an empty array.\n    if (nums.length === 0) return [];\n\n    let result = []; // Array to store the resulting ranges.\n    let start = nums[0]; // Starting number of the current range.\n\n    // Log initial values.\n    console.log(\"Initial nums array:\", nums);\n\n    // Iterate through the array starting from the second element.\n    for (let i = 1; i <= nums.length; i++) {\n        // Log the current iteration details.\n        console.log(`Iteration ${i}: Current number = ${nums[i-1]}, Start = ${start}`);\n\n        // Check if we are at the end of the array or if the current number is not consecutive.\n        if (i === nums.length || nums[i] !== nums[i - 1] + 1) {\n            // Log range detection.\n            console.log(`Range detected from ${start} to ${nums[i - 1]}`);\n\n            // Determine the range and add it to the result.\n            if (start === nums[i - 1]) {\n                result.push(`${start}`); // Single number range.\n                console.log(`Added single number: ${start}`);\n            } else {\n                result.push(`${start}->${nums[i - 1]}`); // Continuous range.\n                console.log(`Added range: ${start}->${nums[i - 1]}`);\n            }\n\n            // Update `start` for the next range.\n            if (i < nums.length) start = nums[i];\n            console.log(`Updated start for next range: ${start}`);\n        }\n    }\n    console.log(\"Final result:\", result);\n\n    return result;\n};\n",
		"explanation": "Explanation:<br/>1. Initialization:<br/>   - We set `start` to the first element of the `nums` array, marking the beginning of the first range.<br/><br/>2. Loop through the Array:<br/>   - We iterate through the `nums` array starting from the second element.<br/>   - In each iteration:<br/>     - We check if the current number is consecutive to the previous one. If not, this indicates the end of the current range.<br/>     - We construct the range and add it to the `result` array in the appropriate format:<br/>       - If `start` equals `nums[i - 1]`, we add the single number range `start`.<br/>       - Otherwise, we add the continuous range in the format `start->nums[i - 1]`.<br/>     - We update `start` to `nums[i]` if `i < nums.length` to prepare for the next range.<br/><br/>3. Edge Case Handling:<br/>   - If the array is empty, we return an empty array.<br/><br/>Example Walkthrough:<br/>- For input `nums = [0,1,2,4,5,7]`:<br/>  - We start with `start = 0` and form the range \"0->2\".<br/>  - Next, `4, 5` form the range \"4->5\".<br/>  - Finally, `7` is a single number, so we add \"7\" to the result.<br/>  - The resulting array is [\"0->2\", \"4->5\", \"7\"].<br/><br/>- For input `nums = [0,2,3,4,6,8,9]`:<br/>  - The first number is `0`, so the range is \"0\".<br/>  - `2, 3, 4` form the range \"2->4\".<br/>  - `6` is a single number, so we add \"6\" to the result.<br/>  - `8, 9` form the range \"8->9\".<br/>  - The resulting array is [\"0\", \"2->4\", \"6\", \"8->9\"].<br/><br/>Time and Space Complexity:<br/>- Time Complexity: O(n), where `n` is the number of elements in `nums`. We iterate through the array once.<br/>- Space Complexity: O(k), where `k` is the number of ranges in the result array. In the worst case, this is O(n) if there are no consecutive numbers.",
		"category": "Intervals"
	},
	{
		"id": 49,
		"topic": "Merge Intervals",
		"code": "// Merge overlapping intervals\nfunction merge(intervals) {\n if (!intervals.length) return [];\n intervals.sort((a, b) => a[0] - b[0]);\n let merged = [intervals[0]];\n for (let i = 1; i < intervals.length; i++) {\n let [prevStart, prevEnd] = merged[merged.length - 1];\n let [currStart, currEnd] = intervals[i];\n if (currStart <= prevEnd) {\n merged[merged.length - 1][1] = Math.max(prevEnd, currEnd);\n } else {\n merged.push(intervals[i]);\n }\n }\n return merged;\n}\n",
		"explanation": "This function merges overlapping intervals in an array.",
		"category": "Intervals"
	},
	{
		"id": 50,
		"topic": "Insert Interval",
		"code": "// Insert a new interval into a list of non-overlapping intervals\nfunction insert(intervals, newInterval) {\n let result = [];\n let i = 0;\n while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n result.push(intervals[i++]);\n }\n while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n i++;\n }\n result.push(newInterval);\n while (i < intervals.length) {\n result.push(intervals[i++]);\n }\n return result;\n}\n",
		"explanation": "This function inserts a new interval into a list of non-overlapping intervals and merges if necessary.",
		"category": "Intervals"
	},
	{
		"id": 51,
		"topic": "Minimum Number of Arrows to Burst Balloons",
		"code": "// Find the minimum number of arrows to burst all balloons\nfunction findMinArrowShots(points) {\n if (!points.length) return 0;\n points.sort((a, b) => a[1] - b[1]);\n let arrows = 1, end = points[0][1];\n for (let i = 1; i < points.length; i++) {\n if (points[i][0] > end) {\n arrows++;\n end = points[i][1];\n }\n }\n return arrows;\n}\n",
		"explanation": "This function finds the minimum number of arrows required to burst all balloons represented as intervals.",
		"category": "Intervals"
	},
	{
		"id": 52,
		"topic": "Valid Parentheses",
		"code": "// Check if the parentheses are valid\nconst isValid = function(s) {\n     console.log(\"Initial Stack:\", s);\n    // Stack to keep track of opening brackets\n    const stack = [];\n    // Map to match closing brackets with their respective opening brackets\n    const matchingBrackets = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n    \n    for (let char of s) {\n        if (char === '(' || char === '{' || char === '[') {\n            // Push opening brackets onto the stack\n            stack.push(char);\n            console.log(`Pushed ${char} onto the stack:`, stack);\n        } else {\n            // Check if the stack is empty or if the top of the stack doesn't match\n            if (stack.length === 0) {\n                console.log(`Stack is empty when encountering ${char}`);\n                return false;\n            }\n            if (stack[stack.length - 1] !== matchingBrackets[char]) {\n                console.log(`Mismatch found: expected ${matchingBrackets[char]}, found ${char}`);\n                return false;\n            }\n            // Pop the matched opening bracket\n            console.log(`Popped ${stack[stack.length - 1]} for ${char}`);\n            stack.pop();\n        }\n    }\n    \n    // Final state of the stack\n    console.log(\"Final stack state:\", stack);\n    // If the stack is empty, all brackets were matched correctly\n    return stack.length === 0;\n};\n\n// Example usage\nconsole.log(\"true?: \", isValid(\"()[]{}\"));  // Expected output: true\nconsole.log(\"false?: \", isValid(\"(]\"));      // Expected output: false\nconsole.log(\"true?: \", isValid(\"([{}])\"));  // Expected output: true\nconsole.log(\"false?: \", isValid(\"((()))]\")); // Expected output: false\n",
		"explanation": "Explanation<br/>Initial Logging:<br/><br/>console.log(\"Initial Stack:\", s); logs the input string to give context about the input before processing.<br/>Setting Up the Stack:<br/><br/>const stack = []; initializes an empty stack to keep track of opening brackets. This stack helps ensure that each opening bracket has a corresponding and correctly ordered closing bracket.<br/>Matching Map for Closing Brackets:<br/><br/>const matchingBrackets = { ')': '(', '}': '{', ']': '[' }; defines a dictionary mapping each closing bracket to its respective opening bracket. This will make it easy to check if each closing bracket has a corresponding opening bracket in the correct order.<br/>Iterating through the Characters in the String:<br/><br/>The function iterates through each character in the input string s with for (let char of s).<br/><br/>If the character is an opening bracket ((, {, or [):<br/><br/>stack.push(char); pushes the character onto the stack.<br/>console.log(...) logs that the character has been pushed, displaying the current stack’s state.<br/>If the character is a closing bracket (), }, or ]):<br/><br/>Empty Stack Check:<br/>if (stack.length === 0) checks if the stack is empty. If true, it logs this and returns false because there’s no opening bracket for this closing bracket, making the string invalid.<br/>Mismatched Brackets Check:<br/>if (stack[stack.length - 1] !== matchingBrackets[char]) compares the last pushed opening bracket (top of the stack) with the expected matching bracket from matchingBrackets. If they don’t match, it logs this mismatch and returns false.<br/>Matching Brackets:<br/>If the closing bracket matches the top opening bracket, stack.pop() removes this opening bracket from the stack, effectively “matching” this pair of brackets.<br/>console.log(...) logs this successful pop, showing which bracket was removed from the stack for the matched closing bracket.<br/>Final Stack Check:<br/><br/>After the loop, console.log(\"Final stack state:\", stack); logs the state of the stack. For the string to be valid, the stack should be empty; this would mean all opening brackets were properly closed and matched.<br/>return stack.length === 0; returns true if the stack is empty (valid string) and false otherwise (invalid string).",
		"category": "Stack"
	},
	{
		"id": 53,
		"topic": "Simplify Path",
		"code": "// Simplify the file path\nfunction simplifyPath(path) {\n let stack = [];\n let parts = path.split('/');\n for (let part of parts) {\n if (part === '' || part === '.') continue;\n if (part === '..') stack.pop();\n else stack.push(part);\n }\n return '/' + stack.join('/');\n}\n",
		"explanation": "This function simplifies a given file path.",
		"category": "Stack"
	},
	{
		"id": 54,
		"topic": "Min Stack",
		"code": "// Implement a stack that supports push, pop, top, and retrieving the minimum element\nclass MinStack {\n constructor() {\n this.stack = [];\n this.minStack = [];\n }\n push(val) {\n this.stack.push(val);\n if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n this.minStack.push(val);\n }\n }\n pop() {\n let val = this.stack.pop();\n if (val === this.minStack[this.minStack.length - 1]) {\n this.minStack.pop();\n }\n }\n top() {\n return this.stack[this.stack.length - 1];\n }\n getMin() {\n return this.minStack[this.minStack.length - 1];\n }\n}\n",
		"explanation": "This class implements a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
		"category": "Stack"
	},
	{
		"id": 55,
		"topic": "Evaluate Reverse Polish Notation",
		"code": "// Evaluate the value of an arithmetic expression in Reverse Polish Notation\nfunction evalRPN(tokens) {\n let stack = [];\n for (let token of tokens) {\n if (!isNaN(token)) stack.push(Number(token));\n else {\n let b = stack.pop(), a = stack.pop();\n switch (token) {\n case '+': stack.push(a + b); break;\n case '-': stack.push(a - b); break;\n case '*': stack.push(a * b); break;\n case '/': stack.push(Math.trunc(a / b)); break;\n }\n }\n }\n return stack[0];\n}\n",
		"explanation": "This function evaluates the value of an arithmetic expression in Reverse Polish Notation.",
		"category": "Stack"
	},
	{
		"id": 56,
		"topic": "Basic Calculator",
		"code": "// Implement a basic calculator to evaluate a simple expression string\nfunction calculate(s) {\n let stack = [], num = 0, sign = 1, result = 0;\n for (let char of s) {\n if (!isNaN(char) && char !== ' ') num = num * 10 + Number(char);\n else if (char === '+') {\n result += sign * num;\n num = 0;\n sign = 1;\n } else if (char === '-') {\n result += sign * num;\n num = 0;\n sign = -1;\n } else if (char === '(') {\n stack.push(result);\n stack.push(sign);\n result = 0;\n sign = 1;\n } else if (char === ')') {\n result += sign * num;\n num = 0;\n result *= stack.pop();\n result += stack.pop();\n }\n }\n return result + (sign * num);\n}\n",
		"explanation": "This function implements a basic calculator to evaluate a simple expression string.",
		"category": "Stack"
	},
	{
		"id": 57,
		"topic": "Linked List Cycle",
		"code": "// Check if a linked list has a cycle\nvar hasCycle = function(head) {\n // Edge case: A list with no nodes or only one node cannot have a cycle.\n if (!head || !head.next) return false;\n \n // Initialize two pointers: \n // 'slow' moves one step at a time, while 'fast' moves two steps at a time.\n let slow = head;\n let fast = head;\n \n // Traverse the list using the two pointers.\n while (fast && fast.next) {\n slow = slow.next; // Move 'slow' one step forward.\n fast = fast.next.next; // Move 'fast' two steps forward.\n \n // If 'slow' and 'fast' meet, a cycle exists in the list.\n if (slow === fast) {\n return true;\n }\n }\n \n // If the loop ends, it means 'fast' reached the end of the list (no cycle).\n return false;\n};\n",
		"explanation": "Explanation:<br/><br/>1. Edge Case Handling:<br/>   - If the list is empty (`head` is null) or has only one node (`head.next` is null), <br/>     it cannot contain a cycle, so we return false.<br/><br/>2. Pointer Initialization:<br/>   - 'slow' pointer moves one step at a time.<br/>   - 'fast' pointer moves two steps at a time.<br/><br/>3. Cycle Detection:<br/>   - As 'fast' moves faster, if a cycle exists, 'slow' and 'fast' will eventually <br/>     meet within the cycle.<br/>   - If 'fast' or 'fast.next' becomes null, it means the list has no cycle.<br/><br/>4. Return Value:<br/>   - If the two pointers meet, return true (a cycle is detected).<br/>   - If the loop terminates without the pointers meeting, return false (no cycle).<br/><br/>Example Use Cases:<br/>- Input: [3, 2, 0, -4] with pos = 1 (tail connects to the node at index 1)<br/>  Output: true (cycle detected).<br/>- Input: [1, 2] with pos = 0 (tail connects to the head)<br/>  Output: true (cycle detected).<br/>- Input: [1] with pos = -1 (no cycle)<br/>  Output: false (no cycle).",
		"category": "Linked List"
	},
	{
		"id": 58,
		"topic": "Add Two Numbers",
		"code": "// Add two numbers represented by linked lists\nfunction addTwoNumbers(l1, l2) {\n let dummy = new ListNode(0);\n let p = l1, q = l2, current = dummy;\n let carry = 0;\n while (p || q) {\n let x = p ? p.val : 0;\n let y = q ? q.val : 0;\n let sum = carry + x + y;\n carry = Math.floor(sum / 10);\n current.next = new ListNode(sum % 10);\n current = current.next;\n if (p) p = p.next;\n if (q) q = q.next;\n }\n if (carry > 0) {\n current.next = new ListNode(carry);\n }\n return dummy.next;\n}\n",
		"explanation": "This function adds two numbers represented by linked lists and returns the sum as a linked list.",
		"category": "Linked List"
	},
	{
		"id": 59,
		"topic": "Merge Two Sorted Lists",
		"code": "// Merge two sorted linked lists\nfunction mergeTwoLists(l1, l2) {\n let dummy = new ListNode(0);\n let current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n}\n",
		"explanation": "This function merges two sorted linked lists and returns the merged list.",
		"category": "Linked List"
	},
	{
		"id": 60,
		"topic": "Copy List with Random Pointer",
		"code": "// Copy a linked list with random pointer\nfunction copyRandomList(head) {\n if (!head) return null;\n let map = new Map();\n let current = head;\n while (current) {\n map.set(current, new ListNode(current.val));\n current = current.next;\n }\n current = head;\n while (current) {\n map.get(current).next = map.get(current.next) || null;\n map.get(current).random = map.get(current.random) || null;\n current = current.next;\n }\n return map.get(head);\n}\n",
		"explanation": "This function copies a linked list with random pointers and returns the deep copy.",
		"category": "Linked List"
	},
	{
		"id": 61,
		"topic": "Reverse Linked List II",
		"code": "// Reverse a linked list from position m to n\nfunction reverseBetween(head, m, n) {\n if (!head) return null;\n let dummy = new ListNode(0);\n dummy.next = head;\n let prev = dummy;\n for (let i = 1; i < m; i++) prev = prev.next;\n let start = prev.next;\n let then = start.next;\n for (let i = 0; i < n - m; i++) {\n start.next = then.next;\n then.next = prev.next;\n prev.next = then;\n then = start.next;\n }\n return dummy.next;\n}\n",
		"explanation": "This function reverses a linked list from position m to n.",
		"category": "Linked List"
	},
	{
		"id": 62,
		"topic": "Reverse Nodes in k-Group",
		"code": "// Reverse nodes in k-group\nfunction reverseKGroup(head, k) {\n let count = 0;\n let node = head;\n while (node && count < k) {\n node = node.next;\n count++;\n }\n if (count === k) {\n let reversedHead = reverse(head, k);\n head.next = reverseKGroup(node, k);\n return reversedHead;\n }\n return head;\n}\nfunction reverse(head, k) {\n let prev = null, current = head;\n while (k--) {\n let next = current.next;\n current.next = prev;\n prev = current;\n current = next;\n }\n return prev;\n}\n",
		"explanation": "This function reverses nodes in k-group in a linked list.",
		"category": "Linked List"
	},
	{
		"id": 63,
		"topic": "Remove Nth Node From End of List",
		"code": "// Remove the nth node from the end of the list\nfunction removeNthFromEnd(head, n) {\n let dummy = new ListNode(0);\n dummy.next = head;\n let first = dummy, second = dummy;\n for (let i = 0; i <= n; i++) first = first.next;\n while (first) {\n first = first.next;\n second = second.next;\n }\n second.next = second.next.next;\n return dummy.next;\n}\n",
		"explanation": "This function removes the nth node from the end of the list.",
		"category": "Linked List"
	},
	{
		"id": 64,
		"topic": "Remove Duplicates from Sorted List II",
		"code": "// Remove duplicates from sorted list\nfunction deleteDuplicates(head) {\n let dummy = new ListNode(0);\n dummy.next = head;\n let prev = dummy;\n while (head) {\n if (head.next && head.val === head.next.val) {\n while (head.next && head.val === head.next.val) head = head.next;\n prev.next = head.next;\n } else {\n prev = prev.next;\n }\n head = head.next;\n }\n return dummy.next;\n}\n",
		"explanation": "This function removes duplicates from a sorted linked list.",
		"category": "Linked List"
	},
	{
		"id": 65,
		"topic": "Rotate List",
		"code": "// Rotate a linked list to the right by k places\nfunction rotateRight(head, k) {\n if (!head || !head.next) return head;\n let length = 1;\n let tail = head;\n while (tail.next) {\n tail = tail.next;\n length++;\n }\n k = k % length;\n if (k === 0) return head;\n tail.next = head;\n for (let i = 0; i < length - k; i++) tail = tail.next;\n let newHead = tail.next;\n tail.next = null;\n return newHead;\n}\n",
		"explanation": "This function rotates a linked list to the right by k places.",
		"category": "Linked List"
	},
	{
		"id": 66,
		"topic": "Partition List",
		"code": "// Partition a linked list around a value x\nfunction partition(head, x) {\n let before = new ListNode(0), after = new ListNode(0);\n let beforeHead = before, afterHead = after;\n while (head) {\n if (head.val < x) {\n before.next = head;\n before = before.next;\n } else {\n after.next = head;\n after = after.next;\n }\n head = head.next;\n }\n after.next = null;\n before.next = afterHead.next;\n return beforeHead.next;\n}\n",
		"explanation": "This function partitions a linked list around a value x.",
		"category": "Linked List"
	},
	{
		"id": 67,
		"topic": "LRU Cache",
		"code": "// Implement LRU Cache\nclass LRUCache {\n constructor(capacity) {\n this.capacity = capacity;\n this.cache = new Map();\n }\n get(key) {\n if (!this.cache.has(key)) return -1;\n let value = this.cache.get(key);\n this.cache.delete(key);\n this.cache.set(key, value);\n return value;\n }\n put(key, value) {\n if (this.cache.has(key)) this.cache.delete(key);\n this.cache.set(key, value);\n if (this.cache.size > this.capacity) this.cache.delete(this.cache.keys().next().value);\n }\n}\n",
		"explanation": "This class implements an LRU Cache.",
		"category": "Linked List"
	},
	{
		"id": 68,
		"topic": "Maximum Depth of Binary Tree",
		"code": "var maxDepth = function(root) {\n    // Base case: if the node is null, the depth is 0\n    if (root === null) {\n        console.log(\"Reached a null node, returning depth of 0.\");\n        return 0;\n    }\n\n    // Log the current node being processed\n    console.log(`Processing node with value: ${root.val}`);\n\n    // Recursively find the depth of the left and right subtrees\n    const leftDepth = maxDepth(root.left);\n    const rightDepth = maxDepth(root.right);\n\n    // Log the depths of the left and right subtrees\n    console.log(`At node ${root.val}: Left Subtree Depth: ${leftDepth}, Right Subtree Depth: ${rightDepth}`);\n\n    // The depth of the current node is the maximum depth of the left and right subtrees, plus 1 for the current node\n    const currentDepth = Math.max(leftDepth, rightDepth) + 1;\n\n    // Log the calculated depth for the current node\n    console.log(`At node ${root.val}: Returning Depth: ${currentDepth}`);\n\n    return currentDepth;\n};\n\n// Test 1: Tree: [3,9,20,null,null,15,7]\n// ERD: \n//      3\n//     / \\\n//    9   20\n//        /  \\\n//       15   7\nconst testTree1 = new TreeNode(3);\ntestTree1.left = new TreeNode(9);\ntestTree1.right = new TreeNode(20);\ntestTree1.right.left = new TreeNode(15);\ntestTree1.right.right = new TreeNode(7);\n\nconsole.log(\"Test 1 - Expected: 3, Result:\", maxDepth(testTree1)); // Expected: 3\n",
		"explanation": "This function finds the maximum depth of a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 69,
		"topic": "Same Tree",
		"code": "// Check if two binary trees are the same\nfunction isSameTree(p, q) {\n if (!p && !q) return true;\n if (!p || !q || p.val !== q.val) return false;\n return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n",
		"explanation": "This function checks if two binary trees are the same.",
		"category": "Binary Tree General"
	},
	{
		"id": 70,
		"topic": "Invert Binary Tree",
		"code": "// Invert a binary tree\nfunction invertTree(root) {\n if (!root) return null;\n let left = invertTree(root.left);\n let right = invertTree(root.right);\n root.left = right;\n root.right = left;\n return root;\n}\n",
		"explanation": "This function inverts a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 71,
		"topic": "Symmetric Tree",
		"code": "// Check if a binary tree is symmetric\nfunction isSymmetric(root) {\n if (!root) return true;\n function isMirror(t1, t2) {\n if (!t1 && !t2) return true;\n if (!t1 || !t2 || t1.val !== t2.val) return false;\n return isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\n }\n return isMirror(root.left, root.right);\n}\n",
		"explanation": "This function checks if a binary tree is symmetric.",
		"category": "Binary Tree General"
	},
	{
		"id": 72,
		"topic": "Construct Binary Tree from Preorder and Inorder Traversal",
		"code": "// Construct binary tree from preorder and inorder traversal\nfunction buildTree(preorder, inorder) {\n if (!preorder.length || !inorder.length) return null;\n let root = new TreeNode(preorder[0]);\n let mid = inorder.indexOf(preorder[0]);\n root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n return root;\n}\n",
		"explanation": "This function constructs a binary tree from preorder and inorder traversal.",
		"category": "Binary Tree General"
	},
	{
		"id": 73,
		"topic": "Construct Binary Tree from Inorder and Postorder Traversal",
		"code": "// Construct binary tree from inorder and postorder traversal\nfunction buildTree(inorder, postorder) {\n if (!inorder.length || !postorder.length) return null;\n let root = new TreeNode(postorder.pop());\n let mid = inorder.indexOf(root.val);\n root.right = buildTree(inorder.slice(mid + 1), postorder);\n root.left = buildTree(inorder.slice(0, mid), postorder);\n return root;\n}\n",
		"explanation": "This function constructs a binary tree from inorder and postorder traversal.",
		"category": "Binary Tree General"
	},
	{
		"id": 74,
		"topic": "Populating Next Right Pointers in Each Node II",
		"code": "// Populate next right pointers in each node\nfunction connect(root) {\n if (!root) return null;\n let queue = [root];\n while (queue.length) {\n let size = queue.length;\n for (let i = 0; i < size; i++) {\n let node = queue.shift();\n if (i < size - 1) node.next = queue[0];\n if (node.left) queue.push(node.left);\n if (node.right) queue.push(node.right);\n }\n }\n return root;\n}\n",
		"explanation": "This function populates each next pointer to point to its next right node.",
		"category": "Binary Tree General"
	},
	{
		"id": 75,
		"topic": "Flatten Binary Tree to Linked List",
		"code": "// Flatten binary tree to linked list\nfunction flatten(root) {\n if (!root) return;\n flatten(root.left);\n flatten(root.right);\n let left = root.left;\n let right = root.right;\n root.left = null;\n root.right = left;\n let current = root;\n while (current.right) current = current.right;\n current.right = right;\n}\n",
		"explanation": "This function flattens a binary tree to a linked list in-place.",
		"category": "Binary Tree General"
	},
	{
		"id": 76,
		"topic": "Path Sum",
		"code": "// Find if there is a root-to-leaf path with a given sum\nfunction hasPathSum(root, sum) {\n if (!root) return false;\n if (!root.left && !root.right) return root.val === sum;\n return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n}\n",
		"explanation": "This function checks if there is a root-to-leaf path with a given sum.",
		"category": "Binary Tree General"
	},
	{
		"id": 77,
		"topic": "Sum Root to Leaf Numbers",
		"code": "// Find the sum of all root-to-leaf numbers\nfunction sumNumbers(root) {\n function dfs(node, currentSum) {\n if (!node) return 0;\n currentSum = currentSum * 10 + node.val;\n if (!node.left && !node.right) return currentSum;\n return dfs(node.left, currentSum) + dfs(node.right, currentSum);\n }\n return dfs(root, 0);\n}\n",
		"explanation": "This function finds the sum of all root-to-leaf numbers.",
		"category": "Binary Tree General"
	},
	{
		"id": 78,
		"topic": "Binary Tree Maximum Path Sum",
		"code": "// Find the maximum path sum in a binary tree\nfunction maxPathSum(root) {\n let maxSum = -Infinity;\n function dfs(node) {\n if (!node) return 0;\n let left = Math.max(dfs(node.left), 0);\n let right = Math.max(dfs(node.right), 0);\n let newPathSum = node.val + left + right;\n maxSum = Math.max(maxSum, newPathSum);\n return node.val + Math.max(left, right);\n }\n dfs(root);\n return maxSum;\n}\n",
		"explanation": "This function finds the maximum path sum in a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 79,
		"topic": "Binary Search Tree Iterator",
		"code": "// Implement a binary search tree iterator\nclass BSTIterator {\n constructor(root) {\n this.stack = [];\n this.pushAll(root);\n }\n next() {\n let node = this.stack.pop();\n this.pushAll(node.right);\n return node.val;\n }\n hasNext() {\n return this.stack.length > 0;\n }\n pushAll(node) {\n while (node) {\n this.stack.push(node);\n node = node.left;\n }\n }\n}\n",
		"explanation": "This class implements a binary search tree iterator with next and hasNext methods.",
		"category": "Binary Tree General"
	},
	{
		"id": 80,
		"topic": "Count Complete Tree Nodes",
		"code": "// Count the number of nodes in a complete binary tree\nfunction countNodes(root) {\n if (!root) return 0;\n let leftDepth = getDepth(root.left);\n let rightDepth = getDepth(root.right);\n if (leftDepth === rightDepth) {\n return (1 << leftDepth) + countNodes(root.right);\n } else {\n return (1 << rightDepth) + countNodes(root.left);\n }\n}\nfunction getDepth(node) {\n let depth = 0;\n while (node) {\n depth++;\n node = node.left;\n }\n return depth;\n}\n",
		"explanation": "This function counts the number of nodes in a complete binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 81,
		"topic": "Lowest Common Ancestor of a Binary Tree",
		"code": "// Find the lowest common ancestor of two nodes in a binary tree\nfunction lowestCommonAncestor(root, p, q) {\n if (!root || root === p || root === q) return root;\n let left = lowestCommonAncestor(root.left, p, q);\n let right = lowestCommonAncestor(root.right, p, q);\n if (left && right) return root;\n return left ? left : right;\n}\n",
		"explanation": "This function finds the lowest common ancestor of two nodes in a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 82,
		"topic": "Binary Tree Right Side View",
		"code": "// Find the right side view of a binary tree\nvar rightSideView = function(root) {\n // Return empty array if the tree is empty\n if (!root) return [];\n \n // Initialize queue for BFS and result array for the right-side view\n let queue = [root];\n let result = [];\n\n // Perform level-order traversal using BFS\n while (queue.length > 0) {\n let levelSize = queue.length; // Number of nodes at the current level\n \n for (let i = 0; i < levelSize; i++) {\n let currentNode = queue.shift(); // Dequeue the front node\n \n // If it's the last node in this level, add its value to the result\n if (i === levelSize - 1) {\n result.push(currentNode.val);\n }\n \n // Enqueue left and right children (if they exist)\n if (currentNode.left) queue.push(currentNode.left);\n if (currentNode.right) queue.push(currentNode.right);\n }\n }\n\n return result;\n};\n",
		"explanation": "Explanation:<br/> 1. Edge Case:<br/>    - If the root is null, return an empty array [].<br/> <br/> 2. BFS Traversal:<br/>    - Use a queue to perform a level-order traversal.<br/>    - For each level, iterate through all nodes.<br/>    - Keep track of the last node's value at each level and add it to the result array.<br/> <br/> 3. Enqueue Children:<br/>    - After processing a node, enqueue its left and right children (if they exist)<br/>      for processing in the next level.",
		"category": "Binary Tree BFS"
	},
	{
		"id": 83,
		"topic": "Average of Levels in Binary Tree",
		"code": "// Find the average of levels in a binary tree\nfunction averageOfLevels(root) {\n let result = [], queue = [root];\n while (queue.length) {\n let sum = 0, count = 0, nextQueue = [];\n for (let node of queue) {\n sum += node.val;\n count++;\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(sum / count);\n queue = nextQueue;\n }\n return result;\n}\n",
		"explanation": "This function finds the average of levels in a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"id": 84,
		"topic": "Binary Tree Level Order Traversal",
		"code": "// Perform level order traversal of a binary tree\nfunction levelOrder(root) {\n let result = [], queue = [root];\n while (queue.length) {\n let level = [], nextQueue = [];\n for (let node of queue) {\n level.push(node.val);\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(level);\n queue = nextQueue;\n }\n return result;\n}\n",
		"explanation": "This function performs level order traversal of a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"id": 85,
		"topic": "Binary Tree Zigzag Level Order Traversal",
		"code": "// Perform zigzag level order traversal of a binary tree\nfunction zigzagLevelOrder(root) {\n let result = [], queue = [root], leftToRight = true;\n while (queue.length) {\n let level = [], nextQueue = [];\n for (let node of queue) {\n if (leftToRight) level.push(node.val);\n else level.unshift(node.val);\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(level);\n queue = nextQueue;\n leftToRight = !leftToRight;\n }\n return result;\n}\n",
		"explanation": "This function performs zigzag level order traversal of a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"id": 86,
		"topic": "Minimum Absolute Difference in BST",
		"code": "// Find the minimum absolute difference in a BST\nvar getMinimumDifference = function (root) {\n let prev = null; // Tracks the previous value in the in-order traversal\n let minDiff = Infinity; // Initialize the minimum difference to a very large number\n\n // Helper function for in-order traversal\n const inOrderTraversal = (node) => {\n if (!node) return;\n\n // Traverse the left subtree\n inOrderTraversal(node.left);\n\n // Process the current node\n if (prev !== null) {\n // Update the minimum difference\n minDiff = Math.min(minDiff, Math.abs(node.val - prev));\n }\n // Update the previous value to the current node's value\n prev = node.val;\n\n // Traverse the right subtree\n inOrderTraversal(node.right);\n };\n\n // Perform in-order traversal starting from the root\n inOrderTraversal(root);\n\n return minDiff;\n};\n",
		"explanation": "Explanation:\n\n1. In-order Traversal:\nThe recursive function `inOrderTraversal` processes nodes in ascending order for a BST.\n\n2. `prev` Variable:\nKeeps track of the previously visited node's value during traversal.\n\n3. Minimum Difference Calculation:\nAt each node, the absolute difference between the current node's value and `prev` is calculated.\nThe `minDiff` is updated if the new difference is smaller.\n\n4. Return Value:\nAfter the traversal, `minDiff` contains the smallest absolute difference between any two nodes.\n\nComplexity Analysis:\n- Time Complexity: O(n), where `n` is the number of nodes. Each node is visited once.\n- Space Complexity: O(h), where `h` is the height of the BST. This accounts for the recursion stack.",
		"category": "Binary Search Tree"
	},
	{
		"id": 87,
		"topic": "Kth Smallest Element in a BST",
		"code": "// Find the kth smallest element in a BST\nvar kthSmallest = function(root, k) {\n console.log(\"root\", root);\n console.log(\"k\", k);\n let count = 0; // Keeps track of how many nodes we've visited during the in-order traversal.\n let result = null; // Stores the kth smallest element when found.\n\n // Helper function to perform in-order traversal of the BST.\n function inorder(node) {\n if (node === null) return; // Base case: if the node is null, just return.\n\n // 1. Traverse the left subtree first, as it contains smaller values.\n inorder(node.left); // Example: for node with value 3, it will first visit the left child (node with value 1).\n // If node is 3, the left child is 1, and the traversal will move to 1 first.\n\n // 2. Visit the current node.\n count++; // Increment count because we've visited a new node.\n if (count === k) {\n result = node.val; // If count equals k, we’ve found the kth smallest value.\n return; // Stop the traversal since we found the result.\n }\n // Example: After visiting node 1 (left child), count becomes 1, then it moves back to 3.\n\n // 3. Traverse the right subtree after visiting the node.\n inorder(node.right); // After visiting node 3, it will move to its right child (node with value 4).\n // Example: Node 3 visits right child 4 after visiting itself.\n }\n\n inorder(root); // Start in-order traversal from the root of the tree.\n return result; // Return the kth smallest element found during the traversal.\n};\n\n// Example usage:\n// console.log(kthSmallest([3,1,4,null,2], 1)); // Output: 1\n// console.log(kthSmallest([5,3,6,2,4,null,null,1], 3)); // Output: 3\n",
		"explanation": "1. In-order Traversal:<br/> - In-order traversal visits nodes in ascending order in a binary search tree (BST). The order of traversal is:<br/> 1) Traverse the left subtree.<br/> - Example: For the tree [3,1,4,null,2], first it traverses left subtree, visiting node 1.<br/> 2) Visit the current node.<br/> - Example: After node 1, the current node is 3. We count 3 and move to the next.<br/> 3) Then traverse the right subtree.<br/> - Example: After visiting node 3, it moves to the right child, which is node 4.<br/> - This order guarantees that if we visit nodes one by one, we’ll visit the smallest node first, the second smallest next, and so on.<br/> - For example, in the tree `root = [3,1,4,null,2]`, the in-order traversal visits nodes in this order: `[1, 2, 3, 4]`. Therefore, the 1st smallest element is 1, and the 3rd smallest element is 3.<br/><br/>2. Recursive Approach:<br/> - The `inorder` function is defined to traverse the tree recursively. This means we will explore the left child, visit the node, and then explore the right child, following a depth-first traversal.<br/> - We maintain a `count` variable to track how many nodes we've visited so far. When `count` reaches `k`, we've found the kth smallest element, and we store its value in `result`.<br/> - The traversal stops early once we find the kth smallest element, which helps to save time by avoiding unnecessary exploration of the tree.<br/><br/>3. Time Complexity:<br/> - O(n), where `n` is the number of nodes in the tree. In the worst case, we may need to traverse all nodes in the tree, especially if `k` is large or if the kth smallest element is near the last visited node.<br/><br/>4. Space Complexity:<br/> - O(h), where `h` is the height of the tree. This represents the space needed for the recursive call stack. In the worst case (e.g., for a skewed tree), the height `h` can be equal to `n` (i.e., O(n)).",
		"category": "Binary Search Tree"
	},
	{
		"id": 88,
		"topic": "Validate Binary Search Tree",
		"code": "// Validate if a tree is a binary search tree\nfunction isValidBST(root) {\n function validate(node, low = -Infinity, high = Infinity) {\n if (!node) return true;\n if (node.val <= low || node.val >= high) return false;\n return validate(node.left, low, node.val) && validate(node.right, node.val, high);\n }\n return validate(root);\n}\n",
		"explanation": "This function validates if a tree is a binary search tree.",
		"category": "Binary Search Tree"
	},
	{
		"id": 89,
		"topic": "Number of Islands",
		"code": "// Find the number of islands\nvar numIslands = function(grid) {\n // Helper function to mark all connected land cells of an island\n function markIsland(i, j) {\n // Base case: if the cell is out of bounds or water, return\n if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') {\n return;\n }\n\n // Mark the current cell as visited by setting it to '0'\n grid[i][j] = '0';\n\n // Recursively visit the neighboring cells (up, down, left, right)\n console.log(`Visiting cell: (${i}, ${j})`);\n markIsland(i - 1, j); // up\n markIsland(i + 1, j); // down\n markIsland(i, j - 1); // left\n markIsland(i, j + 1); // right\n }\n\n let islandCount = 0;\n\n // Loop through the entire grid\n for (let i = 0; i < grid.length; i++) {\n for (let j = 0; j < grid[0].length; j++) {\n // If we find a land cell ('1'), we have found a new island\n if (grid[i][j] === '1') {\n console.log(`Found a new island at: (${i}, ${j})`);\n islandCount++;\n // Start exploring the island and mark all connected land cells as visited\n markIsland(i, j);\n }\n }\n }\n\n return islandCount;\n};\n\n// Test example 1\nconst grid1 = [\n [\"1\",\"1\",\"1\",\"1\",\"0\"],\n [\"1\",\"1\",\"0\",\"1\",\"0\"],\n [\"1\",\"1\",\"0\",\"0\",\"0\"],\n [\"0\",\"0\",\"0\",\"0\",\"0\"]\n];\nconsole.log(\"Number of Islands (Test 1):\", numIslands(grid1));\n\n// Test example 2\nconst grid2 = [\n [\"1\",\"1\",\"0\",\"0\",\"0\"],\n [\"1\",\"1\",\"0\",\"0\",\"0\"],\n [\"0\",\"0\",\"1\",\"0\",\"0\"],\n [\"0\",\"0\",\"0\",\"1\",\"1\"]\n];\nconsole.log(\"Number of Islands (Test 2):\", numIslands(grid2));\n",
		"explanation": "Explanation:<br/><br/>1. `numIslands` Function:<br/>   - This function takes a 2D grid (a map of land '1' and water '0') as input and returns the total number of islands in the grid.<br/><br/>2. Grid Exploration:<br/>   - We iterate through each cell of the grid.<br/>   - When a '1' (land) is found, we have encountered a new island and increment the `islandCount`.<br/>   - The `markIsland` helper function is then called to explore all connected land cells (i.e., to \"mark\" the entire island as visited).<br/><br/>3. Depth-First Search (DFS) - `markIsland`:<br/>   - This function performs a Depth-First Search (DFS) to explore the entire island.<br/>   - It works by recursively marking all adjacent land cells (up, down, left, right) as visited by setting them to '0' (water).<br/>   - The recursion ensures that all cells belonging to the same island are visited and marked.<br/><br/>4. Termination of Depth-First Search (DFS):<br/>   - The Depth-First Search (DFS) terminates if a cell is out of bounds or if it is water ('0').<br/><br/>5. Example 1 (grid1):<br/>   - In the first test case, the grid represents a single island, so the function will find one island.<br/>   - The DFS will visit all connected '1's and mark them as '0'.<br/>   - The output will be `1`.<br/><br/>6. Example 2 (grid2):<br/>   - In the second test case, the grid contains three separate islands.<br/>   - The function will detect and count all three islands individually.<br/>   - The output will be `3`.<br/><br/>7. **Log Statements:**<br/>   - **`console.log('Visiting cell:')`** shows each cell visited during the DFS traversal.<br/>   - **`console.log('Found a new island at:')`** indicates the starting point of a new island being discovered.<br/><br/>Output Example:<br/>Found a new island at: (0, 0)<br/>Visiting cell: (0, 0)<br/>Visiting cell: (1, 0)<br/>Visiting cell: (2, 0)<br/>Visiting cell: (2, 1)<br/>Visiting cell: (1, 1)<br/>Visiting cell: (0, 1)<br/>Visiting cell: (0, 2)<br/>Visiting cell: (1, 2)<br/>Number of Islands (Test 1): 1<br/><br/>Found a new island at: (0, 0)<br/>Visiting cell: (0, 0)<br/>Visiting cell: (1, 0)<br/>Visiting cell: (2, 0)<br/>Visiting cell: (2, 1)<br/>Visiting cell: (1, 1)<br/>Visiting cell: (0, 1)<br/>Visiting cell: (0, 2)<br/>Visiting cell: (1, 2)<br/>Found a new island at: (2, 2)<br/>Visiting cell: (2, 2)<br/>Visiting cell: (3, 2)<br/>Visiting cell: (3, 3)<br/>Found a new island at: (3, 3)<br/>Visiting cell: (3, 3)<br/>Number of Islands (Test 2): 3",
		"category": "Graph General"
	},
	{
		"id": 90,
		"topic": "Surrounded Regions",
		"code": "// Capture all regions surrounded by 'X'\nfunction solve(board) {\n if (!board.length) return;\n let m = board.length, n = board[0].length;\n function dfs(i, j) {\n if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] !== 'O') return;\n board[i][j] = 'T';\n dfs(i + 1, j);\n dfs(i - 1, j);\n dfs(i, j + 1);\n dfs(i, j - 1);\n }\n for (let i = 0; i < m; i++) {\n if (board[i][0] === 'O') dfs(i, 0);\n if (board[i][n - 1] === 'O') dfs(i, n - 1);\n }\n for (let j = 0; j < n; j++) {\n if (board[0][j] === 'O') dfs(0, j);\n if (board[m - 1][j] === 'O') dfs(m - 1, j);\n }\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n if (board[i][j] === 'O') board[i][j] = 'X';\n if (board[i][j] === 'T') board[i][j] = 'O';\n }\n }\n}\n",
		"explanation": "This function captures all regions surrounded by 'X' in a board.",
		"category": "Graph General"
	},
	{
		"id": 91,
		"topic": "Clone Graph",
		"code": "// Clone a graph\nfunction cloneGraph(node) {\n if (!node) return null;\n let map = new Map();\n function clone(node) {\n if (!map.has(node)) {\n map.set(node, new Node(node.val));\n map.get(node).neighbors = node.neighbors.map(clone);\n }\n return map.get(node);\n }\n return clone(node);\n}\n",
		"explanation": "This function clones a graph using DFS.",
		"category": "Graph General"
	},
	{
		"id": 92,
		"topic": "Evaluate Division",
		"code": "// Evaluate division\nfunction calcEquation(equations, values, queries) {\n let graph = new Map();\n function buildGraph(equations, values) {\n for (let i = 0; i < equations.length; i++) {\n let [a, b] = equations[i];\n if (!graph.has(a)) graph.set(a, new Map());\n if (!graph.has(b)) graph.set(b, new Map());\n graph.get(a).set(b, values[i]);\n graph.get(b).set(a, 1 / values[i]);\n }\n }\n function dfs(start, end, visited) {\n if (!graph.has(start) || !graph.has(end)) return -1;\n if (start === end) return 1;\n visited.add(start);\n for (let [neighbor, value] of graph.get(start)) {\n if (!visited.has(neighbor)) {\n let product = dfs(neighbor, end, visited);\n if (product !== -1) return product * value;\n }\n }\n return -1;\n }\n buildGraph(equations, values);\n let results = [];\n for (let [a, b] of queries) {\n results.push(dfs(a, b, new Set()));\n }\n return results;\n}\n",
		"explanation": "This function evaluates division using a graph and DFS.",
		"category": "Graph General"
	},
	{
		"id": 93,
		"topic": "Course Schedule",
		"code": "// Determine if you can finish all courses\nfunction canFinish(numCourses, prerequisites) {\n let graph = new Map();\n let indegree = Array(numCourses).fill(0);\n for (let [course, prereq] of prerequisites) {\n if (!graph.has(prereq)) graph.set(prereq, []);\n graph.get(prereq).push(course);\n indegree[course]++;\n }\n let queue = [];\n for (let i = 0; i < numCourses; i++) {\n if (indegree[i] === 0) queue.push(i);\n }\n let count = 0;\n while (queue.length) {\n let course = queue.shift();\n count++;\n if (graph.has(course)) {\n for (let nextCourse of graph.get(course)) {\n indegree[nextCourse]--;\n if (indegree[nextCourse] === 0) queue.push(nextCourse);\n }\n }\n }\n return count === numCourses;\n}\n",
		"explanation": "This function determines if you can finish all courses given the prerequisites.",
		"category": "Graph General"
	},
	{
		"id": 94,
		"topic": "Course Schedule II",
		"code": "// Find the order of courses to finish all courses\nfunction findOrder(numCourses, prerequisites) {\n let graph = new Map();\n let indegree = Array(numCourses).fill(0);\n for (let [course, prereq] of prerequisites) {\n if (!graph.has(prereq)) graph.set(prereq, []);\n graph.get(prereq).push(course);\n indegree[course]++;\n }\n let queue = [];\n for (let i = 0; i < numCourses; i++) {\n if (indegree[i] === 0) queue.push(i);\n }\n let order = [];\n while (queue.length) {\n let course = queue.shift();\n order.push(course);\n if (graph.has(course)) {\n for (let nextCourse of graph.get(course)) {\n indegree[nextCourse]--;\n if (indegree[nextCourse] === 0) queue.push(nextCourse);\n }\n }\n }\n return order.length === numCourses ? order : [];\n}\n",
		"explanation": "This function finds the order of courses to finish all courses given the prerequisites.",
		"category": "Graph General"
	},
	{
		"id": 95,
		"topic": "Snakes and Ladders",
		"code": "// Find the minimum number of moves to reach the last square\nvar snakesAndLadders = function(board) {\n console.log('Original board:', board);\n const boardSize = board.length; // The size of the board (n x n)\n const totalSquares = boardSize * boardSize; // The total number of squares on the board (n^2)\n\n // Flatten the 2D board into a 1D array representing the board\n // We iterate over each row and alternate the direction for odd rows\n let flattenedBoard = new Array(totalSquares).fill(-1); // 0-based array\n let index = 0;\n\n console.log('Flattening the board...');\n\n // Traverse each row from bottom to top\n for (let row = boardSize - 1; row >= 0; row--) {\n if (row % 2 === boardSize % 2) { // Right to left direction for odd rows\n for (let col = boardSize - 1; col >= 0; col--) {\n flattenedBoard[index++] = board[row][col];\n }\n } else { // Left to right direction for even rows\n for (let col = 0; col < boardSize; col++) {\n flattenedBoard[index++] = board[row][col];\n }\n }\n }\n\n // 0-based array\n console.log('Flattened Board (0-based array):', flattenedBoard);\n \n // BFS (Breadth-First Search) setup to find the shortest path to the last square\n let queue = [[0, 0]]; // Start from square 1 (index 0)\n let visitedSquares = new Array(totalSquares).fill(false); // Array to keep track of visited squares\n visitedSquares[0] = true; // Mark the first square as visited\n\n console.log('Starting BFS to find the shortest path to the last square...');\n\n while (queue.length > 0) {\n // Remove the first element from the queue and get the current square and dice rolls\n let [currentSquare, diceRolls] = queue.shift();\n \n // Inside the BFS loop, where you're processing squares:\n console.log(`Landed on square ${currentSquare + 1} (Index: ${currentSquare}), Dice rolls: ${diceRolls}`);\n\n \n // If we've reached the last square (n^2 - 1), return the number of dice rolls\n if (currentSquare === totalSquares - 1) {\n console.log(`Reached the last square! Total dice rolls: ${diceRolls}`);\n return diceRolls;\n }\n \n // Try all dice rolls from 1 to 6\n for (let dice = 1; dice <= 6; dice++) {\n let nextSquare = currentSquare + dice; // Calculate the next square based on the dice roll\n \n // Prevent going out of bounds of the board\n if (nextSquare >= totalSquares) break;\n \n // Check if there's a snake or ladder at the next square\n if (flattenedBoard[nextSquare] !== -1) {\n // A snake or ladder sends the player directly to the destination square\n nextSquare = flattenedBoard[nextSquare] - 1; // Adjust because the destination is 1-based\n console.log(\"nextSquare set\", nextSquare + 1);\n // convert from 0-based indexing to 1-based indexing\n // console.log(`Landed on a snake/ladder, moving from square ${currentSquare + 1} to ${nextSquare + 1}`);\n } else {\n // No snake or ladder, move normally\n // convert from 0-based indexing to 1-based indexing\n // console.log(`Moving from square ${currentSquare + 1} to square ${nextSquare + 1}`);\n }\n \n // If the next square hasn't been visited, mark it and add it to the queue\n if (!visitedSquares[nextSquare]) {\n visitedSquares[nextSquare] = true;\n queue.push([nextSquare, diceRolls + 1]);\n console.log(`Adding square ${nextSquare + 1} to the queue with ${diceRolls + 1} dice rolls.`);\n }\n }\n }\n \n // If we can't reach the last square, return -1\n console.log('Unable to reach the last square. Returning -1.');\n return -1;\n};\n\n// Example board for testing\nboard = [\n [-1,-1,-1,-1,-1,-1],\n [-1,-1,-1,-1,-1,-1],\n [-1,-1,-1,-1,-1,-1],\n [-1,35,-1,-1,13,-1],\n [-1,-1,-1,-1,-1,-1],\n [-1,15,-1,-1,-1,-1]\n]\n// Test the function with example board A\nconsole.log('A Minimum number of dice rolls:', snakesAndLadders(board));\nconsole.log('-----');\n\n// Test the function with example board B\n// boardB = [\n// [-1,-1],\n// [-1,3]\n// ]\n\n// console.log('B Minimum number of dice rolls:', snakesAndLadders(boardB));\n",
		"explanation": "The problem asks to find the minimum number of dice rolls required to reach the last square on a snakes-and-ladders board, starting from the first square. The board is represented as a 2D array, where each element can either be:<br/>- -1, indicating an empty square.<br/>- A positive number, which indicates a ladder that takes you directly to the square at that position.<br/>- A negative number, representing a snake, which takes you to a square with the corresponding number.<br/><br/>We can treat the board as an unweighted graph, where each square is a node, and the dice rolls define possible edges to neighboring nodes. The objective is to find the shortest path from the first square to the last square.<br/><br/>1. Flattening the Board (2D to 1D transformation):<br/>   - The input board is a 2D array, but to simplify our logic (since BFS typically works with a 1D array for easier indexing), we convert the 2D board into a 1D array.<br/>   - The board is traversed in a \"Boustrophedon\" style, which means:<br/>     - For odd-indexed rows (from the bottom), we traverse from right to left.<br/>     - For even-indexed rows (from the bottom), we traverse from left to right.<br/>   - This transformation makes it easier to handle the board's unique structure and helps us index the board using a simple 1D array.<br/>   - The flattened array will have a length of `n^2` (where `n` is the side length of the square grid).<br/><br/>2. Breadth-First Search (BFS) for the Shortest Path:<br/>   - BFS is chosen because it efficiently finds the shortest path in an unweighted graph.<br/>   - We use a queue to explore the board level by level (i.e., dice roll by dice roll). Each element in the queue represents a square on the board, along with the number of dice rolls taken to reach that square.<br/>   - Starting from the first square (index 0), we try all possible dice rolls (1 through 6) to explore the next squares. For each dice roll, we calculate the destination square and check if it’s a snake or ladder.<br/>     - If it’s a ladder or snake, we adjust the destination to the corresponding square.<br/>     - If not, we simply move to the square resulting from the dice roll.<br/><br/>3. Tracking Visited Squares:<br/>   - To avoid revisiting squares and causing infinite loops, we maintain an array `visitedSquares` where each index corresponds to a square on the board. If a square has been visited before, it is skipped in future dice rolls.<br/>   - This ensures that the BFS doesn’t waste time exploring already visited squares and guarantees that the shortest path is found.<br/><br/>4. Termination Condition:<br/>   - The BFS continues until the queue is empty or we reach the last square (`n^2 - 1`).<br/>   - If we reach the last square, we return the number of dice rolls taken to get there, as that represents the shortest path.<br/>   - If the BFS completes without reaching the last square (i.e., the queue is exhausted), we return `-1`, indicating that it's impossible to reach the last square (which should never happen with a valid board setup).<br/><br/>Time Complexity:<br/>   - The time complexity of this solution is O(n^2), where `n` is the side length of the square grid.<br/>   - BFS processes each square at most once, and for each square, we attempt to move in 6 possible directions (1 through 6 dice rolls).<br/>   - Since the number of squares is `n^2`, the total number of operations is proportional to `n^2`, making this approach efficient for typical board sizes.<br/><br/>In summary, we flatten the board to simplify movement logic, apply BFS to explore the shortest path using dice rolls, and track visited squares to ensure we don’t process a square more than once. The BFS guarantees that we find the minimum number of rolls required to reach the last square.",
		"category": "Graph BFS"
	},
	{
		"id": 96,
		"topic": "Minimum Genetic Mutation",
		"code": "// Find the minimum number of mutations to reach the end gene\nfunction minMutation(start, end, bank) {\n let bankSet = new Set(bank);\n if (!bankSet.has(end)) return -1;\n let queue = [[start, 0]];\n let visited = new Set([start]);\n let chars = ['A', 'C', 'G', 'T'];\n while (queue.length) {\n let [gene, mutations] = queue.shift();\n if (gene === end) return mutations;\n for (let i = 0; i < gene.length; i++) {\n for (let char of chars) {\n let newGene = gene.slice(0, i) + char + gene.slice(i + 1);\n if (bankSet.has(newGene) && !visited.has(newGene)) {\n visited.add(newGene);\n queue.push([newGene, mutations + 1]);\n }\n }\n }\n }\n return -1;\n}\n",
		"explanation": "This function finds the minimum number of mutations needed to reach the end gene from the start gene.",
		"category": "Graph BFS"
	},
	{
		"id": 97,
		"topic": "Word Ladder",
		"code": "// Find the length of the shortest transformation sequence from beginWord to endWord\nfunction ladderLength(beginWord, endWord, wordList) {\n let wordSet = new Set(wordList);\n if (!wordSet.has(endWord)) return 0;\n let queue = [[beginWord, 1]];\n while (queue.length) {\n let [word, length] = queue.shift();\n if (word === endWord) return length;\n for (let i = 0; i < word.length; i++) {\n for (let char of 'abcdefghijklmnopqrstuvwxyz') {\n let newWord = word.slice(0, i) + char + word.slice(i + 1);\n if (wordSet.has(newWord)) {\n wordSet.delete(newWord);\n queue.push([newWord, length + 1]);\n }\n }\n }\n }\n return 0;\n}\n",
		"explanation": "This function finds the length of the shortest transformation sequence from beginWord to endWord.",
		"category": "Graph BFS"
	},
	{
		"id": 98,
		"topic": "Implement Trie (Prefix Tree)",
		"code": "// Implement a Trie (Prefix Tree)\nclass Trie {\n constructor() {\n this.children = {};\n this.isEndOfWord = false;\n }\n insert(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) node.children[char] = new Trie();\n node = node.children[char];\n }\n node.isEndOfWord = true;\n }\n search(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) return false;\n node = node.children[char];\n }\n return node.isEndOfWord;\n }\n startsWith(prefix) {\n let node = this;\n for (let char of prefix) {\n if (!node.children[char]) return false;\n node = node.children[char];\n }\n return true;\n }\n}\n",
		"explanation": "This class implements a Trie (Prefix Tree) with insert, search, and startsWith methods.",
		"category": "Trie"
	},
	{
		"id": 99,
		"topic": "Design Add and Search Words Data Structure",
		"code": "// Design a data structure that supports adding and searching words\nclass WordDictionary {\n constructor() {\n this.children = {};\n this.isEndOfWord = false;\n }\n addWord(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) node.children[char] = new WordDictionary();\n node = node.children[char];\n }\n node.isEndOfWord = true;\n }\n search(word) {\n function dfs(node, i) {\n if (i === word.length) return node.isEndOfWord;\n if (word[i] === '.') {\n for (let child in node.children) {\n if (dfs(node.children[child], i + 1)) return true;\n }\n return false;\n }\n if (!node.children[word[i]]) return false;\n return dfs(node.children[word[i]], i + 1);\n }\n return dfs(this, 0);\n }\n}\n",
		"explanation": "This class implements a data structure that supports adding and searching words with '.' as a wildcard character.",
		"category": "Trie"
	},
	{
		"id": 100,
		"topic": "Word Search II",
		"code": "// Find all words in the board\nfunction findWords(board, words) {\n let result = [];\n let trie = new Trie();\n for (let word of words) trie.insert(word);\n function dfs(node, i, j, path) {\n if (node.isEndOfWord) {\n result.push(path);\n node.isEndOfWord = false;\n }\n if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || !node.children[board[i][j]]) return;\n let char = board[i][j];\n board[i][j] = '#';\n for (let [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {\n dfs(node.children[char], i + dx, j + dy, path + char);\n }\n board[i][j] = char;\n }\n for (let i = 0; i < board.length; i++) {\n for (let j = 0; j < board[0].length; j++) {\n if (trie.children[board[i][j]]) dfs(trie, i, j, '');\n }\n }\n return result;\n}\n",
		"explanation": "This function finds all words in the board using a Trie and DFS.",
		"category": "Trie"
	},
	{
		"id": 101,
		"topic": "Letter Combinations of a Phone Number",
		"code": "// Find all letter combinations of a phone number\nvar letterCombinations = function(digits) {\n // Map of digit to corresponding letters, similar to a phone keypad\n const digitToLetters = {\n \"2\": \"abc\",\n \"3\": \"def\",\n \"4\": \"ghi\",\n \"5\": \"jkl\",\n \"6\": \"mno\",\n \"7\": \"pqrs\",\n \"8\": \"tuv\",\n \"9\": \"wxyz\"\n };\n \n // Result array to store all possible letter combinations\n const result = [];\n \n // Base case: If the input digits are empty, return an empty array\n if (digits.length === 0) {\n return result;\n }\n \n const backtrack = (index, currentCombination) => {\n // If the current combination length equals the number of digits, add it to the result\n if (index === digits.length) {\n result.push(currentCombination); // Valid combination completed\n return;\n }\n \n // Get the letters corresponding to the current digit\n const letters = digitToLetters[digits[index]];\n \n // Loop through each letter for the current digit\n for (const letter of letters) {\n // Add the letter to the current combination and move to the next digit\n backtrack(index + 1, currentCombination + letter);\n }\n };\n \n // Start the backtracking process with index 0 and an empty combination\n backtrack(0, \"\");\n \n // Return the final list of all combinations\n return result;\n};\n\n// Example usage:\nconst inputDigits = \"23\";\nconsole.log(letterCombinations(inputDigits)); \n// Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n",
		"explanation": "1. `digitToLetters`: Maps digits (2-9) to their corresponding letters. This allows quick lookup for any digit.<br/>2. `result`: Stores all valid letter combinations.<br/>3. Base Case: If the `digits` string is empty, no combinations can be formed, so return an empty array.<br/>4. `backtrack` function:<br/>   - Tracks progress using `index` (current digit position) and `currentCombination` (letters formed so far).<br/>   - Recursion explores all possible paths:<br/>     a. Add a letter to the current combination.<br/>     b. Move to the next digit using `index + 1`.<br/>     c. Stop recursion and add the combination to `result` once all digits are processed.<br/>5. Backtracking starts at index 0 with an empty string.<br/>6. Time Complexity: O(3^n * 4^m), where n is digits mapping to 3 letters (e.g., 2-6, 8), and m maps to 4 letters (e.g., 7, 9).<br/>7. Space Complexity: O(n), due to the recursion stack depth equal to the number of digits.",
		"category": "Backtracking"
	},
	{
		"id": 102,
		"topic": "Combinations",
		"code": "// Find all combinations of k numbers out of 1 to n\nfunction combine(n, k) {\n let result = [];\n function backtrack(start, path) {\n if (path.length === k) {\n result.push([...path]);\n return;\n }\n for (let i = start; i <= n; i++) {\n path.push(i);\n backtrack(i + 1, path);\n path.pop();\n }\n }\n backtrack(1, []);\n return result;\n}\n",
		"explanation": "This function finds all combinations of k numbers out of 1 to n.",
		"category": "Backtracking"
	},
	{
		"id": 103,
		"topic": "Permutations",
		"code": "// Generate all permutations of an array of numbers\nfunction permute(nums) {\n let result = [];\n function backtrack(path = [], used = Array(nums.length).fill(false)) {\n if (path.length === nums.length) {\n result.push([...path]);\n return;\n }\n for (let i = 0; i < nums.length; i++) {\n if (used[i]) continue;\n used[i] = true;\n path.push(nums[i]);\n backtrack(path, used);\n path.pop();\n used[i] = false;\n }\n }\n backtrack();\n return result;\n}\n",
		"explanation": "This function generates all possible permutations of an array using backtracking.",
		"category": "Backtracking"
	},
	{
		"id": 104,
		"topic": "Combination Sum",
		"code": "// Find all unique combinations that sum up to the target\nfunction combinationSum(candidates, target) {\n let result = [];\n function backtrack(start = 0, path = [], remaining = target) {\n if (remaining === 0) {\n result.push([...path]);\n return;\n }\n for (let i = start; i < candidates.length; i++) {\n if (remaining < candidates[i]) continue;\n path.push(candidates[i]);\n backtrack(i, path, remaining - candidates[i]);\n path.pop();\n }\n }\n backtrack();\n return result;\n}\n",
		"explanation": "This function finds all unique combinations of numbers from the candidates array that sum up to the target.",
		"category": "Backtracking"
	},
	{
		"id": 105,
		"topic": "N-Queens II",
		"code": "// Count all unique solutions to the N-Queens problem\nfunction totalNQueens(n) {\n let count = 0;\n function backtrack(row = 0, cols = new Set(), diags1 = new Set(), diags2 = new Set()) {\n if (row === n) {\n count++;\n return;\n }\n for (let col = 0; col < n; col++) {\n let diag1 = row - col;\n let diag2 = row + col;\n if (cols.has(col) || diags1.has(diag1) || diags2.has(diag2)) continue;\n cols.add(col);\n diags1.add(diag1);\n diags2.add(diag2);\n backtrack(row + 1, cols, diags1, diags2);\n cols.delete(col);\n diags1.delete(diag1);\n diags2.delete(diag2);\n }\n }\n backtrack();\n return count;\n}\n",
		"explanation": "This function counts all distinct solutions to the N-Queens problem using backtracking.",
		"category": "Backtracking"
	},
	{
		"id": 106,
		"topic": "Generate Parentheses",
		"code": "// Generate all combinations of well-formed parentheses\nfunction generateParenthesis(n) {\n let result = [];\n function backtrack(s = '', left = 0, right = 0) {\n if (s.length === 2 * n) {\n result.push(s);\n return;\n }\n if (left < n) backtrack(s + '(', left + 1, right);\n if (right < left) backtrack(s + ')', left, right + 1);\n }\n backtrack();\n return result;\n}\n",
		"explanation": "This function generates all combinations of well-formed parentheses.",
		"category": "Backtracking"
	},
	{
		"id": 107,
		"topic": "Word Search",
		"code": "// Find if a word exists in the board\nfunction exist(board, word) {\n function dfs(i, j, k) {\n if (k === word.length) return true;\n if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] !== word[k]) return false;\n let temp = board[i][j];\n board[i][j] = '#';\n let found = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n board[i][j] = temp;\n return found;\n }\n for (let i = 0; i < board.length; i++) {\n for (let j = 0; j < board[0].length; j++) {\n if (dfs(i, j, 0)) return true;\n }\n }\n return false;\n}\n",
		"explanation": "This function finds if a word exists in the board using DFS.",
		"category": "Backtracking"
	},
	{
		"id": 108,
		"topic": "Convert Sorted Array to Binary Search Tree",
		"code": "// Convert sorted array to binary search tree\nvar sortedArrayToBST = function(nums) {\n // Helper function to recursively build the BST\n const buildBST = (start, end) => {\n if (start > end) {\n return null; // Base case: no elements to process\n }\n // Choose the middle element as the root\n const mid = Math.floor((start + end) / 2);\n const root = new TreeNode(nums[mid]);\n // Recursively build the left and right subtrees\n root.left = buildBST(start, mid - 1);\n root.right = buildBST(mid + 1, end);\n return root;\n };\n // Start the recursion with the entire array range\n return buildBST(0, nums.length - 1);\n};\n\n// Helper function to print the tree in a readable format\nconst printTree = (node) => {\n if (node === null) {\n return \"null\";\n }\n return `(${node.val}, ${printTree(node.left)}, ${printTree(node.right)})`;\n};\n\n// Example\nconst nums = [-10, -3, 0, 5, 9];\nconst bst = sortedArrayToBST(nums);\nconsole.log(\"Generated BST:\", printTree(bst));\n",
		"explanation": "The goal is to convert a sorted array into a height-balanced binary search tree (BST). A height-balanced BST is one where the depth of the two subtrees of every node never differs by more than one.<br/><br/>To achieve this, we recursively choose the middle element of the array (or subarray) as the root, ensuring balance. The left half of the array forms the left subtree, and the right half forms the right subtree. This process continues until all elements are placed in the tree.<br/><br/>1. We define a helper function `buildBST(start, end)` which:<br/> - Returns `null` when `start > end` (base case).<br/> - Chooses the middle element `nums[mid]` as the root.<br/> - Recursively builds the left subtree using elements before the middle and the right subtree using elements after the middle.<br/><br/>2. The function `sortedArrayToBST` starts the recursion with the full array range (`start = 0`, `end = nums.length - 1`).<br/><br/>3. A helper function `printTree(node)` is used to visualize the resulting tree in a readable format.<br/><br/>Time Complexity: O(n), as each element is processed once.<br/>Space Complexity: O(log n), due to recursion stack depth for a balanced tree.<br/><br/>Example - Tree Structure Explanation:<br/>For the input array `[-10, -3, 0, 5, 9]`, the output tree structure is as follows:<br/><br/>      0<br/>     / \\<br/>   -3   9<br/>   /   /<br/> -10   5<br/><br/>- The root node is `0` (middle element).<br/>- The left subtree of `0` is formed from the left half of the array `[-10, -3]`, with `-3` as the root and `-10` as its left child.<br/>- The right subtree of `0` is formed from the right half of the array `[5, 9]`, with `9` as the root and `5` as its left child.",
		"category": "Divide & Conquer"
	},
	{
		"id": 109,
		"topic": "Sort List",
		"code": "// Sort a linked list in O(n log n) time\nfunction sortList(head) {\n if (!head || !head.next) return head;\n let slow = head, fast = head, prev = null;\n while (fast && fast.next) {\n prev = slow;\n slow = slow.next;\n fast = fast.next.next;\n }\n prev.next = null;\n let l1 = sortList(head);\n let l2 = sortList(slow);\n return merge(l1, l2);\n}\nfunction merge(l1, l2) {\n let dummy = new ListNode(0), current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n}\n",
		"explanation": "This function sorts a linked list in O(n log n) time using merge sort.",
		"category": "Divide & Conquer"
	},
	{
		"id": 110,
		"topic": "Construct Quad Tree",
		"code": "// Construct a quad tree\nfunction construct(grid) {\n function build(x, y, length) {\n if (length === 1) return new Node(grid[x][y] === 1, true);\n let half = length / 2;\n let topLeft = build(x, y, half);\n let topRight = build(x, y + half, half);\n let bottomLeft = build(x + half, y, half);\n let bottomRight = build(x + half, y + half, half);\n if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf && topLeft.val === topRight.val && topRight.val === bottomLeft.val && bottomLeft.val === bottomRight.val) {\n return new Node(topLeft.val, true);\n }\n return new Node('*', false, topLeft, topRight, bottomLeft, bottomRight);\n }\n return build(0, 0, grid.length);\n}\n",
		"explanation": "This function constructs a quad tree from a grid.",
		"category": "Divide & Conquer"
	},
	{
		"id": 111,
		"topic": "Merge k Sorted Lists",
		"code": "// Merge k sorted linked lists\nfunction mergeKLists(lists) {\n if (!lists.length) return null;\n function mergeTwoLists(l1, l2) {\n let dummy = new ListNode(0), current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n }\n while (lists.length > 1) {\n let l1 = lists.shift();\n let l2 = lists.shift();\n let merged = mergeTwoLists(l1, l2);\n lists.push(merged);\n }\n return lists[0];\n}\n",
		"explanation": "This function merges k sorted linked lists into one sorted linked list.",
		"category": "Divide & Conquer"
	},
	{
		"id": 112,
		"topic": "Maximum Subarray",
		"code": "// Find the contiguous subarray with the maximum sum\nvar maxSubArray = function(nums) {\n let maxSum = nums[0];  // Initialize maxSum with the first element\n let currentSum = 0;    // Initialize currentSum to 0\n\n // Iterate through the array\n for (let num of nums) {\n // Decide whether to start a new subarray or continue adding the current number\n currentSum = Math.max(num, currentSum + num);\n\n // Update maxSum if currentSum is greater\n maxSum = Math.max(maxSum, currentSum);\n }\n\n return maxSum;  // Return the largest sum found\n};\n\n// Example\nconst nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4];\nconsole.log('Maximum Subarray Sum:', maxSubArray(nums)); // Output: Maximum Subarray Sum: 6\n",
		"explanation": "The problem at hand is to find the contiguous subarray within an integer array `nums` that has the largest sum. This problem is efficiently solved using `Kadane’s Algorithm`, which operates in linear time.<br/><br/>### Key Steps in Kadane’s Algorithm:<br/><br/>1. Initialization:<br/> - We start by initializing `maxSum` with the first element of the array (`nums[0]`) since the subarray must have at least one element. This is also our starting point for comparison.<br/> - `currentSum` is initialized to 0, which will be used to track the sum of the current subarray as we iterate through the array.<br/><br/>2. Iterate through the array:<br/> - For each number in the array (`num`), we decide whether to:<br/> - Start a new subarray with the current number (`num`), or<br/> - Add the current number to the ongoing subarray sum (`currentSum + num`).<br/> - The decision is made by comparing `num` with `currentSum + num` and taking the larger value using `Math.max(num, currentSum + num)`. This allows us to effectively \"reset\" the sum if adding the current number leads to a smaller sum than just starting fresh with the current number.<br/><br/>3. Update `maxSum`:<br/> - After adjusting `currentSum` for each number, we check if `currentSum` is greater than the current `maxSum`. If it is, we update `maxSum` to be `currentSum`.<br/><br/>4. Return the result:<br/> - After iterating through the array, the `maxSum` will contain the largest sum of any contiguous subarray, which is our desired result.<br/><br/>### Example Walkthrough:<br/>Given the input `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`:<br/>- Initially, `maxSum` is `-2` (the first element) and `currentSum` is `0`.<br/>- We begin iterating:<br/> - When `1` is encountered, `currentSum` becomes `1` (since `1 > 0 + 1`).<br/> - Next, when `-3` is encountered, `currentSum` becomes `-2` (since `1 + (-3)` is less than `-3`).<br/> - When `4` is encountered, `currentSum` becomes `4` (since `4 > -2 + 4`), and so on.<br/>- The algorithm identifies the subarray `[4, -1, 2, 1]` with the maximum sum of `6`.<br/><br/>### Time Complexity:<br/>- O(n) where `n` is the length of the array, because we only need to make one pass through the array.<br/><br/>### Space Complexity:<br/>- O(1) since we only use a constant amount of extra space (`maxSum` and `currentSum`).",
		"category": "Kadane's Algorithm"
	},
	{
		"id": 113,
		"topic": "Maximum Sum Circular Subarray",
		"code": "// Find the maximum sum of a circular subarray\nfunction maxSubarraySumCircular(A) {\n let total = 0, maxSum = A[0], currentMax = 0, minSum = A[0], currentMin = 0;\n for (let a of A) {\n currentMax = Math.max(currentMax + a, a);\n maxSum = Math.max(maxSum, currentMax);\n currentMin = Math.min(currentMin + a, a);\n minSum = Math.min(minSum, currentMin);\n total += a;\n }\n return maxSum > 0 ? Math.max(maxSum, total - minSum) : maxSum;\n}\n",
		"explanation": "This function finds the maximum sum of a circular subarray.",
		"category": "Kadane's Algorithm"
	},
	{
		"id": 114,
		"topic": "Search Insert Position",
		"code": "// Find the index where a target should be inserted\nvar searchInsert = function(nums, target) {\n console.log(\"nums:\", nums);\n console.log(\"target:\", target);\n // Initializing two pointers, left and right, which will define the search range\n let left = 0;\n let right = nums.length - 1;\n\n // Binary search loop: Continue until the left pointer exceeds the right pointer\n while (left <= right) {\n // Find the middle index in the current search range\n const mid = Math.floor((left + right) / 2);\n\n // Case 1: If the target is found at mid, return the mid index\n if (nums[mid] === target) {\n return mid;\n }\n // Case 2: If the target is greater than the mid value, search in the right half\n else if (nums[mid] < target) {\n left = mid + 1;  // Move the left pointer to mid + 1\n }\n // Case 3: If the target is smaller than the mid value, search in the left half\n else {\n right = mid - 1;  // Move the right pointer to mid - 1\n }\n }\n\n // If the target is not found, left will be the position where the target should be inserted\n // This ensures the array remains sorted if the target were to be inserted\n return left;\n};\n\n// Example usage:\nconsole.log(searchInsert([1, 3, 5, 6], 5)); // Output: 2\nconsole.log(searchInsert([1, 3, 5, 6], 2)); // Output: 1\nconsole.log(searchInsert([1, 3, 5, 6], 7)); // Output: 4\nconsole.log(searchInsert([1, 3, 5, 6], 0)); // Output: 0\nconsole.log(searchInsert([1, 3, 5, 6], 4)); // Output: 2\n",
		"explanation": "- `left` and `right` represent the current search boundaries within the array. Initially, `left` is at the start (0) and `right` is at the end (nums.length - 1).<br/><br/>- `mid` is the middle index of the current search range and is calculated by `(left + right) / 2`. It is used to compare the target with the element at that index.<br/><br/>- The three cases inside the while loop handle different situations:<br/> - If the element at `nums[mid]` equals the target, we return the `mid` index immediately, as we have found the target.<br/> - If `nums[mid]` is less than the target, the target must be on the right side of `mid`, so we move the `left` pointer to `mid + 1`.<br/> - If `nums[mid]` is greater than the target, the target must be on the left side of `mid`, so we move the `right` pointer to `mid - 1`.<br/><br/>- Once the binary search is complete and the target is not found, the `left` pointer will be positioned at the index where the target should be inserted to keep the array sorted. This is the key idea: if the target isn't present, `left` will point to the first position where the target can be inserted without disrupting the order.<br/><br/>Time Complexity:<br/><br/>- O(log n): The binary search halves the search range in each step, leading to a logarithmic time complexity. This is optimal for searching in a sorted array.<br/><br/>Space Complexity:<br/><br/>- O(1): The algorithm uses a constant amount of extra space, as it only stores a few variables (left, right, mid) and does not use any additional data structures.",
		"category": "Binary Search"
	},
	{
		"id": 115,
		"topic": "Search a 2D Matrix",
		"code": "// Search a target in a 2D matrix\nfunction searchMatrix(matrix, target) {\n if (!matrix.length || !matrix[0].length) return false;\n let rows = matrix.length, cols = matrix[0].length;\n let left = 0, right = rows * cols - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n let midVal = matrix[Math.floor(mid / cols)][mid % cols];\n if (midVal === target) return true;\n if (midVal < target) left = mid + 1;\n else right = mid - 1;\n }\n return false;\n}\n",
		"explanation": "This function searches for a target in a 2D matrix.",
		"category": "Binary Search"
	},
	{
		"id": 116,
		"topic": "Find Peak Element",
		"code": "// Find peak element\nfunction findPeakElement(nums) {\n let left = 0, right = nums.length - 1;\n while (left < right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] > nums[mid + 1]) right = mid;\n else left = mid + 1;\n }\n return left;\n}\n",
		"explanation": "This function finds a peak element in an array.",
		"category": "Binary Search"
	},
	{
		"id": 117,
		"topic": "Search in Rotated Sorted Array",
		"code": "// Search in rotated sorted array\nfunction search(nums, target) {\n let left = 0, right = nums.length - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] === target) return mid;\n if (nums[left] <= nums[mid]) {\n if (nums[left] <= target && target < nums[mid]) right = mid - 1;\n else left = mid + 1;\n } else {\n if (nums[mid] < target && target <= nums[right]) left = mid + 1;\n else right = mid - 1;\n }\n }\n return -1;\n}\n",
		"explanation": "This function searches for a target in a rotated sorted array.",
		"category": "Binary Search"
	},
	{
		"id": 118,
		"topic": "Find First and Last Position of Element in Sorted Array",
		"code": "// Find first and last position of element in sorted array\nfunction searchRange(nums, target) {\n function findBound(isFirst) {\n let left = 0, right = nums.length - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] === target) {\n if (isFirst) {\n if (mid === left || nums[mid - 1] !== target) return mid;\n right = mid - 1;\n } else {\n if (mid === right || nums[mid + 1] !== target) return mid;\n left = mid + 1;\n }\n } else if (nums[mid] < target) left = mid + 1;\n else right = mid - 1;\n }\n return -1;\n }\n return [findBound(true), findBound(false)];\n}\n",
		"explanation": "This function finds the first and last position of an element in a sorted array.",
		"category": "Binary Search"
	},
	{
		"id": 119,
		"topic": "Find Minimum in Rotated Sorted Array",
		"code": "// Find minimum in rotated sorted array\nfunction findMin(nums) {\n let left = 0, right = nums.length - 1;\n while (left < right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] > nums[right]) left = mid + 1;\n else right = mid;\n }\n return nums[left];\n}\n",
		"explanation": "This function finds the minimum element in a rotated sorted array.",
		"category": "Binary Search"
	},
	{
		"id": 120,
		"topic": "Median of Two Sorted Arrays",
		"code": "// Find median of two sorted arrays\nfunction findMedianSortedArrays(nums1, nums2) {\n let m = nums1.length, n = nums2.length;\n if (m > n) [nums1, nums2, m, n] = [nums2, nums1, n, m];\n let imin = 0, imax = m, halfLen = Math.floor((m + n + 1) / 2);\n while (imin <= imax) {\n let i = Math.floor((imin + imax) / 2);\n let j = halfLen - i;\n if (i < m && nums1[i] < nums2[j - 1]) imin = i + 1;\n else if (i > 0 && nums1[i - 1] > nums2[j]) imax = i - 1;\n else {\n let maxOfLeft = 0;\n if (i === 0) maxOfLeft = nums2[j - 1];\n else if (j === 0) maxOfLeft = nums1[i - 1];\n else maxOfLeft = Math.max(nums1[i - 1], nums2[j - 1]);\n if ((m + n) % 2 === 1) return maxOfLeft;\n let minOfRight = 0;\n if (i === m) minOfRight = nums2[j];\n else if (j === n) minOfRight = nums1[i];\n else minOfRight = Math.min(nums1[i], nums2[j]);\n return (maxOfLeft + minOfRight) / 2;\n }\n }\n return 0;\n}\n",
		"explanation": "This function finds the median of two sorted arrays.",
		"category": "Binary Search"
	},
	{
		"id": 121,
		"topic": "Kth Largest Element in an Array",
		"code": "// Find kth largest element in an array\nfunction findKthLargest(nums, k) {\n let heap = new MinHeap();\n for (let num of nums) {\n heap.add(num);\n if (heap.size() > k) heap.poll();\n }\n return heap.peek();\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] >= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild < element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild < element) || (swap !== null && rightChild < leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the kth largest element in an array using a min heap.",
		"category": "Heap"
	},
	{
		"id": 122,
		"topic": "IPO",
		"code": "// Find the maximum capital after k projects\nfunction findMaximizedCapital(k, W, Profits, Capital) {\n let minCapital = new MinHeap(), maxProfit = new MaxHeap();\n for (let i = 0; i < Capital.length; i++) minCapital.add([Capital[i], Profits[i]]);\n for (let i = 0; i < k; i++) {\n while (minCapital.size() && minCapital.peek()[0] <= W) maxProfit.add(minCapital.poll()[1]);\n if (!maxProfit.size()) break;\n W += maxProfit.poll();\n }\n return W;\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index][0] >= this.heap[parentIndex][0]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild[0] < element[0]) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild[0] < element[0]) || (swap !== null && rightChild[0] < leftChild[0])) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\nclass MaxHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] <= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild > element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the maximum capital after k projects.",
		"category": "Heap"
	},
	{
		"id": 123,
		"topic": "Find K Pairs with Smallest Sums",
		"code": "// Find k pairs with smallest sums\nfunction kSmallestPairs(nums1, nums2, k) {\n let heap = new MinHeap();\n for (let i = 0; i < Math.min(nums1.length, k); i++) heap.add([nums1[i] + nums2[0], i, 0]);\n let result = [];\n while (k-- > 0 && heap.size()) {\n let [sum, i, j] = heap.poll();\n result.push([nums1[i], nums2[j]]);\n if (j + 1 < nums2.length) heap.add([nums1[i] + nums2[j + 1], i, j + 1]);\n }\n return result;\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index][0] >= this.heap[parentIndex][0]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild[0] < element[0]) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild[0] < element[0]) || (swap !== null && rightChild[0] < leftChild[0])) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds k pairs with the smallest sums.",
		"category": "Heap"
	},
	{
		"id": 124,
		"topic": "Find Median from Data Stream",
		"code": "// Find median from data stream\nclass MedianFinder {\n constructor() {\n this.small = new MaxHeap();\n this.large = new MinHeap();\n }\n addNum(num) {\n this.small.add(num);\n this.large.add(this.small.poll());\n if (this.small.size() < this.large.size()) this.small.add(this.large.poll());\n }\n findMedian() {\n return this.small.size() > this.large.size() ? this.small.peek() : (this.small.peek() + this.large.peek()) / 2;\n }\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] >= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild < element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild < element) || (swap !== null && rightChild < leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\nclass MaxHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] <= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild > element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the median from a data stream.",
		"category": "Heap"
	},
	{
		"id": 125,
		"topic": "Add Binary",
		"code": "// Add two binary numbers\nfunction addBinary(a, b) {\n let result = '', carry = 0, i = a.length - 1, j = b.length - 1;\n while (i >= 0 || j >= 0 || carry) {\n let sum = carry;\n if (i >= 0) sum += parseInt(a[i--], 2);\n if (j >= 0) sum += parseInt(b[j--], 2);\n result = (sum % 2) + result;\n carry = Math.floor(sum / 2);\n }\n return result;\n}\n",
		"explanation": "This function adds two binary numbers and returns the result as a binary string.",
		"category": "Bit Manipulation"
	},
	{
		"id": 126,
		"topic": "Reverse Bits",
		"code": "// Reverse bits of a given 32 bits unsigned integer\nfunction reverseBits(n) {\n let result = 0;\n for (let i = 0; i < 32; i++) {\n result = (result << 1) | (n & 1);\n n >>>= 1;\n }\n return result >>> 0;\n}\n",
		"explanation": "This function reverses the bits of a given 32 bits unsigned integer.",
		"category": "Bit Manipulation"
	},
	{
		"id": 127,
		"topic": "Number of 1 Bits",
		"code": "// Count the number of 1 bits\nfunction hammingWeight(n) {\n let count = 0;\n while (n !== 0) {\n count += n & 1;\n n >>>= 1;\n }\n return count;\n}\n",
		"explanation": "This function counts the number of 1 bits in a given integer.",
		"category": "Bit Manipulation"
	},
	{
		"id": 128,
		"topic": "Single Number",
		"code": "// Find the single number\nfunction singleNumber(nums) {\n let result = 0;\n for (let num of nums) {\n result ^= num;\n }\n return result;\n}\n",
		"explanation": "This function finds the single number in an array where every other number appears twice.",
		"category": "Bit Manipulation"
	},
	{
		"id": 129,
		"topic": "Single Number II",
		"code": "// Find the single number that appears only once\nfunction singleNumber(nums) {\n let ones = 0, twos = 0;\n for (let num of nums) {\n ones = (ones ^ num) & ~twos;\n twos = (twos ^ num) & ~ones;\n }\n return ones;\n}\n",
		"explanation": "This function finds the single number that appears only once in an array where every other number appears three times.",
		"category": "Bit Manipulation"
	},
	{
		"id": 130,
		"topic": "Bitwise AND of Numbers Range",
		"code": "// Find the bitwise AND of numbers range\nfunction rangeBitwiseAnd(m, n) {\n let shift = 0;\n while (m < n) {\n m >>= 1;\n n >>= 1;\n shift++;\n }\n return m << shift;\n}\n",
		"explanation": "This function finds the bitwise AND of all numbers in a given range.",
		"category": "Bit Manipulation"
	},
	{
		"id": 131,
		"topic": "Palindrome Number",
		"code": "// Check if a number is a palindrome\nfunction isPalindrome(x) {\n if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n let revertedNumber = 0;\n while (x > revertedNumber) {\n revertedNumber = revertedNumber * 10 + x % 10;\n x = Math.floor(x / 10);\n }\n return x === revertedNumber || x === Math.floor(revertedNumber / 10);\n}\n",
		"explanation": "This function checks if a number is a palindrome.",
		"category": "Math"
	},
	{
		"id": 132,
		"topic": "Plus One",
		"code": "// Increment a number represented as an array\nfunction plusOne(digits) {\n for (let i = digits.length - 1; i >= 0; i--) {\n if (digits[i] < 9) {\n digits[i]++;\n return digits;\n }\n digits[i] = 0;\n }\n digits.unshift(1);\n return digits;\n}\n",
		"explanation": "This function increments a number represented as an array of digits by one.",
		"category": "Math"
	},
	{
		"id": 133,
		"topic": "Factorial Trailing Zeroes",
		"code": "// Find the number of trailing zeroes in factorial\nfunction trailingZeroes(n) {\n let count = 0;\n while (n > 0) {\n n = Math.floor(n / 5);\n count += n;\n }\n return count;\n}\n",
		"explanation": "This function finds the number of trailing zeroes in the factorial of a given number.",
		"category": "Math"
	},
	{
		"id": 134,
		"topic": "Sqrt(x)",
		"code": "// Calculate the square root of x\nfunction mySqrt(x) {\n if (x === 0) return 0;\n let left = 1, right = x;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (mid * mid === x) return mid;\n if (mid * mid < x) left = mid + 1;\n else right = mid - 1;\n }\n return right;\n}\n",
		"explanation": "This function calculates the square root of x using binary search.",
		"category": "Math"
	},
	{
		"id": 135,
		"topic": "Pow(x, n)",
		"code": "// Calculate x raised to the power n\nfunction myPow(x, n) {\n if (n === 0) return 1;\n if (n < 0) return 1 / myPow(x, -n);\n if (n % 2 === 0) return myPow(x * x, n / 2);\n return x * myPow(x * x, (n - 1) / 2);\n}\n",
		"explanation": "This function calculates x raised to the power n using recursion.",
		"category": "Math"
	},
	{
		"id": 136,
		"topic": "Max Points on a Line",
		"code": "// Find the maximum number of points on a line\nfunction maxPoints(points) {\n if (points.length < 3) return points.length;\n let max = 0;\n for (let i = 0; i < points.length; i++) {\n let map = new Map(), duplicates = 1;\n for (let j = i + 1; j < points.length; j++) {\n let dx = points[j][0] - points[i][0];\n let dy = points[j][1] - points[i][1];\n if (dx === 0 && dy === 0) {\n duplicates++;\n continue;\n }\n let gcd = getGCD(dx, dy);\n dx /= gcd;\n dy /= gcd;\n let key = `${dx}/${dy}`;\n map.set(key, (map.get(key) || 0) + 1);\n }\n max = Math.max(max, duplicates);\n for (let count of map.values()) {\n max = Math.max(max, count + duplicates);\n }\n }\n return max;\n}\nfunction getGCD(a, b) {\n if (b === 0) return a;\n return getGCD(b, a % b);\n}\n",
		"explanation": "This function finds the maximum number of points on a line.",
		"category": "Math"
	},
	{
		"id": 137,
		"topic": "Climbing Stairs",
		"code": "// Find the number of ways to climb stairs\nfunction climbStairs(n) {\n if (n <= 2) return n;\n let a = 1, b = 2;\n for (let i = 3; i <= n; i++) {\n let temp = a + b;\n a = b;\n b = temp;\n }\n return b;\n}\n",
		"explanation": "This function finds the number of ways to climb a staircase with n steps.",
		"category": "1D DP"
	},
	{
		"id": 138,
		"topic": "House Robber",
		"code": "// Find the maximum amount of money you can rob\nvar rob = function(nums) {\n // Handle edge cases\n if (nums.length === 0) return 0; // No houses to rob\n if (nums.length === 1) return nums[0]; // Only one house to rob\n // Initialize variables for the maximum money robbed at two previous houses\n let prevHouseMax = 0; // Represents the max money robbed from two houses ago (dp[i-2])\n let lastHouseMax = nums[0]; // Represents the max money robbed from the last house (dp[i-1])\n // Iterate through the houses starting from the second one\n for (let i = 1; i < nums.length; i++) {\n // Calculate the maximum money we can rob at this house\n let currentMax = Math.max(lastHouseMax, nums[i] + prevHouseMax);\n // Update the variables for the next iteration\n prevHouseMax = lastHouseMax;\n lastHouseMax = currentMax;\n }\n // The final `lastHouseMax` contains the maximum amount of money that can be robbed\n return lastHouseMax;\n};\n\n// Example usage:\nconsole.log(rob([1,2,3,1])); // Output: 4\nconsole.log(rob([2,7,9,3,1])); // Output: 12\n",
		"explanation": "1. Edge Cases:<br/> - If the list is empty, return 0 as there are no houses to rob.<br/> - If there is only one house, return its value (`nums[0]`).<br/><br/>2. Dynamic Programming Approach:<br/> - Use two variables, `prevHouseMax` and `lastHouseMax`, to keep track of the maximum money robbed from the last two houses.<br/> - For each house:<br/> - Decide between skipping the house (taking `lastHouseMax`) or robbing it (taking `nums[i] + prevHouseMax`).<br/> - Store the maximum of these two options in `currentMax`.<br/><br/>3. Space Optimization:<br/> - Instead of using an entire array to store intermediate results, we only track the last two states, reducing space complexity to O(1).<br/><br/>4. Final Result:<br/> - After processing all houses, `lastHouseMax` holds the maximum amount of money that can be robbed.<br/><br/>Time Complexity: O(n), where n is the number of houses. We only need to iterate through the list once.<br/>Space Complexity: O(1), as we only use a constant amount of extra space.",
		"category": "1D DP"
	},
	{
		"id": 139,
		"topic": "Word Break",
		"code": "// Determine if you can segment the string into words\nfunction wordBreak(s, wordDict) {\n let dp = Array(s.length + 1).fill(false);\n dp[0] = true;\n for (let i = 1; i <= s.length; i++) {\n for (let j = 0; j < i; j++) {\n if (dp[j] && wordDict.includes(s.slice(j, i))) {\n dp[i] = true;\n break;\n }\n }\n }\n return dp[s.length];\n}\n",
		"explanation": "This function determines if you can segment the string into words from the dictionary.",
		"category": "1D DP"
	},
	{
		"id": 140,
		"topic": "Coin Change",
		"code": "// Find the minimum number of coins to make up a given amount\nfunction coinChange(coins, amount) {\n let dp = Array(amount + 1).fill(Infinity);\n dp[0] = 0;\n for (let coin of coins) {\n for (let i = coin; i <= amount; i++) {\n dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n }\n }\n return dp[amount] === Infinity ? -1 : dp[amount];\n}\n",
		"explanation": "This function finds the minimum number of coins needed to make up a given amount.",
		"category": "1D DP"
	},
	{
		"id": 141,
		"topic": "Longest Increasing Subsequence",
		"code": "// Find the length of the longest increasing subsequence\nfunction lengthOfLIS(nums) {\n let dp = Array(nums.length).fill(1);\n for (let i = 1; i < nums.length; i++) {\n for (let j = 0; j < i; j++) {\n if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);\n }\n }\n return Math.max(...dp);\n}\n",
		"explanation": "This function finds the length of the longest increasing subsequence in an array.",
		"category": "1D DP"
	},
	{
		"id": 142,
		"topic": "Triangle",
		"code": "// Find the minimum path sum from top to bottom\nfunction minimumTotal(triangle) {\n let dp = triangle[triangle.length - 1];\n for (let i = triangle.length - 2; i >= 0; i--) {\n for (let j = 0; j < triangle[i].length; j++) {\n dp[j] = triangle[i][j] + Math.min(dp[j], dp[j + 1]);\n }\n }\n return dp[0];\n}\n",
		"explanation": "This function finds the minimum path sum from top to bottom in a triangle.",
		"category": "Multidimensional DP"
	},
	{
		"id": 143,
		"topic": "Minimum Path Sum",
		"code": "// Find the minimum path sum in a grid\nfunction minPathSum(grid) {\n let m = grid.length, n = grid[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n dp[0][0] = grid[0][0];\n for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];\n for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];\n for (let i = 1; i < m; i++) {\n for (let j = 1; j < n; j++) {\n dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);\n }\n }\n return dp[m - 1][n - 1];\n}\n",
		"explanation": "This function finds the minimum path sum in a grid from top-left to bottom-right.",
		"category": "Multidimensional DP"
	},
	{
		"id": 144,
		"topic": "Unique Paths II",
		"code": "// Find the number of unique paths in a grid with obstacles\nfunction uniquePathsWithObstacles(obstacleGrid) {\n let m = obstacleGrid.length, n = obstacleGrid[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n dp[0][0] = obstacleGrid[0][0] === 1 ? 0 : 1;\n for (let i = 1; i < m; i++) dp[i][0] = obstacleGrid[i][0] === 1 ? 0 : dp[i - 1][0];\n for (let j = 1; j < n; j++) dp[0][j] = obstacleGrid[0][j] === 1 ? 0 : dp[0][j - 1];\n for (let i = 1; i < m; i++) {\n for (let j = 1; j < n; j++) {\n if (obstacleGrid[i][j] === 1) dp[i][j] = 0;\n else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n }\n }\n return dp[m - 1][n - 1];\n}\n",
		"explanation": "This function finds the number of unique paths in a grid with obstacles from top-left to bottom-right.",
		"category": "Multidimensional DP"
	},
	{
		"id": 145,
		"topic": "Longest Palindromic Substring",
		"code": "// Find the longest palindromic substring\nfunction longestPalindrome(s) {\n let n = s.length;\n let dp = Array(n).fill().map(() => Array(n).fill(false));\n let maxLength = 1, start = 0;\n for (let i = 0; i < n; i++) dp[i][i] = true;\n for (let i = 0; i < n - 1; i++) {\n if (s[i] === s[i + 1]) {\n dp[i][i + 1] = true;\n start = i;\n maxLength = 2;\n }\n }\n for (let k = 3; k <= n; k++) {\n for (let i = 0; i < n - k + 1; i++) {\n let j = i + k - 1;\n if (dp[i + 1][j - 1] && s[i] === s[j]) {\n dp[i][j] = true;\n if (k > maxLength) {\n start = i;\n maxLength = k;\n }\n }\n }\n }\n return s.substring(start, start + maxLength);\n}\n",
		"explanation": "This function finds the longest palindromic substring in a given string.",
		"category": "Multidimensional DP"
	},
	{
		"id": 146,
		"topic": "Interleaving String",
		"code": "// Determine if s3 is an interleaving of s1 and s2\nfunction isInterleave(s1, s2, s3) {\n if (s1.length + s2.length !== s3.length) return false;\n let dp = Array(s1.length + 1).fill().map(() => Array(s2.length + 1).fill(false));\n dp[0][0] = true;\n for (let i = 1; i <= s1.length; i++) dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\n for (let j = 1; j <= s2.length; j++) dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\n for (let i = 1; i <= s1.length; i++) {\n for (let j = 1; j <= s2.length; j++) {\n dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n }\n }\n return dp[s1.length][s2.length];\n}\n",
		"explanation": "This function determines if s3 is an interleaving of s1 and s2.",
		"category": "Multidimensional DP"
	},
	{
		"id": 147,
		"topic": "Edit Distance",
		"code": "// Find the minimum edit distance between two strings\nfunction minDistance(word1, word2) {\n let m = word1.length, n = word2.length;\n let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n for (let i = 0; i <= m; i++) dp[i][0] = i;\n for (let j = 0; j <= n; j++) dp[0][j] = j;\n for (let i = 1; i <= m; i++) {\n for (let j = 1; j <= n; j++) {\n if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n else dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;\n }\n }\n return dp[m][n];\n}\n",
		"explanation": "This function finds the minimum edit distance between two strings.",
		"category": "Multidimensional DP"
	},
	{
		"id": 148,
		"topic": "Best Time to Buy and Sell Stock III",
		"code": "// Find the maximum profit with at most two transactions\nfunction maxProfit(prices) {\n let t1Cost = Infinity, t2Cost = Infinity;\n let t1Profit = 0, t2Profit = 0;\n for (let price of prices) {\n t1Cost = Math.min(t1Cost, price);\n t1Profit = Math.max(t1Profit, price - t1Cost);\n t2Cost = Math.min(t2Cost, price - t1Profit);\n t2Profit = Math.max(t2Profit, price - t2Cost);\n }\n return t2Profit;\n}\n",
		"explanation": "This function finds the maximum profit with at most two transactions.",
		"category": "Multidimensional DP"
	},
	{
		"id": 149,
		"topic": "Best Time to Buy and Sell Stock IV",
		"code": "// Find the maximum profit with at most k transactions\nfunction maxProfit(k, prices) {\n if (prices.length === 0) return 0;\n if (k >= prices.length / 2) {\n let profit = 0;\n for (let i = 1; i < prices.length; i++) {\n if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\n }\n return profit;\n }\n let dp = Array(k + 1).fill().map(() => Array(prices.length).fill(0));\n for (let i = 1; i <= k; i++) {\n let maxDiff = -prices[0];\n for (let j = 1; j < prices.length; j++) {\n dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n }\n }\n return dp[k][prices.length - 1];\n}\n",
		"explanation": "This function finds the maximum profit with at most k transactions.",
		"category": "Multidimensional DP"
	},
	{
		"id": 150,
		"topic": "Maximal Square",
		"code": "// Find the largest square containing only 1's\nfunction maximalSquare(matrix) {\n if (matrix.length === 0) return 0;\n let m = matrix.length, n = matrix[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n let maxSide = 0;\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n if (matrix[i][j] === '1') {\n if (i === 0 || j === 0) dp[i][j] = 1;\n else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n maxSide = Math.max(maxSide, dp[i][j]);\n }\n }\n }\n return maxSide * maxSide;\n}\n",
		"explanation": "This function finds the largest square containing only 1's in a binary matrix.",
		"category": "Multidimensional DP"
	}
]
