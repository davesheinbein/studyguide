[
	{
		"id": 1,
		"topic": "Merge Sorted Array",
		"code": "// Define a function to merge two sorted integer arrays\nvar merge = function(nums1, m, nums2, n) {\n    // Initialize pointers for the last elements of nums1 and nums2\n    let i = m - 1; // Pointer for the last element in the first part of nums1\n    let j = n - 1; // Pointer for the last element in nums2\n    let k = m + n - 1; // Pointer for the last position in nums1 (the merged array)\n\n    // While there are still elements to merge from nums2\n    while (j >= 0) {\n        // If there are remaining elements in nums1 and the current element in nums1 is greater than in nums2\n        if (i >= 0 && nums1[i] > nums2[j]) {\n            nums1[k] = nums1[i]; // Place the element from nums1 into the correct position in nums1\n            i--; // Move the pointer in nums1 left\n        } else {\n            // If nums2's current element is greater or nums1 is exhausted\n            nums1[k] = nums2[j]; // Place the element from nums2 into nums1\n            j--; // Move the pointer in nums2 left\n        }\n        // Move the pointer for the merged position left\n        k--;\n    }\n    // No need to return anything since we modify nums1 in place\n};\n",
		"explanation": "1. Function Purpose: The merge function is designed to combine two sorted arrays, nums1 and nums2, into a single sorted array stored in nums1.<br/>2. Input Specification: <br/>   - nums1 is an array of integers that contains m elements followed by n zeros. <br/>   - nums2 is an array of integers containing n elements.<br/>   - m represents the number of actual elements in nums1.<br/>   - n represents the number of elements in nums2.<br/>3. Output Specification: <br/>   - The merged sorted array is stored in nums1.<br/>   - No return value is necessary as the result modifies nums1 in place.<br/>4. Example Walkthrough:<br/>   - Example 1: For the input nums1 = [1, 2, 3, 0, 0, 0], m = 3, nums2 = [2, 5, 6], n = 3:<br/>     - Start merging from the end of both arrays, comparing elements and placing them in the correct position.<br/>     - Final output in nums1 will be [1, 2, 2, 3, 5, 6].<br/>   - Example 2: For the input nums1 = [1], m = 1, nums2 = [], n = 0:<br/>     - Since nums2 is empty, nums1 remains [1].<br/>   - Example 3: For the input nums1 = [0], m = 0, nums2 = [1], n = 1:<br/>     - All elements from nums2 are placed in nums1, resulting in [1].<br/>5. Constraints:<br/>   - The function handles constraints ensuring both arrays are of appropriate lengths, with -10^9 <= nums1[i], nums2[j] <= 10^9.<br/>   - The overall length of the combined arrays does not exceed 200 elements, ensuring efficient performance.<br/>6. In-Place Modification: <br/>   - This approach modifies nums1 directly, utilizing its extra space to accommodate the merged result without needing additional arrays, thus achieving O(1) extra space complexity.",
		"category": "Array / String"
	},
	{
		"id": 2,
		"topic": "Remove Element",
		"code": "var removeElement = function(nums, val) {\n    // Initialize k to track the position for the next element that isn’t equal to val.\n    let k = 0;\n\n    // Loop through each element in the nums array\n    for (let i = 0; i < nums.length; i++) {\n        // Check if the current element nums[i] is not equal to val\n        if (nums[i] !== val) {\n            // Place the current element at index k, then increment k\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    \n    // Return k, which now represents the number of elements not equal to val\n    return k;\n};\n",
		"explanation": "Explanation:<br/> - Two-Pointer Approach: We use two pointers, one iterating through the array (`i`)<br/>   and one (`k`) to store the position of the next non-val element.<br/> - Place Non-Val Elements: If an element isn’t equal to `val`, we place it at the<br/>   current position of `k` and then increment `k`.<br/> - Final Result: By the end of the loop, the first `k` elements in `nums` will contain<br/>   all elements except `val`. `k` is returned, representing the count of elements in `nums`<br/>   that are not equal to `val`.<br/> ### Example Walkthroughs:<br/> 1. Example 1:<br/>    - Input: `nums = [3, 2, 2, 3]`, `val = 3`<br/>    - Output: `2`, `nums = [2, 2, _, _]`<br/>    - Explanation: After removing all occurrences of `val = 3`, the array has two elements<br/>      `[2, 2]` and `k = 2`.<br/> <br/> 2. Example 2:<br/>    - Input: `nums = [0, 1, 2, 2, 3, 0, 4, 2]`, `val = 2`<br/>    - Output: `5`, `nums = [0, 1, 4, 0, 3, _, _, _]`<br/>    - Explanation: After removing all occurrences of `val = 2`, the array has five elements<br/>      `[0, 1, 4, 0, 3]` and `k = 5`.<br/> <br/> ### Complexity:<br/> - Time Complexity: `O(n)`, where `n` is the length of `nums`, as we make a single pass through the array.<br/> - Space Complexity: `O(1)`, as the operation is performed in-place with no additional storage.",
		"category": "Array / String"
	},
	{
		"id": 3,
		"topic": "Remove Duplicates from Sorted Array",
		"code": "var removeDuplicates = function(nums) {\n    // Log the initial state of the input array\n    console.log(`Initial nums: ${nums}`);\n    // Log the length of the input array\n    console.log(`nums.length: ${nums.length}`);\n\n    // Check if the input array is empty\n    if (nums.length === 0) {\n        // If empty, log a message and return 0 as there are no unique elements\n        console.log(\"Input array is empty.\");\n        return 0;\n    }\n\n    // Initialize a pointer `k` to track the position of the last unique element\n    // Since the first element is always unique, we start with k = 1\n    let k = 1; \n\n    // Start iterating through the array from the second element (index 1)\n    for (let i = 1; i < nums.length; i++) {\n        // Log the current element being checked and the previous unique element\n        console.log(`Checking nums[${i}]: ${nums[i]} against nums[${i - 1}]: ${nums[i - 1]}`);\n        \n        // Compare the current element with the last unique element\n        if (nums[i] !== nums[i - 1]) {\n            // If they are different, we found a new unique element\n            console.log(`Found new unique element: ${nums[i]}`);\n            // Assign the current unique element to the position k in the array\n            nums[k] = nums[i]; \n            // Increment k to point to the next position for any future unique elements\n            k++; \n            // Log the updated state of the array containing unique elements so far\n            console.log(`Updated nums: ${nums.slice(0, k)} (unique count: ${k})`);\n        } else {\n            // If they are the same, it's a duplicate; log that a duplicate was found\n            console.log(`Duplicate element found: ${nums[i]}`);\n        }\n    }\n\n    // Log the final count of unique elements found\n    console.log(`Final unique count: ${k}`);\n    // Log the modified array which now contains only the unique elements in the first k positions\n    console.log(`Final modified nums: ${nums.slice(0, k)} (remaining elements are not important)`);\n    \n    // Return the count of unique elements\n    return k;\n};\n",
		"explanation": "Explanation of the Code Logic:<br/><br/>1. Function Declaration: The removeDuplicates function takes an array nums as input and is designed to modify it in place to remove duplicates.<br/><br/>2. Initial Checks: It first logs the input array and its length. If the array is empty, it returns 0, indicating there are no unique elements.<br/><br/>3. Pointer Initialization: The variable `k` is initialized to 1 because the first element is always considered unique.<br/><br/>4. Iterative Comparison: A for loop starts at index 1 and iterates through the array:<br/>   - It compares the current element (nums[i]) with the previous element (nums[i - 1]).<br/>   - If they are different, it identifies the current element as unique, assigns it to nums[k], and increments k.<br/>   - If they are the same, it logs that a duplicate has been found.<br/>5. Final Output: After processing all elements, it logs the count of unique elements and the modified array, which contains only the unique elements up to index k.",
		"category": "Array / String"
	},
	{
		"id": 4,
		"topic": "Remove Duplicates from Sorted Array II",
		"code": "var removeDuplicates = function(nums) {\n    console.log(\"Initial array:\", nums);\n    // Initialize a pointer 'k' to keep track of the position where the next allowable element should be placed.\n    let k = 0;\n\n    // Loop through each element in the input array 'nums' using the index 'i'.\n    for (let i = 0; i < nums.length; i++) {\n        console.log(`Current index i = ${i}, value nums[i] = ${nums[i]}`);\n\n        // Check the conditions to decide if nums[i] can be added.\n        if (k < 2 || nums[i] !== nums[k - 2]) {\n            console.log(`Adding nums[i] = ${nums[i]} at index k = ${k}`);\n            \n            // Place the current element 'nums[i]' at the position 'k' in the array.\n            nums[k] = nums[i];\n            k++;  // Increment 'k' for the next valid placement.\n            \n            console.log(`Updated array: ${nums.slice(0, k)} (length = ${k})`);\n        } else {\n            console.log(`Skipping nums[i] = ${nums[i]} to prevent more than two occurrences`);\n        }\n    }\n\n    // Final state of the modified array.\n    console.log(\"Final modified array:\", nums.slice(0, k));\n    console.log(\"Final length of modified array:\", k);\n\n    return k;\n};\n",
		"explanation": "Detailed Explanation Summary:<br/>1. 'k' is used as both a pointer and a counter:<br/>   - It keeps track of the position in 'nums' where the next valid element should be placed.<br/>   - By the end, 'k' will represent the length of the modified array.<br/>2. As we iterate through each element 'nums[i]', we use two conditions to decide if it should be added to the result:<br/>   - If 'k < 2', we are in the initial phase of the result array where any element is allowed.<br/>   - If 'k >= 2', we add 'nums[i]' only if it’s different from 'nums[k - 2]'.<br/>3. The check 'nums[i] !== nums[k - 2]' ensures that each unique element appears at most twice, by comparing with the element two places back.<br/>4. The function finally returns 'k', the length of the modified array, where each unique element appears at most twice.<br/>   - Elements from 'nums[0]' up to 'nums[k - 1]' represent the final modified array.",
		"category": "Array / String"
	},
	{
		"id": 5,
		"topic": "Majority Element",
		"code": "// Find majority element\nconst majorityElement = function(nums) {\n let count = 0; // Tracks the current \"weight\" of the candidate element.\n let candidate = null; // Stores the potential majority element.\n\n // Phase 1: Find a candidate for the majority element\n for (let i = 0; i < nums.length; i++) {\n if (count === 0) { // If count reaches zero, we choose a new candidate.\n candidate = nums[i];\n }\n // Increment or decrement the count based on whether the current number matches the candidate.\n count += (nums[i] === candidate) ? 1 : -1;\n }\n\n // At this point, `candidate` is the element that could potentially be the majority element.\n\n // Phase 2: Verify if the candidate is indeed the majority element\n count = 0; // Reset count to verify the candidate.\n for (let i = 0; i < nums.length; i++) {\n if (nums[i] === candidate) { // Count occurrences of the candidate in the array.\n count++;\n }\n }\n\n // Check if the candidate occurs more than ⌊n/2⌋ times.\n if (count > Math.floor(nums.length / 2)) {\n return candidate; // Candidate is the majority element.\n }\n // Throw an error if no majority element is found.\n // (Should not happen if the input meets the problem's guarantee.)\n throw new Error(\"No majority element found\");\n};\n\nconsole.log(majorityElement([3, 2, 3])); // Output: 3\n// Explanation: The majority element is 3, as it appears twice (more than 3/2 = 1.5 times).\n\nconsole.log(majorityElement([2, 2, 1, 1, 1, 2, 2])); // Output: 2\n// Explanation: The majority element is 2, as it appears four times (more than 7/2 = 3.5 times).\n",
		"explanation": "Explanation:<br/><br/>1. The algorithm is based on the Boyer-Moore Voting Algorithm.<br/>2. Phase 1:<br/>   - Iterates through the array to identify a potential majority element (`candidate`).<br/>   - Keeps a `count` which increases when the current number matches `candidate` and decreases otherwise.<br/>   - If `count` becomes zero, a new `candidate` is selected.<br/>   - By the end of this phase, `candidate` is guaranteed to be the majority element if one exists.<br/>3. Phase 2:<br/>   - Verifies if the `candidate` appears more than ⌊n/2⌋ times in the array.<br/>   - If yes, it returns the candidate. Otherwise, it throws an error.<br/>4. Time complexity: O(n) - Linear, as the array is traversed twice.<br/>5. Space complexity: O(1) - Constant, as no additional data structures are used.",
		"category": "Array / String"
	},
	{
		"id": 6,
		"topic": "Rotate Array",
		"code": "const rotate = function(nums, k) {\n    // Display the original array and k value to track changes.\n    console.log(\"Original array:\", nums);\n    console.log(\"Original k:\", k);\n\n    // Adjust k if it's greater than the array length:\n    // k % nums.length gives the effective number of rotations needed, \n    // since rotating by the length of the array results in the same array.\n    k = k % nums.length;\n\n    console.log(\"Rotation steps (k):\", k); // Show adjusted k value after modulo operation\n    \n    // Step 1: Reverse the entire array to start the rotation process.\n    // This brings the elements to the \"right-rotated\" positions but in reverse order.\n    reverse(nums, 0, nums.length - 1);\n    console.log(\"After reversing the entire array:\", nums);\n\n    // Step 2: Reverse the first `k` elements to place the rotated part in the correct order.\n    reverse(nums, 0, k - 1);\n    console.log(`After reversing the first ${k} elements:`, nums);\n\n    // Step 3: Reverse the elements from `k` to the end of the array.\n    // This step restores the remaining elements to their original order following the rotated segment.\n    reverse(nums, k, nums.length - 1);\n    console.log(`After reversing the elements from index ${k} to end:`, nums);\n};\n\nfunction reverse(nums, start, end) {\n    while (start < end) {\n        [nums[start], nums[end]] = [nums[end], nums[start]];\n        start++;\n        end--;\n    }\n}\n",
		"explanation": "Explanation of Key Parts:<br/><br/>1. Modulo Operation:<br/>   - `k = k % nums.length` reduces the rotation count by removing unnecessary full-length rotations. For example, rotating an array of length 7 by 7 or any multiple results in no change.<br/><br/>2. Reverse Function:<br/>   - `reverse` swaps elements between the `start` and `end` indices, iterating inward until `start` meets or exceeds `end`. This in-place swap operation reverses the specified segment of the array.<br/><br/>3. Three-Step Array Manipulation:<br/>   - Step 1: Reverse the entire array, setting up the array for a \"right rotation\" by bringing the last `k` elements to the beginning (in reverse order).<br/>   - Step 2: Reverse the first `k` elements, putting the rotated segment in its final, correct order.<br/>   - Step 3: Reverse the remaining elements to restore the rest of the array to its original sequence after the rotated portion.",
		"category": "Array / String"
	},
	{
		"id": 7,
		"topic": "Best Time to Buy and Sell Stock",
		"code": "// Find the maximum profit\nvar maxProfit = function(prices) {\n let minPrice = Infinity; // Initialize the minimum price as Infinity. This will be used to find the lowest price seen so far.\n let maxProfit = 0; // Initialize the maximum profit as 0. This will store the highest profit we can achieve.\n\n // Iterate through each price in the array\n for (let price of prices) {\n if (price < minPrice) {\n minPrice = price; // If the current price is lower than the minimum price seen so far, update minPrice.\n } else {\n // If the current price is not lower than minPrice, calculate the potential profit\n // by subtracting minPrice from the current price.\n maxProfit = Math.max(maxProfit, price - minPrice);\n // Update maxProfit only if the calculated profit is greater than the current maxProfit.\n }\n }\n\n return maxProfit; // After iterating through the array, return the maximum profit found.\n};\n\nlet prices1 = [7, 1, 5, 3, 6, 4];\nconsole.log(maxProfit(prices1)); // Output: 5\n// Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6). Profit = 6 - 1 = 5.\n\nlet prices2 = [7, 6, 4, 3, 1];\nconsole.log(maxProfit(prices2)); // Output: 0\n// Explanation: No transactions are possible since prices keep decreasing. Profit = 0.\n",
		"explanation": "Explanation:<br/>1. We iterate through the `prices` array to simulate buying and selling the stock.<br/>2. `minPrice` keeps track of the lowest price seen so far, ensuring that we always \"buy\" at the lowest possible price.<br/>3. For each price in the array:<br/>   - If it is lower than `minPrice`, update `minPrice` (simulate finding a better day to buy).<br/>   - Otherwise, calculate the profit if we \"sell\" on the current day. Compare this profit with the current `maxProfit` and update it if the new profit is higher.<br/>4. If no profit is possible (prices keep decreasing), `maxProfit` remains 0.<br/>5. The algorithm ensures we only traverse the array once, making it efficient with O(n) time complexity.",
		"category": "Array / String"
	},
	{
		"id": 8,
		"topic": "Best Time to Buy and Sell Stock II",
		"code": "// Find the maximum profit with multiple transactions\nvar maxProfit = function(prices) {\n let maxProfit = 0;\n\n for (let i = 1; i < prices.length; i++) {\n // If the price today is higher than the price yesterday,\n // it means we can make a profit by selling the stock.\n if (prices[i] > prices[i - 1]) {\n // Add the difference between today's price and yesterday's price to maxProfit\n maxProfit += prices[i] - prices[i - 1];\n }\n }\n\n // Return the total profit achieved from all profitable transactions\n return maxProfit;\n};\n\n// Example 1:\nconsole.log(maxProfit([7,1,5,3,6,4])); // Output: 7\n// Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5 - 1 = 4.\n// Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6 - 3 = 3.\n// Total profit = 4 + 3 = 7.\n\n// Example 2:\nconsole.log(maxProfit([1,2,3,4,5])); // Output: 4\n// Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5 - 1 = 4.\n// Total profit = 4.\n\n// Example 3:\nconsole.log(maxProfit([7,6,4,3,1])); // Output: 0\n// Explanation: No profitable opportunities since prices keep decreasing.\n// Total profit = 0.\n",
		"explanation": "Explanation:<br/><br/>- We are given an array 'prices' where each element represents the price of a stock on a given day.<br/>- The goal is to maximize profit by buying and selling the stock at the right times.<br/>- The key observation is that you can make a profit if the stock price increases from one day to the next.<br/>- On each day, if the price is higher than the previous day's price, we \"buy\" on the previous day and \"sell\" on the current day. The profit from this transaction is the difference between the two prices.<br/>- We repeat this for all days, adding the profits from each transaction, to get the total maximum profit.<br/>- The approach runs in linear time O(n), where n is the number of days in the 'prices' array.",
		"category": "Array / String"
	},
	{
		"id": 9,
		"topic": "Jump Game",
		"code": "// Determine if you can reach the last index\nfunction canJump(nums) {\n let maxReach = 0;\n for (let i = 0; i < nums.length; i++) {\n if (i > maxReach) return false;\n maxReach = Math.max(maxReach, i + nums[i]);\n }\n return true;\n}\n",
		"explanation": "This function determines if you can reach the last index of the array.",
		"category": "Array / String"
	},
	{
		"id": 10,
		"topic": "Jump Game II",
		"code": "// Find the minimum number of jumps to reach the last index\nfunction jump(nums) {\n let jumps = 0, currentEnd = 0, farthest = 0;\n for (let i = 0; i < nums.length - 1; i++) {\n farthest = Math.max(farthest, i + nums[i]);\n if (i === currentEnd) {\n jumps++;\n currentEnd = farthest;\n }\n }\n return jumps;\n}\n",
		"explanation": "This function finds the minimum number of jumps to reach the last index of the array.",
		"category": "Array / String"
	},
	{
		"id": 11,
		"topic": "H-Index",
		"code": "// Calculate H-Index\nfunction hIndex(citations) {\n citations.sort((a, b) => b - a);\n let h = 0;\n while (h < citations.length && citations[h] > h) {\n h++;\n }\n return h;\n}\n",
		"explanation": "This function calculates the H-Index given an array of citations.",
		"category": "Array / String"
	},
	{
		"id": 12,
		"topic": "Insert Delete GetRandom O(1)",
		"code": "// Implement Insert Delete GetRandom O(1)\nclass RandomizedSet {\n constructor() {\n this.map = new Map();\n this.list = [];\n }\n insert(val) {\n if (this.map.has(val)) return false;\n this.map.set(val, this.list.length);\n this.list.push(val);\n return true;\n }\n remove(val) {\n if (!this.map.has(val)) return false;\n let index = this.map.get(val);\n let lastElement = this.list.pop();\n if (index < this.list.length) {\n this.list[index] = lastElement;\n this.map.set(lastElement, index);\n }\n this.map.delete(val);\n return true;\n }\n getRandom() {\n return this.list[Math.floor(Math.random() * this.list.length)];\n }\n}\n",
		"explanation": "This class implements a data structure that supports insert, delete, and getRandom operations in O(1) time.",
		"category": "Array / String"
	},
	{
		"id": 13,
		"topic": "Product of Array Except Self",
		"code": "// Calculate product of array except self\nfunction productExceptSelf(nums) {\n let output = Array(nums.length).fill(1);\n let left = 1, right = 1;\n for (let i = 0; i < nums.length; i++) {\n output[i] *= left;\n left *= nums[i];\n }\n for (let i = nums.length - 1; i >= 0; i--) {\n output[i] *= right;\n right *= nums[i];\n }\n return output;\n}\n",
		"explanation": "This function returns an array where each element is the product of all the elements of the input array except itself.",
		"category": "Array / String"
	},
	{
		"id": 14,
		"topic": "Gas Station",
		"code": "// Find the starting gas station\nfunction canCompleteCircuit(gas, cost) {\n let total = 0, tank = 0, start = 0;\n for (let i = 0; i < gas.length; i++) {\n total += gas[i] - cost[i];\n tank += gas[i] - cost[i];\n if (tank < 0) {\n start = i + 1;\n tank = 0;\n }\n }\n return total >= 0 ? start : -1;\n}\n",
		"explanation": "This function finds the starting gas station index from which you can complete the circuit.",
		"category": "Array / String"
	},
	{
		"id": 15,
		"topic": "Candy",
		"code": "// Distribute candies\nfunction candy(ratings) {\n let candies = Array(ratings.length).fill(1);\n for (let i = 1; i < ratings.length; i++) {\n if (ratings[i] > ratings[i - 1]) {\n candies[i] = candies[i - 1] + 1;\n }\n }\n for (let i = ratings.length - 2; i >= 0; i--) {\n if (ratings[i] > ratings[i + 1]) {\n candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n }\n }\n return candies.reduce((a, b) => a + b, 0);\n}\n",
		"explanation": "This function distributes candies to children such that each child must have at least one candy and children with a higher rating get more candies than their neighbors.",
		"category": "Array / String"
	},
	{
		"id": 16,
		"topic": "Trapping Rain Water",
		"code": "// Calculate trapped rain water\nfunction trap(height) {\n let left = 0, right = height.length - 1;\n let leftMax = 0, rightMax = 0, water = 0;\n while (left < right) {\n if (height[left] < height[right]) {\n height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n left++;\n } else {\n height[right] >= rightMax ? rightMax = height[right] : water += rightMax - height[right];\n right--;\n }\n }\n return water;\n}\n",
		"explanation": "This function calculates the amount of water that can be trapped after raining given an array of heights.",
		"category": "Array / String"
	},
	{
		"id": 17,
		"topic": "Roman to Integer",
		"code": "// Convert Roman numeral to integer\nfunction romanToInt(s) {\n const map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };\n let num = 0;\n for (let i = 0; i < s.length; i++) {\n if (i < s.length - 1 && map[s[i]] < map[s[i + 1]]) {\n num -= map[s[i]];\n } else {\n num += map[s[i]];\n }\n }\n return num;\n}\n",
		"explanation": "This function converts a Roman numeral to an integer.",
		"category": "Array / String"
	},
	{
		"id": 18,
		"topic": "Integer to Roman",
		"code": "// Convert integer to Roman numeral\nfunction intToRoman(num) {\n const map = [\n ['M', 1000], ['CM', 900], ['D', 500], ['CD', 400],\n ['C', 100], ['XC', 90], ['L', 50], ['XL', 40],\n ['X', 10], ['IX', 9], ['V', 5], ['IV', 4], ['I', 1]\n ];\n let roman = '';\n for (let [symbol, value] of map) {\n while (num >= value) {\n roman += symbol;\n num -= value;\n }\n }\n return roman;\n}\n",
		"explanation": "This function converts an integer to a Roman numeral.",
		"category": "Array / String"
	},
	{
		"id": 19,
		"topic": "Length of Last Word",
		"code": "// Find length of last word\nfunction lengthOfLastWord(s) {\n return s.trim().split(' ').pop().length;\n}\n",
		"explanation": "This function returns the length of the last word in a given string.",
		"category": "Array / String"
	},
	{
		"id": 20,
		"topic": "Longest Common Prefix",
		"code": "// Find longest common prefix\nfunction longestCommonPrefix(strs) {\n if (!strs.length) return '';\n let prefix = strs[0];\n for (let i = 1; i < strs.length; i++) {\n while (strs[i].indexOf(prefix) !== 0) {\n prefix = prefix.slice(0, -1);\n if (!prefix) return '';\n }\n }\n return prefix;\n}\n",
		"explanation": "This function finds the longest common prefix string amongst an array of strings.",
		"category": "Array / String"
	},
	{
		"id": 21,
		"topic": "Reverse Words in a String",
		"code": "var reverseWords = function(s) {\n    // Step 1: Trim the string to remove leading and trailing spaces\n    // This ensures we don't have extra spaces that could affect our word separation.\n    // Example: \"  hello world  \" becomes \"hello world\"\n    const trimmedString = s.trim();\n\n    // Step 2: Split the string into words based on spaces\n    // We use the split() method with a regular expression that matches one or more whitespace characters.\n    // The regex /\\s+/ will handle multiple spaces and convert them into an array of words,\n    // effectively filtering out empty strings that might result from consecutive spaces.\n    // Example: \"a good   example\" becomes [\"a\", \"good\", \"example\"]\n    const words = trimmedString.split(/\\s+/);\n\n    // Step 3: Reverse the array of words\n    // By calling reverse(), we change the order of elements in the array,\n    // so the last word becomes the first and vice versa.\n    // Example: [\"a\", \"good\", \"example\"] becomes [\"example\", \"good\", \"a\"]\n    const reversedWords = words.reverse();\n\n    // Step 4: Join the reversed array back into a string with a single space\n    // Using join(\" \"), we concatenate the elements of the array into a single string,\n    // ensuring that words are separated by exactly one space.\n    // Example: [\"example\", \"good\", \"a\"] becomes \"example good a\"\n    return reversedWords.join(\" \");\n};\n\n// Example usage:\nconst input1 = \"the sky is blue\";\nconst output1 = reverseWords(input1);\nconsole.log(output1); // Output: \"blue is sky the\"\n",
		"explanation": "Function Definition: The function `reverseWords` takes a single parameter `s`, which is the input string containing words separated by spaces.<br/>- Trimming the String: <br/>  - We use the `trim()` method to remove any extra spaces from the start and end of the string. <br/>  - This is crucial because leading or trailing spaces do not contribute to the meaningful content of the string and would result in incorrect word splitting.<br/>- Splitting into Words:<br/>  - The `split(/\\s+/)` method takes advantage of a regular expression that matches one or more whitespace characters.<br/>  - This means that any sequence of spaces (including tabs or multiple spaces) between words is treated as a single delimiter.<br/>  - The result is an array of words, with no empty strings, even if there were multiple spaces between them.<br/>- Reversing the Words:<br/>  - The `reverse()` method modifies the original array in place, reversing the order of its elements.<br/>  - This effectively turns the last word into the first one, aligning with the requirement of returning the words in reverse order.<br/>- Joining the Words:<br/>  - Finally, we use `join(\" \")` to combine the elements of the reversed array into a single string, inserting a single space between each word.<br/>  - This ensures that the output format is correct, with only one space separating the words and no extra spaces at the beginning or end.<br/>### Example Cases:<br/>- For the input `\"the sky is blue\"`, the function first trims the string (no change here), splits it into `[\"the\", \"sky\", \"is\", \"blue\"]`, reverses it to `[\"blue\", \"is\", \"sky\", \"the\"]`, and joins it to form `\"blue is sky the\"`.<br/>  <br/>- For the input `\"  hello world  \"`, trimming results in `\"hello world\"`, which splits into `[\"hello\", \"world\"]`, reverses to `[\"world\", \"hello\"]`, and finally joins to produce `\"world hello\"`.<br/>- For the input `\"a good   example\"`, trimming yields `\"a good   example\"`, which splits into `[\"a\", \"good\", \"example\"]`, reverses to `[\"example\", \"good\", \"a\"]`, and joins to give `\"example good a\"`.<br/>This approach is efficient, leveraging built-in JavaScript methods to manipulate strings and arrays while maintaining clarity and conciseness in the code.",
		"category": "Array / String"
	},
	{
		"id": 22,
		"topic": "Zigzag Conversion",
		"code": "// Convert string to zigzag pattern\nfunction convert(s, numRows) {\n if (numRows === 1) return s;\n let rows = Array(Math.min(numRows, s.length)).fill('');\n let curRow = 0, goingDown = false;\n for (let c of s) {\n rows[curRow] += c;\n if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown;\n curRow += goingDown ? 1 : -1;\n }\n return rows.join('');\n}\n",
		"explanation": "This function converts a string to a zigzag pattern on a given number of rows.",
		"category": "Array / String"
	},
	{
		"id": 23,
		"topic": "Find the Index of the First Occurrence in a String",
		"code": "// Find the index of the first occurrence in a string\nfunction strStr(haystack, needle) {\n if (!needle) return 0;\n for (let i = 0; i <= haystack.length - needle.length; i++) {\n if (haystack.slice(i, i + needle.length) === needle) return i;\n }\n return -1;\n}\n",
		"explanation": "This function finds the index of the first occurrence of a substring in a string.",
		"category": "Array / String"
	},
	{
		"id": 24,
		"topic": "Text Justification",
		"code": "// Justify text\nfunction fullJustify(words, maxWidth) {\n let result = [], line = [], lineLength = 0;\n for (let word of words) {\n if (lineLength + word.length + line.length > maxWidth) {\n for (let i = 0; i < maxWidth - lineLength; i++) {\n line[i % (line.length - 1 || 1)] += ' ';\n }\n result.push(line.join(''));\n line = [];\n lineLength = 0;\n }\n line.push(word);\n lineLength += word.length;\n }\n result.push(line.join(' ') + ' '.repeat(maxWidth - lineLength - line.length + 1));\n return result;\n}\n",
		"explanation": "This function justifies text to a given width.",
		"category": "Array / String"
	},
	{
		"id": 25,
		"topic": "Valid Palindrome",
		"code": "var isPalindrome = function(s) {\n    // Remove non-alphanumeric characters and convert to lowercase\n    let cleaned = s.replace(/[^a-z0-9]/gi, '').toLowerCase();\n    \n    // Check if the cleaned string is the same as its reverse\n    return cleaned === cleaned.split('').reverse().join('');\n};\n",
		"explanation": "Explanation:<br/><br/>1. Cleaning the String:<br/>   - The function removes all non-alphanumeric characters using the regular expression /[^a-z0-9]/gi and converts the string to lowercase.<br/>   - /[^a-z0-9]/: Matches any character that is not a letter (a-z) or digit (0-9).<br/>   - g: Global flag ensures all matches are replaced.<br/>   - i: Case-insensitive flag ensures both uppercase and lowercase characters are matched.<br/><br/>2. Palindrome Check:<br/>   - The cleaned string is compared with its reversed version.<br/>   - cleaned.split(''): Splits the string into an array of characters.<br/>   - .reverse(): Reverses the order of characters in the array.<br/>   - .join(''): Joins the reversed characters back into a string.<br/>   - The function returns true if the cleaned string matches its reverse; otherwise, it returns false.",
		"category": "Two Pointers"
	},
	{
		"id": 26,
		"topic": "Is Subsequence",
		"code": "// Check if s is a subsequence of t\nvar isSubsequence = function(s, t) {\n let i = 0, j = 0;\n \n // Traverse string t to find characters of string s in order\n while (i < s.length && j < t.length) {\n console.log(`Comparing s[${i}] = '${s[i]}' with t[${j}] = '${t[j]}'`);\n \n if (s[i] === t[j]) {\n console.log(`Match found! Incrementing i to ${i + 1}`);\n i++; // Move pointer for s when there's a match\n }\n \n // Always move pointer for t\n j++;\n console.log(`Incrementing j to ${j}`);\n }\n \n // If all characters in s are found in order in t, return true\n console.log(`Final value of i: ${i}, length of s: ${s.length}`);\n return i === s.length;\n};\n\n// Optimized solution\n// Preprocess t and store the positions of each character\nvar preprocess = function(t) {\nconst positions = new Map();\nfor (let i = 0; i < t.length; i++) {\nif (!positions.has(t[i])) {\npositions.set(t[i], []);\n}\npositions.get(t[i]).push(i);\n}\nreturn positions;\n};\n\n// Check if s is a subsequence of t using binary search\nvar isSubsequence = function(s, t) {\nconst positions = preprocess(t);\nlet prevIndex = -1;\n\nTraverse each character in s\nfor (let char of s) {\nif (!positions.has(char)) {\nreturn false; // If t doesn't contain this character, return false\n// }\n\nconst indices = positions.get(char);\n\n// Use binary search to find the smallest index in indices that is greater than prevIndex\nlet left = 0, right = indices.length - 1;\nlet found = false;\n\nwhile (left <= right) {\nconst mid = Math.floor((left + right) / 2);\nif (indices[mid] > prevIndex) {\nfound = true;\nprevIndex = indices[mid];\nright = mid - 1;\n} else {\nleft = mid + 1;\n}\n}\n\n// If no valid index is found, return false\nif (!found) {\nreturn false;\n}\n}\n\nreturn true;\n};\n",
		"explanation": "Explanation:<br/><br/>- We start by initializing two pointers: `i` for string `s` and `j` for string `t`.<br/>- We loop through string `t` using the pointer `j`. For each character in `t`, we check if it matches the current character in `s` (pointed to by `i`).<br/>- If a match is found (`s[i] === t[j]`), we increment `i` to check the next character in `s`.<br/>- Regardless of a match, we always increment `j` to continue traversing `t`.<br/>- If we manage to find all characters of `s` in order within `t`, `i` will reach the end of `s`, and we return `true`.<br/>- If not, we return `false`.<br/><br/>Time Complexity:<br/>- The time complexity is O(n), where `n` is the length of string `t`, since we only traverse string `t` once.<br/><br/>Space Complexity:<br/>- The space complexity is O(1), since we only use a few variables (`i` and `j`) for the pointers.<br/><br/><br/>Optimized Explanation:<br/><br/>1. We preprocess `t` into a map where the key is the character and the value is a list of indices where that character appears in `t`.<br/>2. For each string `s`, we use binary search to find the next available position in `t` where each character in `s` appears after the previously found character.<br/>3. If we can't find a character in the required order, return `false`.<br/>4. If we find all characters of `s` in order, return `true`.<br/><br/>Time Complexity:<br/>- Preprocessing `t`: O(n), where `n` is the length of `t`.<br/>- For each string `s`, checking if it’s a subsequence takes O(m * log n), where `m` is the length of `s` and `n` is the length of `t`. This is because we use binary search on the list of indices for each character of `s`.<br/><br/>Space Complexity:<br/>- O(n), where `n` is the length of `t`, for storing the positions of characters.",
		"category": "Two Pointers"
	},
	{
		"id": 27,
		"topic": "Two Sum II - Input Array Is Sorted",
		"code": "// Find two numbers that add up to a specific target\nfunction twoSum(numbers, target) {\n let left = 0, right = numbers.length - 1;\n while (left < right) {\n let sum = numbers[left] + numbers[right];\n if (sum === target) return [left + 1, right + 1];\n else if (sum < target) left++;\n else right--;\n }\n return [];\n}\n",
		"explanation": "This function finds two numbers in a sorted array that add up to a specific target and returns their indices.",
		"category": "Two Pointers"
	},
	{
		"id": 28,
		"topic": "Container With Most Water",
		"code": "// Find the container with the most water\nfunction maxArea(height) {\n let left = 0, right = height.length - 1, maxArea = 0;\n while (left < right) {\n let width = right - left;\n let h = Math.min(height[left], height[right]);\n maxArea = Math.max(maxArea, width * h);\n if (height[left] < height[right]) left++;\n else right--;\n }\n return maxArea;\n}\n",
		"explanation": "This function finds the container that can hold the most water given an array of heights.",
		"category": "Two Pointers"
	},
	{
		"id": 29,
		"topic": "3Sum",
		"code": "var threeSum = function(nums) {\n    console.log(\"Input array:\", nums);\n    \n    // Sort the array to simplify finding duplicates and using the two-pointer approach\n    nums.sort((a, b) => a - b);\n    console.log(\"Sorted array:\", nums);\n\n    const result = [];\n    const n = nums.length;\n\n    // Iterate through the array, fixing the first number of the triplet\n    for (let i = 0; i < n - 2; i++) {\n        // Explanation: We use `i < n - 2` because we need at least two numbers after `nums[i]`\n        // to form a triplet. If `i` were to reach `n - 2`, there wouldn't be enough numbers \n        // remaining in the array to form a valid triplet.\n        \n        // Skip duplicates for the first number\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            // console.log(`Skipping duplicate for nums[${i}] = ${nums[i]}`);\n            continue;\n        }\n\n        // Create two pointers: one at the element right after the current one (left)\n        // and one at the last element (right). These pointers will be used to find pairs\n        // that, together with nums[i], sum up to zero.\n        let left = i + 1;\n        let right = n - 1;\n\n        // console.log(`Processing nums[${i}] = ${nums[i]}`);\n\n        while (left < right) {\n            // Combination of current triplet\n            const sum = nums[i] + nums[left] + nums[right];\n            // console.log(`Checking combination: ${nums[i]}, ${nums[left]}, ${nums[right]} (sum = ${sum})`);\n\n            if (sum === 0) {\n                // console.log(`Found triplet: [${nums[i]}, ${nums[left]}, ${nums[right]}]`);\n                \n                // Found a valid triplet: add it to the result array\n                result.push([nums[i], nums[left], nums[right]]);\n                // Move the left pointer to the right, skipping any duplicates\n                left++;\n                // Move the right pointer to the left, skipping any duplicates\n                right--;\n\n                // Skip duplicates for the second number\n                while (left < right && nums[left] === nums[left - 1]) {\n                    // console.log(`Skipping duplicate for nums[${left}] = ${nums[left]}`);\n                    left++;\n                }\n                \n                // Skip duplicates for the third number\n                while (left < right && nums[right] === nums[right + 1]) {\n                    // console.log(`Skipping duplicate for nums[${right}] = ${nums[right]}`);\n                    right--;\n                }\n            } else if (sum < 0) {\n                // console.log(`Sum < 0, incrementing left pointer from ${left} to ${left + 1}`);\n                \n                // If the sum is less than 0, we need a larger number to increase the sum\n                // So, move the left pointer to the right (left++)\n                left++;\n            } else {\n                // console.log(`Sum > 0, decrementing right pointer from ${right} to ${right - 1}`);\n                \n                // If the sum is greater than 0, we need a smaller number to decrease the sum\n                // So, move the right pointer to the left (right--)\n                right--;\n            }\n        }\n    }\n\n    console.log(\"Final result:\", result);\n    return result;\n};\n",
		"explanation": "Explanation:<br/><br/>1. Input array: [-1, 0, 1, 2, -1, -4]<br/>   After sorting: [-4, -1, -1, 0, 1, 2]<br/><br/>2. Iterate through the array and fix the first number of the triplet.<br/><br/>3. Use two pointers (left and right) to find pairs of numbers that, when added to the first number, result in zero:<br/>   - Left pointer:<br/>     - Starts just after the current index `i` (`left = i + 1`).<br/>     - Moves forward (`left++`) if the sum of the triplet is less than zero, since the sorted order means larger numbers are needed to increase the sum.<br/>   - Right pointer:<br/>     - Starts at the last index (`right = n - 1`).<br/>     - Moves backward (`right--`) if the sum of the triplet is greater than zero, since the sorted order means smaller numbers are needed to decrease the sum.<br/>   - Together:<br/>     - `left` and `right` explore all possible pairs for the current `nums[i]`.<br/>     - If the sum of the triplet matches zero, the combination is valid, and both pointers adjust to skip duplicates.<br/>     - The process continues until `left` and `right` pointers overlap, completing all pair possibilities for the current `nums[i]`.<br/><br/>4. If a triplet is found, store it in the result array and adjust the pointers while skipping duplicates.<br/><br/>5. If the sum is less than zero, increment the left pointer to increase the sum.<br/><br/>6. If the sum is greater than zero, decrement the right pointer to decrease the sum.<br/><br/>7. Repeat this process for all elements in the array.<br/><br/>8. Return the final list of unique triplets: [[-1, -1, 2], [-1, 0, 1]].",
		"category": "Two Pointers"
	},
	{
		"id": 30,
		"topic": "Minimum Size Subarray Sum",
		"code": "var minSubArrayLen = function(target, nums) {\n    // Start of the sliding window\n    let left = 0;\n    // Current sum of the numbers within the window\n    let sum = 0; \n    // To store the minimum length of a valid subarray\n    let minLength = Infinity; \n\n    // Iterate through the array with the right pointer\n    for (let right = 0; right < nums.length; right++) {\n        // Add the current element to the sum\n        sum += nums[right]; \n\n        // While the current sum is greater than or equal to the target\n        while (sum >= target) {\n            // Calculate the length of the current subarray\n            let currentLength = right - left + 1;\n            // Update minLength with the smaller value between currentLength and minLength\n            minLength = Math.min(minLength, currentLength);\n            // Shrink the window from the left\n            sum -= nums[left];\n            // Move the left pointer forward\n            left++; \n        }\n    }\n\n    // If no valid subarray was found, return 0; otherwise, return minLength\n    return minLength === Infinity ? 0 : minLength;\n};\n",
		"explanation": "Explanation:<br/><br/>1. **Definition of a window**:<br/>   - A **window** refers to a contiguous segment of the array defined by two pointers: the `left` pointer (start of the window) and the `right` pointer (end of the window).<br/>   - The elements within the window are those between the `left` and `right` indices, inclusive.<br/><br/>2. **How the window works**:<br/>   - The `right` pointer expands the window by including new elements from the array into the sum.<br/>   - The `left` pointer shrinks the window by excluding elements from the sum when the condition (sum >= target) is met.<br/>   - This dynamic adjustment ensures the algorithm considers all possible valid subarrays efficiently.<br/><br/>3. **Algorithm steps**:<br/>   - Start with an empty window (`left = 0` and `right = 0`) and a `sum = 0`.<br/>   - Expand the window by moving the `right` pointer and adding elements to `sum`.<br/>   - If the `sum` of the window meets or exceeds the `target`, calculate the window's length (`right - left + 1`).<br/>   - Update `minLength` if the current window is shorter than the previously found windows.<br/>   - Shrink the window by moving the `left` pointer forward and subtracting the excluded element from `sum`.<br/>   - Continue until the entire array is processed.<br/><br/>4. **Final result**:<br/>   - If no valid subarray is found (i.e., `minLength` remains `Infinity`), return 0.<br/>   - Otherwise, return the smallest length found.<br/><br/>Time Complexity: O(n) - Each element is visited at most twice (once by `right` and once by `left`).<br/>Space Complexity: O(1) - Only constant space is used.",
		"category": "Sliding Window"
	},
	{
		"id": 31,
		"topic": "Longest Substring Without Repeating Characters",
		"code": "// Find the length of the longest substring without repeating characters\nfunction lengthOfLongestSubstring(s) {\n let map = new Map(), left = 0, maxLength = 0;\n for (let right = 0; right < s.length; right++) {\n if (map.has(s[right])) left = Math.max(map.get(s[right]) + 1, left);\n map.set(s[right], right);\n maxLength = Math.max(maxLength, right - left + 1);\n }\n return maxLength;\n}\n",
		"explanation": "This function finds the length of the longest substring without repeating characters.",
		"category": "Sliding Window"
	},
	{
		"id": 32,
		"topic": "Substring with Concatenation of All Words",
		"code": "// Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once\nfunction findSubstring(s, words) {\n if (!s || !words || !words.length) return [];\n let wordLength = words[0].length, wordCount = words.length, totalLength = wordLength * wordCount;\n let wordMap = new Map();\n for (let word of words) wordMap.set(word, (wordMap.get(word) || 0) + 1);\n let result = [];\n for (let i = 0; i < wordLength; i++) {\n let left = i, right = i, count = 0, currentMap = new Map();\n while (right + wordLength <= s.length) {\n let word = s.slice(right, right + wordLength);\n right += wordLength;\n if (wordMap.has(word)) {\n currentMap.set(word, (currentMap.get(word) || 0) + 1);\n count++;\n while (currentMap.get(word) > wordMap.get(word)) {\n let leftWord = s.slice(left, left + wordLength);\n currentMap.set(leftWord, currentMap.get(leftWord) - 1);\n count--;\n left += wordLength;\n }\n if (count === wordCount) result.push(left);\n } else {\n currentMap.clear();\n count = 0;\n left = right;\n }\n }\n }\n return result;\n}\n",
		"explanation": "This function finds all starting indices of substring(s) in s that is a concatenation of each word in words exactly once.",
		"category": "Sliding Window"
	},
	{
		"id": 33,
		"topic": "Minimum Window Substring",
		"code": "// Find the minimum window substring\nfunction minWindow(s, t) {\n let map = new Map();\n for (let char of t) map.set(char, (map.get(char) || 0) + 1);\n let left = 0, right = 0, count = t.length, minLength = Infinity, minStart = 0;\n while (right < s.length) {\n if (map.get(s[right]) > 0) count--;\n map.set(s[right], (map.get(s[right]) || 0) - 1);\n right++;\n while (count === 0) {\n if (right - left < minLength) {\n minLength = right - left;\n minStart = left;\n }\n map.set(s[left], (map.get(s[left]) || 0) + 1);\n if (map.get(s[left]) > 0) count++;\n left++;\n }\n }\n return minLength === Infinity ? '' : s.slice(minStart, minStart + minLength);\n}\n",
		"explanation": "This function finds the minimum window substring in s that contains all the characters in t.",
		"category": "Sliding Window"
	},
	{
		"id": 34,
		"topic": "Valid Sudoku",
		"code": "var isValidSudoku = function(board) {\n    // Create sets to track seen numbers in rows, columns, and sub-boxes\n    let rows = new Array(9).fill(null).map(() => new Set());\n    let cols = new Array(9).fill(null).map(() => new Set());\n    let boxes = new Array(9).fill(null).map(() => new Set());\n    \n    // Iterate through each cell in the 9x9 board\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            let num = board[i][j];\n            \n            // If the cell is not empty\n            if (num !== '.') {\n                // Calculate the index of the sub-box (0-8)\n                let boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);\n                \n                // Log the current number and its position\n                console.log(`Checking number ${num} at position [${i}, ${j}]`);\n                \n                // Check if the number has already appeared in the row, column, or sub-box\n                if (rows[i].has(num)) {\n                    console.log(`Duplicate found in row ${i}: ${num}`);\n                    return false;\n                }\n                if (cols[j].has(num)) {\n                    console.log(`Duplicate found in column ${j}: ${num}`);\n                    return false;\n                }\n                if (boxes[boxIndex].has(num)) {\n                    console.log(`Duplicate found in box ${boxIndex}: ${num}`);\n                    return false;\n                }\n                \n                // Add the number to the respective row, column, and sub-box sets\n                rows[i].add(num);\n                cols[j].add(num);\n                boxes[boxIndex].add(num);\n                \n                // Log the addition of the number\n                console.log(`Added number ${num} to row ${i}, column ${j}, box ${boxIndex}`);\n            }\n        }\n    }\n    \n    // If no duplicates are found, the board is valid\n    console.log('The board is valid');\n    return true;\n};\n\n// Test case 1: Valid Sudoku\nlet board1 = [\n    [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n    [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n    [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n    [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n    [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n    [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n    [\".\", \"6\", \".\", \".\", \".\", \".\", \"2\", \"8\", \".\"],\n    [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n    [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n];\nconsole.log(isValidSudoku(board1));  // Expected output: true\n",
		"explanation": "Explanation:<br/><br/>1. Sets Creation:<br/>   - Creates sets for each row, column, and 3x3 sub-box to track seen numbers.<br/><br/>2. Loop through the Board:<br/>   - Iterates through each cell in the 9x9 Sudoku grid.<br/><br/>3. Check for Duplicates:<br/>   - For each non-empty cell, checks if the number has already appeared in the same row, column, or sub-box.<br/><br/>4. Return False on Duplicate:<br/>   - If a duplicate is found, logs the duplicate's position and returns false (indicating an invalid Sudoku board).<br/><br/>5. Track Seen Numbers:<br/>   - If no duplicates are found, adds the number to the respective row, column, and sub-box set.<br/><br/>6. Return True if Valid:<br/>   - If the entire board is checked without finding duplicates, returns true (indicating a valid Sudoku board).",
		"category": "Matrix"
	},
	{
		"id": 35,
		"topic": "Spiral Matrix",
		"code": "// Return all elements of the matrix in spiral order\nfunction spiralOrder(matrix) {\n let result = [];\n if (matrix.length === 0) return result;\n let top = 0, bottom = matrix.length - 1;\n let left = 0, right = matrix[0].length - 1;\n while (top <= bottom && left <= right) {\n for (let i = left; i <= right; i++) result.push(matrix[top][i]);\n top++;\n for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n right--;\n if (top <= bottom) {\n for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);\n bottom--;\n }\n if (left <= right) {\n for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n left++;\n }\n }\n return result;\n}\n",
		"explanation": "This function returns all elements of the matrix in spiral order.",
		"category": "Matrix"
	},
	{
		"id": 36,
		"topic": "Rotate Image",
		"code": "// Rotate the image by 90 degrees (clockwise)\nfunction rotate(matrix) {\n let n = matrix.length;\n for (let i = 0; i < n; i++) {\n for (let j = i; j < n; j++) {\n [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n }\n }\n for (let i = 0; i < n; i++) {\n matrix[i].reverse();\n }\n}\n",
		"explanation": "This function rotates the image (matrix) by 90 degrees clockwise.",
		"category": "Matrix"
	},
	{
		"id": 37,
		"topic": "Set Matrix Zeroes",
		"code": "// Set matrix zeroes\nfunction setZeroes(matrix) {\n let rows = new Set(), cols = new Set();\n for (let r = 0; r < matrix.length; r++) {\n for (let c = 0; c < matrix[0].length; c++) {\n if (matrix[r][c] === 0) {\n rows.add(r);\n cols.add(c);\n }\n }\n }\n for (let r of rows) {\n for (let c = 0; c < matrix[0].length; c++) {\n matrix[r][c] = 0;\n }\n }\n for (let c of cols) {\n for (let r = 0; r < matrix.length; r++) {\n matrix[r][c] = 0;\n }\n }\n}\n",
		"explanation": "This function sets the entire row and column to zeroes if an element is zero.",
		"category": "Matrix"
	},
	{
		"id": 38,
		"topic": "Game of Life",
		"code": "// Implement the Game of Life\nfunction gameOfLife(board) {\n const directions = [[0, 1], [1, 0], [1, 1], [1, -1], [-1, 0], [-1, 1], [-1, -1], [0, -1]];\n const copyBoard = board.map(arr => [...arr]);\n for (let r = 0; r < board.length; r++) {\n for (let c = 0; c < board[0].length; c++) {\n let liveNeighbors = 0;\n for (let [dr, dc] of directions) {\n let nr = r + dr, nc = c + dc;\n if (nr >= 0 && nr < board.length && nc >= 0 && nc < board[0].length && copyBoard[nr][nc] === 1) {\n liveNeighbors++;\n }\n }\n if (copyBoard[r][c] === 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n board[r][c] = 0;\n }\n if (copyBoard[r][c] === 0 && liveNeighbors === 3) {\n board[r][c] = 1;\n }\n }\n }\n}\n",
		"explanation": "This function implements the Game of Life according to the rules.",
		"category": "Matrix"
	},
	{
		"id": 39,
		"topic": "Ransom Note",
		"code": "// Check if ransom note can be constructed from magazine\nfunction canConstruct(ransomNote, magazine) {\n let map = new Map();\n for (let char of magazine) {\n map.set(char, (map.get(char) || 0) + 1);\n }\n for (let char of ransomNote) {\n if (!map.has(char) || map.get(char) === 0) return false;\n map.set(char, map.get(char) - 1);\n }\n return true;\n}\n",
		"explanation": "This function checks if a ransom note can be constructed from the letters in a magazine.",
		"category": "Hashmap"
	},
	{
		"id": 40,
		"topic": "Isomorphic Strings",
		"code": "// Check if two strings are isomorphic\nfunction isIsomorphic(s, t) {\n let mapS = new Map(), mapT = new Map();\n for (let i = 0; i < s.length; i++) {\n let charS = s[i], charT = t[i];\n if ((mapS.has(charS) && mapS.get(charS) !== charT) || (mapT.has(charT) && mapT.get(charT) !== charS)) return false;\n mapS.set(charS, charT);\n mapT.set(charT, charS);\n }\n return true;\n}\n",
		"explanation": "This function checks if two strings are isomorphic.",
		"category": "Hashmap"
	},
	{
		"id": 41,
		"topic": "Word Pattern",
		"code": "function wordPattern(pattern, s) {\n // Split the string s into an array of words. This creates an array where each element is a word from the input string.\n const words = s.split(' ');\n // If the number of elements in the pattern does not match the number of words, return false.\n // This is a quick check to ensure that the one-to-one mapping can exist.\n if (pattern.length !== words.length) { // If lengths are different, the pattern cannot match the words.\n return false; \n }\n // Initialize two maps to store the character-to-word and word-to-character correspondences.\n // These maps will help track what each character in the pattern maps to and vice versa.\n const charToWordMap = new Map();\n const wordToCharMap = new Map();\n // This loop goes through each character in the pattern and its corresponding word in the words array.\n for (let i = 0; i < pattern.length; ++i) {\n const char = pattern[i]; // Current character from the pattern.\n const word = words[i]; // Current word from the string.\n // Check if the current character is already associated with a different word. If the character is already in the charToWordMap and it maps \n // to a word different from the current one, it indicates a conflict in mapping and thus the pattern cannot match.\n if (charToWordMap.has(char)) {\n if (charToWordMap.get(char) !== word) {\n return false; // Mismatch found, return false.\n }\n }\n // Check if the current word is already associated with a different character. Similar to the previous check, if the word is already mapped \n // to a character different from the current one,this also indicates a conflict.\n if (wordToCharMap.has(word)) {\n if (wordToCharMap.get(word) !== char) {\n return false; // Mismatch found, return false.\n }\n }\n // Add the current character-to-word and word-to-character association to the maps. If no conflicts were found, we can safely set the \n //mapping for both the character and the word.\n charToWordMap.set(char, word);\n wordToCharMap.set(word, char);\n }\n // If no mismatch was found, return true. This means all characters and words have been successfully mapped without any conflicts.\n return true;\n}\n// Example usage\nconsole.log(wordPattern(\"abba\", \"dog cat cat dog\")); // Output: true\nconsole.log(wordPattern(\"abba\", \"dog cat cat fish\")); // Output: false\nconsole.log(wordPattern(\"aaaa\", \"dog cat cat dog\")); // Output: false\nconsole.log(wordPattern(\"abba\", \"dog constructor constructor dog\")); // Output: true\n",
		"explanation": "1. Input Parameters:<br/>   - `pattern`: A string where each character represents a pattern to match.<br/>   - `s`: A string where words are expected to correspond to characters in `pattern`.<br/><br/>2. Splitting the Input String:<br/>   - `s.split(' ')` splits the string `s` into an array of words using spaces as separators.<br/><br/>3. Quick Length Check:<br/>   - If the length of the `pattern` does not match the number of words in `s`, we return `false` immediately, as no one-to-one mapping can exist.<br/><br/>4. Maps for Mappings:<br/>   - `charToWordMap`: A map that tracks the mapping of characters from `pattern` to words.<br/>   - `wordToCharMap`: A map that tracks the reverse mapping, ensuring no word is assigned to more than one character.<br/><br/>5. Iteration over the Pattern:<br/>   - The function iterates through each character in `pattern` and its corresponding word in `words`:<br/>     - If the character is already mapped to a different word, it returns `false`.<br/>     - If the word is already mapped to a different character, it also returns `false`.<br/><br/>6. Returning the Result:<br/>   - If no conflicts are found after checking all the mappings, the function returns `true`, indicating a consistent one-to-one mapping exists between the pattern and the words.<br/><br/>7. Example Outputs:<br/>   - `\"abba\", \"dog cat cat dog\"` → `true`: The mapping is consistent (a → dog, b → cat).<br/>   - `\"abba\", \"dog cat cat fish\"` → `false`: The word \"fish\" doesn't match the expected \"dog\" for the first \"a\".<br/>   - `\"aaaa\", \"dog cat cat dog\"` → `false`: The word \"cat\" can't map to multiple characters.",
		"category": "Hashmap"
	},
	{
		"id": 42,
		"topic": "Valid Anagram",
		"code": "// Check if two strings are anagrams\nfunction isAnagram(s, t) {\n if (s.length !== t.length) return false;\n let map = new Map();\n for (let char of s) {\n map.set(char, (map.get(char) || 0) + 1);\n }\n for (let char of t) {\n if (!map.has(char) || map.get(char) === 0) return false;\n map.set(char, map.get(char) - 1);\n }\n return true;\n}\n",
		"explanation": "This function checks if two strings are anagrams.",
		"category": "Hashmap"
	},
	{
		"id": 43,
		"topic": "Group Anagrams",
		"code": "// Group anagrams\nfunction groupAnagrams(strs) {\n let map = new Map();\n for (let str of strs) {\n let sortedStr = str.split('').sort().join('');\n if (!map.has(sortedStr)) map.set(sortedStr, []);\n map.get(sortedStr).push(str);\n }\n return Array.from(map.values());\n}\n",
		"explanation": "This function groups anagrams together.",
		"category": "Hashmap"
	},
	{
		"id": 44,
		"topic": "Two Sum",
		"code": "var twoSum = function (nums, target) {\n    // Initialize a hash map to store elements and their indices\n    const map = new Map();\n\n    // Loop through the array with index `i`\n    for (let i = 0; i < nums.length; i++) {\n        // Calculate the complement that we need to reach the target\n        const complement = target - nums[i];\n\n        // Check if the complement is in the map\n        if (map.has(complement)) {\n            // If found, return the indices [map.get(complement), i]\n            return [map.get(complement), i];\n        }\n\n        // Store the current element with its index in the map\n        map.set(nums[i], i);\n    }\n\n    // Return an empty array if no solution is found (though the problem guarantees one solution exists)\n    return [];\n};\n",
		"explanation": "Explanation of Each Step:<br/><br/>1. Hash Map Initialization:<br/>   - We initialize an empty map to store each number and its index as we iterate through `nums`.<br/><br/>2. Looping Through nums:<br/>   - For each number `nums[i]`, we calculate the `complement`, which is the difference between the `target` and `nums[i]`.<br/>   - We check if this `complement` exists in the map. If it does, it means that we have previously encountered a number that pairs with `nums[i]` to reach the target.<br/><br/>3. Returning the Solution:<br/>   - If the complement is found in the map, we return the indices of the two numbers: `[map.get(complement), i]`.<br/>   - If the complement is not found, we store the current number and its index in the map to check against future elements.<br/><br/>4. Complexity:<br/>   - **Time Complexity**: O(n) since we only iterate through the array once.<br/>   - **Space Complexity**: O(n) due to the hash map storing up to n elements.",
		"category": "Hashmap"
	},
	{
		"id": 45,
		"topic": "Happy Number",
		"code": "var isHappy = function(n) {\n    // A set to track previously encountered numbers to detect cycles\n    let seen = new Set();\n\n    // Loop until n becomes 1 (happy) or we detect a cycle (repeated number)\n    while (n !== 1) {\n        console.log(`Current number: ${n}`);\n\n        // If the number has been seen before, it means we're in a cycle\n        if (seen.has(n)) {\n            console.log(`Cycle detected: ${n} has already been seen.`);\n            return false;\n        }\n\n        // Add the current number to the set to track it\n        seen.add(n);\n\n        // Calculate the sum of the squares of the digits of n\n        let sumOfSquares = 0;\n        let temp = n; // Temporary variable to calculate sum of squares\n        while (temp > 0) {\n            let digit = temp % 10;            // Extract the last digit of n\n            sumOfSquares += digit * digit;    // Add the square of the digit to the sum\n            temp = Math.floor(temp / 10);     // Remove the last digit from n\n        }\n\n        // Log the sum of squares of digits\n        console.log(`Sum of squares of digits: ${sumOfSquares}`);\n\n        // Update n to the sum of the squares of its digits\n        n = sumOfSquares;\n    }\n\n    // If n reaches 1, it's a happy number\n    console.log(`Happy number found: ${n}`);\n    return true;\n};\n",
		"explanation": "Explanation:<br/><br/>1. The set `seen` is used to track numbers we've already encountered, allowing us to detect cycles.<br/><br/>2. The number `n` is repeatedly replaced with the sum of the squares of its digits.<br/><br/>3. If `n` becomes 1, the function returns true, indicating it is a happy number.<br/><br/>4. If `n` repeats (cycle detected), the function returns false, indicating it's not a happy number.",
		"category": "Hashmap"
	},
	{
		"id": 46,
		"topic": "Contains Duplicate II",
		"code": "// Check if the array contains duplicates within k distance\nfunction containsNearbyDuplicate(nums, k) {\n let map = new Map();\n for (let i = 0; i < nums.length; i++) {\n if (map.has(nums[i]) && i - map.get(nums[i]) <= k) return true;\n map.set(nums[i], i);\n }\n return false;\n}\n",
		"explanation": "This function checks if the array contains duplicates within k distance.",
		"category": "Hashmap"
	},
	{
		"id": 47,
		"topic": "Longest Consecutive Sequence",
		"code": "// Find the length of the longest consecutive sequence\nfunction longestConsecutive(nums) {\n let set = new Set(nums);\n let maxLength = 0;\n for (let num of nums) {\n if (!set.has(num - 1)) {\n let length = 0;\n while (set.has(num + length)) length++;\n maxLength = Math.max(maxLength, length);\n }\n }\n return maxLength;\n}\n",
		"explanation": "This function finds the length of the longest consecutive sequence in an array.",
		"category": "Hashmap"
	},
	{
		"id": 48,
		"topic": "Summary Ranges",
		"code": "// Find summary ranges\nvar summaryRanges = function(nums) {\n    // Edge case: If the input array is empty, return an empty array.\n    if (nums.length === 0) return [];\n\n    let result = []; // Array to store the resulting ranges.\n    let start = nums[0]; // Starting number of the current range.\n\n    // Log initial values.\n    console.log(\"Initial nums array:\", nums);\n\n    // Iterate through the array starting from the second element.\n    for (let i = 1; i <= nums.length; i++) {\n        // Log the current iteration details.\n        console.log(`Iteration ${i}: Current number = ${nums[i-1]}, Start = ${start}`);\n\n        // Check if we are at the end of the array or if the current number is not consecutive.\n        if (i === nums.length || nums[i] !== nums[i - 1] + 1) {\n            // Log range detection.\n            console.log(`Range detected from ${start} to ${nums[i - 1]}`);\n\n            // Determine the range and add it to the result.\n            if (start === nums[i - 1]) {\n                result.push(`${start}`); // Single number range.\n                console.log(`Added single number: ${start}`);\n            } else {\n                result.push(`${start}->${nums[i - 1]}`); // Continuous range.\n                console.log(`Added range: ${start}->${nums[i - 1]}`);\n            }\n\n            // Update `start` for the next range.\n            if (i < nums.length) start = nums[i];\n            console.log(`Updated start for next range: ${start}`);\n        }\n    }\n    console.log(\"Final result:\", result);\n\n    return result;\n};\n",
		"explanation": "Explanation:<br/>1. Initialization:<br/>   - We set `start` to the first element of the `nums` array, marking the beginning of the first range.<br/><br/>2. Loop through the Array:<br/>   - We iterate through the `nums` array starting from the second element.<br/>   - In each iteration:<br/>     - We check if the current number is consecutive to the previous one. If not, this indicates the end of the current range.<br/>     - We construct the range and add it to the `result` array in the appropriate format:<br/>       - If `start` equals `nums[i - 1]`, we add the single number range `start`.<br/>       - Otherwise, we add the continuous range in the format `start->nums[i - 1]`.<br/>     - We update `start` to `nums[i]` if `i < nums.length` to prepare for the next range.<br/><br/>3. Edge Case Handling:<br/>   - If the array is empty, we return an empty array.<br/><br/>Example Walkthrough:<br/>- For input `nums = [0,1,2,4,5,7]`:<br/>  - We start with `start = 0` and form the range \"0->2\".<br/>  - Next, `4, 5` form the range \"4->5\".<br/>  - Finally, `7` is a single number, so we add \"7\" to the result.<br/>  - The resulting array is [\"0->2\", \"4->5\", \"7\"].<br/><br/>- For input `nums = [0,2,3,4,6,8,9]`:<br/>  - The first number is `0`, so the range is \"0\".<br/>  - `2, 3, 4` form the range \"2->4\".<br/>  - `6` is a single number, so we add \"6\" to the result.<br/>  - `8, 9` form the range \"8->9\".<br/>  - The resulting array is [\"0\", \"2->4\", \"6\", \"8->9\"].<br/><br/>Time and Space Complexity:<br/>- Time Complexity: O(n), where `n` is the number of elements in `nums`. We iterate through the array once.<br/>- Space Complexity: O(k), where `k` is the number of ranges in the result array. In the worst case, this is O(n) if there are no consecutive numbers.",
		"category": "Intervals"
	},
	{
		"id": 49,
		"topic": "Merge Intervals",
		"code": "// Merge overlapping intervals\nfunction merge(intervals) {\n if (!intervals.length) return [];\n intervals.sort((a, b) => a[0] - b[0]);\n let merged = [intervals[0]];\n for (let i = 1; i < intervals.length; i++) {\n let [prevStart, prevEnd] = merged[merged.length - 1];\n let [currStart, currEnd] = intervals[i];\n if (currStart <= prevEnd) {\n merged[merged.length - 1][1] = Math.max(prevEnd, currEnd);\n } else {\n merged.push(intervals[i]);\n }\n }\n return merged;\n}\n",
		"explanation": "This function merges overlapping intervals in an array.",
		"category": "Intervals"
	},
	{
		"id": 50,
		"topic": "Insert Interval",
		"code": "// Insert a new interval into a list of non-overlapping intervals\nfunction insert(intervals, newInterval) {\n let result = [];\n let i = 0;\n while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n result.push(intervals[i++]);\n }\n while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n i++;\n }\n result.push(newInterval);\n while (i < intervals.length) {\n result.push(intervals[i++]);\n }\n return result;\n}\n",
		"explanation": "This function inserts a new interval into a list of non-overlapping intervals and merges if necessary.",
		"category": "Intervals"
	},
	{
		"id": 51,
		"topic": "Minimum Number of Arrows to Burst Balloons",
		"code": "// Find the minimum number of arrows to burst all balloons\nfunction findMinArrowShots(points) {\n if (!points.length) return 0;\n points.sort((a, b) => a[1] - b[1]);\n let arrows = 1, end = points[0][1];\n for (let i = 1; i < points.length; i++) {\n if (points[i][0] > end) {\n arrows++;\n end = points[i][1];\n }\n }\n return arrows;\n}\n",
		"explanation": "This function finds the minimum number of arrows required to burst all balloons represented as intervals.",
		"category": "Intervals"
	},
	{
		"id": 52,
		"topic": "Valid Parentheses",
		"code": "// Check if the parentheses are valid\nconst isValid = function(s) {\n     console.log(\"Initial Stack:\", s);\n    // Stack to keep track of opening brackets\n    const stack = [];\n    // Map to match closing brackets with their respective opening brackets\n    const matchingBrackets = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n    \n    for (let char of s) {\n        if (char === '(' || char === '{' || char === '[') {\n            // Push opening brackets onto the stack\n            stack.push(char);\n            console.log(`Pushed ${char} onto the stack:`, stack);\n        } else {\n            // Check if the stack is empty or if the top of the stack doesn't match\n            if (stack.length === 0) {\n                console.log(`Stack is empty when encountering ${char}`);\n                return false;\n            }\n            if (stack[stack.length - 1] !== matchingBrackets[char]) {\n                console.log(`Mismatch found: expected ${matchingBrackets[char]}, found ${char}`);\n                return false;\n            }\n            // Pop the matched opening bracket\n            console.log(`Popped ${stack[stack.length - 1]} for ${char}`);\n            stack.pop();\n        }\n    }\n    \n    // Final state of the stack\n    console.log(\"Final stack state:\", stack);\n    // If the stack is empty, all brackets were matched correctly\n    return stack.length === 0;\n};\n\n// Example usage\nconsole.log(\"true?: \", isValid(\"()[]{}\"));  // Expected output: true\nconsole.log(\"false?: \", isValid(\"(]\"));      // Expected output: false\nconsole.log(\"true?: \", isValid(\"([{}])\"));  // Expected output: true\nconsole.log(\"false?: \", isValid(\"((()))]\")); // Expected output: false\n",
		"explanation": "Explanation<br/>Initial Logging:<br/><br/>console.log(\"Initial Stack:\", s); logs the input string to give context about the input before processing.<br/>Setting Up the Stack:<br/><br/>const stack = []; initializes an empty stack to keep track of opening brackets. This stack helps ensure that each opening bracket has a corresponding and correctly ordered closing bracket.<br/>Matching Map for Closing Brackets:<br/><br/>const matchingBrackets = { ')': '(', '}': '{', ']': '[' }; defines a dictionary mapping each closing bracket to its respective opening bracket. This will make it easy to check if each closing bracket has a corresponding opening bracket in the correct order.<br/>Iterating through the Characters in the String:<br/><br/>The function iterates through each character in the input string s with for (let char of s).<br/><br/>If the character is an opening bracket ((, {, or [):<br/><br/>stack.push(char); pushes the character onto the stack.<br/>console.log(...) logs that the character has been pushed, displaying the current stack’s state.<br/>If the character is a closing bracket (), }, or ]):<br/><br/>Empty Stack Check:<br/>if (stack.length === 0) checks if the stack is empty. If true, it logs this and returns false because there’s no opening bracket for this closing bracket, making the string invalid.<br/>Mismatched Brackets Check:<br/>if (stack[stack.length - 1] !== matchingBrackets[char]) compares the last pushed opening bracket (top of the stack) with the expected matching bracket from matchingBrackets. If they don’t match, it logs this mismatch and returns false.<br/>Matching Brackets:<br/>If the closing bracket matches the top opening bracket, stack.pop() removes this opening bracket from the stack, effectively “matching” this pair of brackets.<br/>console.log(...) logs this successful pop, showing which bracket was removed from the stack for the matched closing bracket.<br/>Final Stack Check:<br/><br/>After the loop, console.log(\"Final stack state:\", stack); logs the state of the stack. For the string to be valid, the stack should be empty; this would mean all opening brackets were properly closed and matched.<br/>return stack.length === 0; returns true if the stack is empty (valid string) and false otherwise (invalid string).",
		"category": "Stack"
	},
	{
		"id": 53,
		"topic": "Simplify Path",
		"code": "// Simplify the file path\nfunction simplifyPath(path) {\n let stack = [];\n let parts = path.split('/');\n for (let part of parts) {\n if (part === '' || part === '.') continue;\n if (part === '..') stack.pop();\n else stack.push(part);\n }\n return '/' + stack.join('/');\n}\n",
		"explanation": "This function simplifies a given file path.",
		"category": "Stack"
	},
	{
		"id": 54,
		"topic": "Min Stack",
		"code": "// Implement a stack that supports push, pop, top, and retrieving the minimum element\nclass MinStack {\n constructor() {\n this.stack = [];\n this.minStack = [];\n }\n push(val) {\n this.stack.push(val);\n if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n this.minStack.push(val);\n }\n }\n pop() {\n let val = this.stack.pop();\n if (val === this.minStack[this.minStack.length - 1]) {\n this.minStack.pop();\n }\n }\n top() {\n return this.stack[this.stack.length - 1];\n }\n getMin() {\n return this.minStack[this.minStack.length - 1];\n }\n}\n",
		"explanation": "This class implements a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
		"category": "Stack"
	},
	{
		"id": 55,
		"topic": "Evaluate Reverse Polish Notation",
		"code": "// Evaluate the value of an arithmetic expression in Reverse Polish Notation\nfunction evalRPN(tokens) {\n let stack = [];\n for (let token of tokens) {\n if (!isNaN(token)) stack.push(Number(token));\n else {\n let b = stack.pop(), a = stack.pop();\n switch (token) {\n case '+': stack.push(a + b); break;\n case '-': stack.push(a - b); break;\n case '*': stack.push(a * b); break;\n case '/': stack.push(Math.trunc(a / b)); break;\n }\n }\n }\n return stack[0];\n}\n",
		"explanation": "This function evaluates the value of an arithmetic expression in Reverse Polish Notation.",
		"category": "Stack"
	},
	{
		"id": 56,
		"topic": "Basic Calculator",
		"code": "// Implement a basic calculator to evaluate a simple expression string\nfunction calculate(s) {\n let stack = [], num = 0, sign = 1, result = 0;\n for (let char of s) {\n if (!isNaN(char) && char !== ' ') num = num * 10 + Number(char);\n else if (char === '+') {\n result += sign * num;\n num = 0;\n sign = 1;\n } else if (char === '-') {\n result += sign * num;\n num = 0;\n sign = -1;\n } else if (char === '(') {\n stack.push(result);\n stack.push(sign);\n result = 0;\n sign = 1;\n } else if (char === ')') {\n result += sign * num;\n num = 0;\n result *= stack.pop();\n result += stack.pop();\n }\n }\n return result + (sign * num);\n}\n",
		"explanation": "This function implements a basic calculator to evaluate a simple expression string.",
		"category": "Stack"
	},
	{
		"id": 57,
		"topic": "Linked List Cycle",
		"code": "// Check if a linked list has a cycle\nvar hasCycle = function(head) {\n // Edge case: A list with no nodes or only one node cannot have a cycle.\n if (!head || !head.next) return false;\n \n // Initialize two pointers: \n // 'slow' moves one step at a time, while 'fast' moves two steps at a time.\n let slow = head;\n let fast = head;\n \n // Traverse the list using the two pointers.\n while (fast && fast.next) {\n slow = slow.next; // Move 'slow' one step forward.\n fast = fast.next.next; // Move 'fast' two steps forward.\n \n // If 'slow' and 'fast' meet, a cycle exists in the list.\n if (slow === fast) {\n return true;\n }\n }\n \n // If the loop ends, it means 'fast' reached the end of the list (no cycle).\n return false;\n};\n",
		"explanation": "Explanation:<br/><br/>1. Edge Case Handling:<br/>   - If the list is empty (`head` is null) or has only one node (`head.next` is null), <br/>     it cannot contain a cycle, so we return false.<br/><br/>2. Pointer Initialization:<br/>   - 'slow' pointer moves one step at a time.<br/>   - 'fast' pointer moves two steps at a time.<br/><br/>3. Cycle Detection:<br/>   - As 'fast' moves faster, if a cycle exists, 'slow' and 'fast' will eventually <br/>     meet within the cycle.<br/>   - If 'fast' or 'fast.next' becomes null, it means the list has no cycle.<br/><br/>4. Return Value:<br/>   - If the two pointers meet, return true (a cycle is detected).<br/>   - If the loop terminates without the pointers meeting, return false (no cycle).<br/><br/>Example Use Cases:<br/>- Input: [3, 2, 0, -4] with pos = 1 (tail connects to the node at index 1)<br/>  Output: true (cycle detected).<br/>- Input: [1, 2] with pos = 0 (tail connects to the head)<br/>  Output: true (cycle detected).<br/>- Input: [1] with pos = -1 (no cycle)<br/>  Output: false (no cycle).",
		"category": "Linked List"
	},
	{
		"id": 58,
		"topic": "Add Two Numbers",
		"code": "// Add two numbers represented by linked lists\nfunction addTwoNumbers(l1, l2) {\n let dummy = new ListNode(0);\n let p = l1, q = l2, current = dummy;\n let carry = 0;\n while (p || q) {\n let x = p ? p.val : 0;\n let y = q ? q.val : 0;\n let sum = carry + x + y;\n carry = Math.floor(sum / 10);\n current.next = new ListNode(sum % 10);\n current = current.next;\n if (p) p = p.next;\n if (q) q = q.next;\n }\n if (carry > 0) {\n current.next = new ListNode(carry);\n }\n return dummy.next;\n}\n",
		"explanation": "This function adds two numbers represented by linked lists and returns the sum as a linked list.",
		"category": "Linked List"
	},
	{
		"id": 59,
		"topic": "Merge Two Sorted Lists",
		"code": "// Merge two sorted linked lists\nfunction mergeTwoLists(l1, l2) {\n let dummy = new ListNode(0);\n let current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n}\n",
		"explanation": "This function merges two sorted linked lists and returns the merged list.",
		"category": "Linked List"
	},
	{
		"id": 60,
		"topic": "Copy List with Random Pointer",
		"code": "// Copy a linked list with random pointer\nfunction copyRandomList(head) {\n if (!head) return null;\n let map = new Map();\n let current = head;\n while (current) {\n map.set(current, new ListNode(current.val));\n current = current.next;\n }\n current = head;\n while (current) {\n map.get(current).next = map.get(current.next) || null;\n map.get(current).random = map.get(current.random) || null;\n current = current.next;\n }\n return map.get(head);\n}\n",
		"explanation": "This function copies a linked list with random pointers and returns the deep copy.",
		"category": "Linked List"
	},
	{
		"id": 61,
		"topic": "Reverse Linked List II",
		"code": "// Reverse a linked list from position m to n\nfunction reverseBetween(head, m, n) {\n if (!head) return null;\n let dummy = new ListNode(0);\n dummy.next = head;\n let prev = dummy;\n for (let i = 1; i < m; i++) prev = prev.next;\n let start = prev.next;\n let then = start.next;\n for (let i = 0; i < n - m; i++) {\n start.next = then.next;\n then.next = prev.next;\n prev.next = then;\n then = start.next;\n }\n return dummy.next;\n}\n",
		"explanation": "This function reverses a linked list from position m to n.",
		"category": "Linked List"
	},
	{
		"id": 62,
		"topic": "Reverse Nodes in k-Group",
		"code": "// Reverse nodes in k-group\nfunction reverseKGroup(head, k) {\n let count = 0;\n let node = head;\n while (node && count < k) {\n node = node.next;\n count++;\n }\n if (count === k) {\n let reversedHead = reverse(head, k);\n head.next = reverseKGroup(node, k);\n return reversedHead;\n }\n return head;\n}\nfunction reverse(head, k) {\n let prev = null, current = head;\n while (k--) {\n let next = current.next;\n current.next = prev;\n prev = current;\n current = next;\n }\n return prev;\n}\n",
		"explanation": "This function reverses nodes in k-group in a linked list.",
		"category": "Linked List"
	},
	{
		"id": 63,
		"topic": "Remove Nth Node From End of List",
		"code": "// Remove the nth node from the end of the list\nfunction removeNthFromEnd(head, n) {\n let dummy = new ListNode(0);\n dummy.next = head;\n let first = dummy, second = dummy;\n for (let i = 0; i <= n; i++) first = first.next;\n while (first) {\n first = first.next;\n second = second.next;\n }\n second.next = second.next.next;\n return dummy.next;\n}\n",
		"explanation": "This function removes the nth node from the end of the list.",
		"category": "Linked List"
	},
	{
		"id": 64,
		"topic": "Remove Duplicates from Sorted List II",
		"code": "// Remove duplicates from sorted list\nfunction deleteDuplicates(head) {\n let dummy = new ListNode(0);\n dummy.next = head;\n let prev = dummy;\n while (head) {\n if (head.next && head.val === head.next.val) {\n while (head.next && head.val === head.next.val) head = head.next;\n prev.next = head.next;\n } else {\n prev = prev.next;\n }\n head = head.next;\n }\n return dummy.next;\n}\n",
		"explanation": "This function removes duplicates from a sorted linked list.",
		"category": "Linked List"
	},
	{
		"id": 65,
		"topic": "Rotate List",
		"code": "// Rotate a linked list to the right by k places\nfunction rotateRight(head, k) {\n if (!head || !head.next) return head;\n let length = 1;\n let tail = head;\n while (tail.next) {\n tail = tail.next;\n length++;\n }\n k = k % length;\n if (k === 0) return head;\n tail.next = head;\n for (let i = 0; i < length - k; i++) tail = tail.next;\n let newHead = tail.next;\n tail.next = null;\n return newHead;\n}\n",
		"explanation": "This function rotates a linked list to the right by k places.",
		"category": "Linked List"
	},
	{
		"id": 66,
		"topic": "Partition List",
		"code": "// Partition a linked list around a value x\nfunction partition(head, x) {\n let before = new ListNode(0), after = new ListNode(0);\n let beforeHead = before, afterHead = after;\n while (head) {\n if (head.val < x) {\n before.next = head;\n before = before.next;\n } else {\n after.next = head;\n after = after.next;\n }\n head = head.next;\n }\n after.next = null;\n before.next = afterHead.next;\n return beforeHead.next;\n}\n",
		"explanation": "This function partitions a linked list around a value x.",
		"category": "Linked List"
	},
	{
		"id": 67,
		"topic": "LRU Cache",
		"code": "// Implement LRU Cache\nclass LRUCache {\n constructor(capacity) {\n this.capacity = capacity;\n this.cache = new Map();\n }\n get(key) {\n if (!this.cache.has(key)) return -1;\n let value = this.cache.get(key);\n this.cache.delete(key);\n this.cache.set(key, value);\n return value;\n }\n put(key, value) {\n if (this.cache.has(key)) this.cache.delete(key);\n this.cache.set(key, value);\n if (this.cache.size > this.capacity) this.cache.delete(this.cache.keys().next().value);\n }\n}\n",
		"explanation": "This class implements an LRU Cache.",
		"category": "Linked List"
	},
	{
		"id": 68,
		"topic": "Maximum Depth of Binary Tree",
		"code": "var maxDepth = function(root) {\n    // Base case: if the node is null, the depth is 0\n    if (root === null) {\n        console.log(\"Reached a null node, returning depth of 0.\");\n        return 0;\n    }\n\n    // Log the current node being processed\n    console.log(`Processing node with value: ${root.val}`);\n\n    // Recursively find the depth of the left and right subtrees\n    const leftDepth = maxDepth(root.left);\n    const rightDepth = maxDepth(root.right);\n\n    // Log the depths of the left and right subtrees\n    console.log(`At node ${root.val}: Left Subtree Depth: ${leftDepth}, Right Subtree Depth: ${rightDepth}`);\n\n    // The depth of the current node is the maximum depth of the left and right subtrees, plus 1 for the current node\n    const currentDepth = Math.max(leftDepth, rightDepth) + 1;\n\n    // Log the calculated depth for the current node\n    console.log(`At node ${root.val}: Returning Depth: ${currentDepth}`);\n\n    return currentDepth;\n};\n\n// Test 1: Tree: [3,9,20,null,null,15,7]\n// ERD: \n//      3\n//     / \\\n//    9   20\n//        /  \\\n//       15   7\nconst testTree1 = new TreeNode(3);\ntestTree1.left = new TreeNode(9);\ntestTree1.right = new TreeNode(20);\ntestTree1.right.left = new TreeNode(15);\ntestTree1.right.right = new TreeNode(7);\n\nconsole.log(\"Test 1 - Expected: 3, Result:\", maxDepth(testTree1)); // Expected: 3\n",
		"explanation": "This function finds the maximum depth of a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 69,
		"topic": "Same Tree",
		"code": "// Check if two binary trees are the same\nfunction isSameTree(p, q) {\n if (!p && !q) return true;\n if (!p || !q || p.val !== q.val) return false;\n return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n",
		"explanation": "This function checks if two binary trees are the same.",
		"category": "Binary Tree General"
	},
	{
		"id": 70,
		"topic": "Invert Binary Tree",
		"code": "// Invert a binary tree\nfunction invertTree(root) {\n if (!root) return null;\n let left = invertTree(root.left);\n let right = invertTree(root.right);\n root.left = right;\n root.right = left;\n return root;\n}\n",
		"explanation": "This function inverts a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 71,
		"topic": "Symmetric Tree",
		"code": "// Check if a binary tree is symmetric\nfunction isSymmetric(root) {\n if (!root) return true;\n function isMirror(t1, t2) {\n if (!t1 && !t2) return true;\n if (!t1 || !t2 || t1.val !== t2.val) return false;\n return isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\n }\n return isMirror(root.left, root.right);\n}\n",
		"explanation": "This function checks if a binary tree is symmetric.",
		"category": "Binary Tree General"
	},
	{
		"id": 72,
		"topic": "Construct Binary Tree from Preorder and Inorder Traversal",
		"code": "// Construct binary tree from preorder and inorder traversal\nfunction buildTree(preorder, inorder) {\n if (!preorder.length || !inorder.length) return null;\n let root = new TreeNode(preorder[0]);\n let mid = inorder.indexOf(preorder[0]);\n root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n return root;\n}\n",
		"explanation": "This function constructs a binary tree from preorder and inorder traversal.",
		"category": "Binary Tree General"
	},
	{
		"id": 73,
		"topic": "Construct Binary Tree from Inorder and Postorder Traversal",
		"code": "// Construct binary tree from inorder and postorder traversal\nfunction buildTree(inorder, postorder) {\n if (!inorder.length || !postorder.length) return null;\n let root = new TreeNode(postorder.pop());\n let mid = inorder.indexOf(root.val);\n root.right = buildTree(inorder.slice(mid + 1), postorder);\n root.left = buildTree(inorder.slice(0, mid), postorder);\n return root;\n}\n",
		"explanation": "This function constructs a binary tree from inorder and postorder traversal.",
		"category": "Binary Tree General"
	},
	{
		"id": 74,
		"topic": "Populating Next Right Pointers in Each Node II",
		"code": "// Populate next right pointers in each node\nfunction connect(root) {\n if (!root) return null;\n let queue = [root];\n while (queue.length) {\n let size = queue.length;\n for (let i = 0; i < size; i++) {\n let node = queue.shift();\n if (i < size - 1) node.next = queue[0];\n if (node.left) queue.push(node.left);\n if (node.right) queue.push(node.right);\n }\n }\n return root;\n}\n",
		"explanation": "This function populates each next pointer to point to its next right node.",
		"category": "Binary Tree General"
	},
	{
		"id": 75,
		"topic": "Flatten Binary Tree to Linked List",
		"code": "// Flatten binary tree to linked list\nfunction flatten(root) {\n if (!root) return;\n flatten(root.left);\n flatten(root.right);\n let left = root.left;\n let right = root.right;\n root.left = null;\n root.right = left;\n let current = root;\n while (current.right) current = current.right;\n current.right = right;\n}\n",
		"explanation": "This function flattens a binary tree to a linked list in-place.",
		"category": "Binary Tree General"
	},
	{
		"id": 76,
		"topic": "Path Sum",
		"code": "// Find if there is a root-to-leaf path with a given sum\nfunction hasPathSum(root, sum) {\n if (!root) return false;\n if (!root.left && !root.right) return root.val === sum;\n return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n}\n",
		"explanation": "This function checks if there is a root-to-leaf path with a given sum.",
		"category": "Binary Tree General"
	},
	{
		"id": 77,
		"topic": "Sum Root to Leaf Numbers",
		"code": "// Find the sum of all root-to-leaf numbers\nfunction sumNumbers(root) {\n function dfs(node, currentSum) {\n if (!node) return 0;\n currentSum = currentSum * 10 + node.val;\n if (!node.left && !node.right) return currentSum;\n return dfs(node.left, currentSum) + dfs(node.right, currentSum);\n }\n return dfs(root, 0);\n}\n",
		"explanation": "This function finds the sum of all root-to-leaf numbers.",
		"category": "Binary Tree General"
	},
	{
		"id": 78,
		"topic": "Binary Tree Maximum Path Sum",
		"code": "// Find the maximum path sum in a binary tree\nfunction maxPathSum(root) {\n let maxSum = -Infinity;\n function dfs(node) {\n if (!node) return 0;\n let left = Math.max(dfs(node.left), 0);\n let right = Math.max(dfs(node.right), 0);\n let newPathSum = node.val + left + right;\n maxSum = Math.max(maxSum, newPathSum);\n return node.val + Math.max(left, right);\n }\n dfs(root);\n return maxSum;\n}\n",
		"explanation": "This function finds the maximum path sum in a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 79,
		"topic": "Binary Search Tree Iterator",
		"code": "// Implement a binary search tree iterator\nclass BSTIterator {\n constructor(root) {\n this.stack = [];\n this.pushAll(root);\n }\n next() {\n let node = this.stack.pop();\n this.pushAll(node.right);\n return node.val;\n }\n hasNext() {\n return this.stack.length > 0;\n }\n pushAll(node) {\n while (node) {\n this.stack.push(node);\n node = node.left;\n }\n }\n}\n",
		"explanation": "This class implements a binary search tree iterator with next and hasNext methods.",
		"category": "Binary Tree General"
	},
	{
		"id": 80,
		"topic": "Count Complete Tree Nodes",
		"code": "// Count the number of nodes in a complete binary tree\nfunction countNodes(root) {\n if (!root) return 0;\n let leftDepth = getDepth(root.left);\n let rightDepth = getDepth(root.right);\n if (leftDepth === rightDepth) {\n return (1 << leftDepth) + countNodes(root.right);\n } else {\n return (1 << rightDepth) + countNodes(root.left);\n }\n}\nfunction getDepth(node) {\n let depth = 0;\n while (node) {\n depth++;\n node = node.left;\n }\n return depth;\n}\n",
		"explanation": "This function counts the number of nodes in a complete binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 81,
		"topic": "Lowest Common Ancestor of a Binary Tree",
		"code": "// Find the lowest common ancestor of two nodes in a binary tree\nfunction lowestCommonAncestor(root, p, q) {\n if (!root || root === p || root === q) return root;\n let left = lowestCommonAncestor(root.left, p, q);\n let right = lowestCommonAncestor(root.right, p, q);\n if (left && right) return root;\n return left ? left : right;\n}\n",
		"explanation": "This function finds the lowest common ancestor of two nodes in a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"id": 82,
		"topic": "Binary Tree Right Side View",
		"code": "// Find the right side view of a binary tree\nvar rightSideView = function(root) {\n // Return empty array if the tree is empty\n if (!root) return [];\n \n // Initialize queue for BFS and result array for the right-side view\n let queue = [root];\n let result = [];\n\n // Perform level-order traversal using BFS\n while (queue.length > 0) {\n let levelSize = queue.length; // Number of nodes at the current level\n \n for (let i = 0; i < levelSize; i++) {\n let currentNode = queue.shift(); // Dequeue the front node\n \n // If it's the last node in this level, add its value to the result\n if (i === levelSize - 1) {\n result.push(currentNode.val);\n }\n \n // Enqueue left and right children (if they exist)\n if (currentNode.left) queue.push(currentNode.left);\n if (currentNode.right) queue.push(currentNode.right);\n }\n }\n\n return result;\n};\n",
		"explanation": "Explanation:<br/> 1. Edge Case:<br/>    - If the root is null, return an empty array [].<br/> <br/> 2. BFS Traversal:<br/>    - Use a queue to perform a level-order traversal.<br/>    - For each level, iterate through all nodes.<br/>    - Keep track of the last node's value at each level and add it to the result array.<br/> <br/> 3. Enqueue Children:<br/>    - After processing a node, enqueue its left and right children (if they exist)<br/>      for processing in the next level.",
		"category": "Binary Tree BFS"
	},
	{
		"id": 83,
		"topic": "Average of Levels in Binary Tree",
		"code": "// Find the average of levels in a binary tree\nfunction averageOfLevels(root) {\n let result = [], queue = [root];\n while (queue.length) {\n let sum = 0, count = 0, nextQueue = [];\n for (let node of queue) {\n sum += node.val;\n count++;\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(sum / count);\n queue = nextQueue;\n }\n return result;\n}\n",
		"explanation": "This function finds the average of levels in a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"id": 84,
		"topic": "Binary Tree Level Order Traversal",
		"code": "// Perform level order traversal of a binary tree\nfunction levelOrder(root) {\n let result = [], queue = [root];\n while (queue.length) {\n let level = [], nextQueue = [];\n for (let node of queue) {\n level.push(node.val);\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(level);\n queue = nextQueue;\n }\n return result;\n}\n",
		"explanation": "This function performs level order traversal of a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"id": 85,
		"topic": "Binary Tree Zigzag Level Order Traversal",
		"code": "// Perform zigzag level order traversal of a binary tree\nfunction zigzagLevelOrder(root) {\n let result = [], queue = [root], leftToRight = true;\n while (queue.length) {\n let level = [], nextQueue = [];\n for (let node of queue) {\n if (leftToRight) level.push(node.val);\n else level.unshift(node.val);\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(level);\n queue = nextQueue;\n leftToRight = !leftToRight;\n }\n return result;\n}\n",
		"explanation": "This function performs zigzag level order traversal of a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"id": 86,
		"topic": "Minimum Absolute Difference in BST",
		"code": "// Find the minimum absolute difference in a BST\nvar getMinimumDifference = function (root) {\n let prev = null; // Tracks the previous value in the in-order traversal\n let minDiff = Infinity; // Initialize the minimum difference to a very large number\n\n // Helper function for in-order traversal\n const inOrderTraversal = (node) => {\n if (!node) return;\n\n // Traverse the left subtree\n inOrderTraversal(node.left);\n\n // Process the current node\n if (prev !== null) {\n // Update the minimum difference\n minDiff = Math.min(minDiff, Math.abs(node.val - prev));\n }\n // Update the previous value to the current node's value\n prev = node.val;\n\n // Traverse the right subtree\n inOrderTraversal(node.right);\n };\n\n // Perform in-order traversal starting from the root\n inOrderTraversal(root);\n\n return minDiff;\n};\n",
		"explanation": "Explanation:\n\n1. In-order Traversal:\nThe recursive function `inOrderTraversal` processes nodes in ascending order for a BST.\n\n2. `prev` Variable:\nKeeps track of the previously visited node's value during traversal.\n\n3. Minimum Difference Calculation:\nAt each node, the absolute difference between the current node's value and `prev` is calculated.\nThe `minDiff` is updated if the new difference is smaller.\n\n4. Return Value:\nAfter the traversal, `minDiff` contains the smallest absolute difference between any two nodes.\n\nComplexity Analysis:\n- Time Complexity: O(n), where `n` is the number of nodes. Each node is visited once.\n- Space Complexity: O(h), where `h` is the height of the BST. This accounts for the recursion stack.",
		"category": "Binary Search Tree"
	},
	{
		"id": 87,
		"topic": "Kth Smallest Element in a BST",
		"code": "// Find the kth smallest element in a BST\nfunction kthSmallest(root, k) {\n let stack = [];\n while (true) {\n while (root) {\n stack.push(root);\n root = root.left;\n }\n root = stack.pop();\n if (--k === 0) return root.val;\n root = root.right;\n }\n}\n",
		"explanation": "This function finds the kth smallest element in a BST.",
		"category": "Binary Search Tree"
	},
	{
		"id": 88,
		"topic": "Validate Binary Search Tree",
		"code": "// Validate if a tree is a binary search tree\nfunction isValidBST(root) {\n function validate(node, low = -Infinity, high = Infinity) {\n if (!node) return true;\n if (node.val <= low || node.val >= high) return false;\n return validate(node.left, low, node.val) && validate(node.right, node.val, high);\n }\n return validate(root);\n}\n",
		"explanation": "This function validates if a tree is a binary search tree.",
		"category": "Binary Search Tree"
	},
	{
		"id": 89,
		"topic": "Number of Islands",
		"code": "// Find the number of islands\nfunction numIslands(grid) {\n if (!grid.length) return 0;\n let count = 0;\n function dfs(i, j) {\n if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return;\n grid[i][j] = '0';\n dfs(i + 1, j);\n dfs(i - 1, j);\n dfs(i, j + 1);\n dfs(i, j - 1);\n }\n for (let i = 0; i < grid.length; i++) {\n for (let j = 0; j < grid[0].length; j++) {\n if (grid[i][j] === '1') {\n count++;\n dfs(i, j);\n }\n }\n }\n return count;\n}\n",
		"explanation": "This function finds the number of islands in a grid using DFS.",
		"category": "Graph General"
	},
	{
		"id": 90,
		"topic": "Surrounded Regions",
		"code": "// Capture all regions surrounded by 'X'\nfunction solve(board) {\n if (!board.length) return;\n let m = board.length, n = board[0].length;\n function dfs(i, j) {\n if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] !== 'O') return;\n board[i][j] = 'T';\n dfs(i + 1, j);\n dfs(i - 1, j);\n dfs(i, j + 1);\n dfs(i, j - 1);\n }\n for (let i = 0; i < m; i++) {\n if (board[i][0] === 'O') dfs(i, 0);\n if (board[i][n - 1] === 'O') dfs(i, n - 1);\n }\n for (let j = 0; j < n; j++) {\n if (board[0][j] === 'O') dfs(0, j);\n if (board[m - 1][j] === 'O') dfs(m - 1, j);\n }\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n if (board[i][j] === 'O') board[i][j] = 'X';\n if (board[i][j] === 'T') board[i][j] = 'O';\n }\n }\n}\n",
		"explanation": "This function captures all regions surrounded by 'X' in a board.",
		"category": "Graph General"
	},
	{
		"id": 91,
		"topic": "Clone Graph",
		"code": "// Clone a graph\nfunction cloneGraph(node) {\n if (!node) return null;\n let map = new Map();\n function clone(node) {\n if (!map.has(node)) {\n map.set(node, new Node(node.val));\n map.get(node).neighbors = node.neighbors.map(clone);\n }\n return map.get(node);\n }\n return clone(node);\n}\n",
		"explanation": "This function clones a graph using DFS.",
		"category": "Graph General"
	},
	{
		"id": 92,
		"topic": "Evaluate Division",
		"code": "// Evaluate division\nfunction calcEquation(equations, values, queries) {\n let graph = new Map();\n function buildGraph(equations, values) {\n for (let i = 0; i < equations.length; i++) {\n let [a, b] = equations[i];\n if (!graph.has(a)) graph.set(a, new Map());\n if (!graph.has(b)) graph.set(b, new Map());\n graph.get(a).set(b, values[i]);\n graph.get(b).set(a, 1 / values[i]);\n }\n }\n function dfs(start, end, visited) {\n if (!graph.has(start) || !graph.has(end)) return -1;\n if (start === end) return 1;\n visited.add(start);\n for (let [neighbor, value] of graph.get(start)) {\n if (!visited.has(neighbor)) {\n let product = dfs(neighbor, end, visited);\n if (product !== -1) return product * value;\n }\n }\n return -1;\n }\n buildGraph(equations, values);\n let results = [];\n for (let [a, b] of queries) {\n results.push(dfs(a, b, new Set()));\n }\n return results;\n}\n",
		"explanation": "This function evaluates division using a graph and DFS.",
		"category": "Graph General"
	},
	{
		"id": 93,
		"topic": "Course Schedule",
		"code": "// Determine if you can finish all courses\nfunction canFinish(numCourses, prerequisites) {\n let graph = new Map();\n let indegree = Array(numCourses).fill(0);\n for (let [course, prereq] of prerequisites) {\n if (!graph.has(prereq)) graph.set(prereq, []);\n graph.get(prereq).push(course);\n indegree[course]++;\n }\n let queue = [];\n for (let i = 0; i < numCourses; i++) {\n if (indegree[i] === 0) queue.push(i);\n }\n let count = 0;\n while (queue.length) {\n let course = queue.shift();\n count++;\n if (graph.has(course)) {\n for (let nextCourse of graph.get(course)) {\n indegree[nextCourse]--;\n if (indegree[nextCourse] === 0) queue.push(nextCourse);\n }\n }\n }\n return count === numCourses;\n}\n",
		"explanation": "This function determines if you can finish all courses given the prerequisites.",
		"category": "Graph General"
	},
	{
		"id": 94,
		"topic": "Course Schedule II",
		"code": "// Find the order of courses to finish all courses\nfunction findOrder(numCourses, prerequisites) {\n let graph = new Map();\n let indegree = Array(numCourses).fill(0);\n for (let [course, prereq] of prerequisites) {\n if (!graph.has(prereq)) graph.set(prereq, []);\n graph.get(prereq).push(course);\n indegree[course]++;\n }\n let queue = [];\n for (let i = 0; i < numCourses; i++) {\n if (indegree[i] === 0) queue.push(i);\n }\n let order = [];\n while (queue.length) {\n let course = queue.shift();\n order.push(course);\n if (graph.has(course)) {\n for (let nextCourse of graph.get(course)) {\n indegree[nextCourse]--;\n if (indegree[nextCourse] === 0) queue.push(nextCourse);\n }\n }\n }\n return order.length === numCourses ? order : [];\n}\n",
		"explanation": "This function finds the order of courses to finish all courses given the prerequisites.",
		"category": "Graph General"
	},
	{
		"id": 95,
		"topic": "Snakes and Ladders",
		"code": "// Find the minimum number of moves to reach the last square\nfunction snakesAndLadders(board) {\n let n = board.length;\n let visited = new Set();\n let queue = [[1, 0]];\n while (queue.length) {\n let [s, moves] = queue.shift();\n for (let i = 1; i <= 6; i++) {\n let next = s + i;\n let [r, c] = [Math.floor((next - 1) / n), (next - 1) % n];\n if (r % 2 === 1) c = n - 1 - c;\n r = n - 1 - r;\n if (board[r][c] !== -1) next = board[r][c];\n if (next === n * n) return moves + 1;\n if (!visited.has(next)) {\n visited.add(next);\n queue.push([next, moves + 1]);\n }\n }\n }\n return -1;\n}\n",
		"explanation": "This function finds the minimum number of moves to reach the last square in a Snakes and Ladders game.",
		"category": "Graph BFS"
	},
	{
		"id": 96,
		"topic": "Minimum Genetic Mutation",
		"code": "// Find the minimum number of mutations to reach the end gene\nfunction minMutation(start, end, bank) {\n let bankSet = new Set(bank);\n if (!bankSet.has(end)) return -1;\n let queue = [[start, 0]];\n let visited = new Set([start]);\n let chars = ['A', 'C', 'G', 'T'];\n while (queue.length) {\n let [gene, mutations] = queue.shift();\n if (gene === end) return mutations;\n for (let i = 0; i < gene.length; i++) {\n for (let char of chars) {\n let newGene = gene.slice(0, i) + char + gene.slice(i + 1);\n if (bankSet.has(newGene) && !visited.has(newGene)) {\n visited.add(newGene);\n queue.push([newGene, mutations + 1]);\n }\n }\n }\n }\n return -1;\n}\n",
		"explanation": "This function finds the minimum number of mutations needed to reach the end gene from the start gene.",
		"category": "Graph BFS"
	},
	{
		"id": 97,
		"topic": "Word Ladder",
		"code": "// Find the length of the shortest transformation sequence from beginWord to endWord\nfunction ladderLength(beginWord, endWord, wordList) {\n let wordSet = new Set(wordList);\n if (!wordSet.has(endWord)) return 0;\n let queue = [[beginWord, 1]];\n while (queue.length) {\n let [word, length] = queue.shift();\n if (word === endWord) return length;\n for (let i = 0; i < word.length; i++) {\n for (let char of 'abcdefghijklmnopqrstuvwxyz') {\n let newWord = word.slice(0, i) + char + word.slice(i + 1);\n if (wordSet.has(newWord)) {\n wordSet.delete(newWord);\n queue.push([newWord, length + 1]);\n }\n }\n }\n }\n return 0;\n}\n",
		"explanation": "This function finds the length of the shortest transformation sequence from beginWord to endWord.",
		"category": "Graph BFS"
	},
	{
		"id": 98,
		"topic": "Implement Trie (Prefix Tree)",
		"code": "// Implement a Trie (Prefix Tree)\nclass Trie {\n constructor() {\n this.children = {};\n this.isEndOfWord = false;\n }\n insert(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) node.children[char] = new Trie();\n node = node.children[char];\n }\n node.isEndOfWord = true;\n }\n search(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) return false;\n node = node.children[char];\n }\n return node.isEndOfWord;\n }\n startsWith(prefix) {\n let node = this;\n for (let char of prefix) {\n if (!node.children[char]) return false;\n node = node.children[char];\n }\n return true;\n }\n}\n",
		"explanation": "This class implements a Trie (Prefix Tree) with insert, search, and startsWith methods.",
		"category": "Trie"
	},
	{
		"id": 99,
		"topic": "Design Add and Search Words Data Structure",
		"code": "// Design a data structure that supports adding and searching words\nclass WordDictionary {\n constructor() {\n this.children = {};\n this.isEndOfWord = false;\n }\n addWord(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) node.children[char] = new WordDictionary();\n node = node.children[char];\n }\n node.isEndOfWord = true;\n }\n search(word) {\n function dfs(node, i) {\n if (i === word.length) return node.isEndOfWord;\n if (word[i] === '.') {\n for (let child in node.children) {\n if (dfs(node.children[child], i + 1)) return true;\n }\n return false;\n }\n if (!node.children[word[i]]) return false;\n return dfs(node.children[word[i]], i + 1);\n }\n return dfs(this, 0);\n }\n}\n",
		"explanation": "This class implements a data structure that supports adding and searching words with '.' as a wildcard character.",
		"category": "Trie"
	},
	{
		"id": 100,
		"topic": "Word Search II",
		"code": "// Find all words in the board\nfunction findWords(board, words) {\n let result = [];\n let trie = new Trie();\n for (let word of words) trie.insert(word);\n function dfs(node, i, j, path) {\n if (node.isEndOfWord) {\n result.push(path);\n node.isEndOfWord = false;\n }\n if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || !node.children[board[i][j]]) return;\n let char = board[i][j];\n board[i][j] = '#';\n for (let [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {\n dfs(node.children[char], i + dx, j + dy, path + char);\n }\n board[i][j] = char;\n }\n for (let i = 0; i < board.length; i++) {\n for (let j = 0; j < board[0].length; j++) {\n if (trie.children[board[i][j]]) dfs(trie, i, j, '');\n }\n }\n return result;\n}\n",
		"explanation": "This function finds all words in the board using a Trie and DFS.",
		"category": "Trie"
	},
	{
		"id": 101,
		"topic": "Letter Combinations of a Phone Number",
		"code": "// Find all letter combinations of a phone number\nfunction letterCombinations(digits) {\n if (!digits.length) return [];\n let map = {\n '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n };\n let result = [];\n function backtrack(index, path) {\n if (index === digits.length) {\n result.push(path);\n return;\n }\n for (let char of map[digits[index]]) {\n backtrack(index + 1, path + char);\n }\n }\n backtrack(0, '');\n return result;\n}\n",
		"explanation": "This function finds all letter combinations of a phone number.",
		"category": "Backtracking"
	},
	{
		"id": 102,
		"topic": "Combinations",
		"code": "// Find all combinations of k numbers out of 1 to n\nfunction combine(n, k) {\n let result = [];\n function backtrack(start, path) {\n if (path.length === k) {\n result.push([...path]);\n return;\n }\n for (let i = start; i <= n; i++) {\n path.push(i);\n backtrack(i + 1, path);\n path.pop();\n }\n }\n backtrack(1, []);\n return result;\n}\n",
		"explanation": "This function finds all combinations of k numbers out of 1 to n.",
		"category": "Backtracking"
	},
	{
		"id": 103,
		"topic": "Permutations",
		"code": "// Generate all permutations of an array of numbers\nfunction permute(nums) {\n let result = [];\n function backtrack(path = [], used = Array(nums.length).fill(false)) {\n if (path.length === nums.length) {\n result.push([...path]);\n return;\n }\n for (let i = 0; i < nums.length; i++) {\n if (used[i]) continue;\n used[i] = true;\n path.push(nums[i]);\n backtrack(path, used);\n path.pop();\n used[i] = false;\n }\n }\n backtrack();\n return result;\n}\n",
		"explanation": "This function generates all possible permutations of an array using backtracking.",
		"category": "Backtracking"
	},
	{
		"id": 104,
		"topic": "Combination Sum",
		"code": "// Find all unique combinations that sum up to the target\nfunction combinationSum(candidates, target) {\n let result = [];\n function backtrack(start = 0, path = [], remaining = target) {\n if (remaining === 0) {\n result.push([...path]);\n return;\n }\n for (let i = start; i < candidates.length; i++) {\n if (remaining < candidates[i]) continue;\n path.push(candidates[i]);\n backtrack(i, path, remaining - candidates[i]);\n path.pop();\n }\n }\n backtrack();\n return result;\n}\n",
		"explanation": "This function finds all unique combinations of numbers from the candidates array that sum up to the target.",
		"category": "Backtracking"
	},
	{
		"id": 105,
		"topic": "N-Queens II",
		"code": "// Count all unique solutions to the N-Queens problem\nfunction totalNQueens(n) {\n let count = 0;\n function backtrack(row = 0, cols = new Set(), diags1 = new Set(), diags2 = new Set()) {\n if (row === n) {\n count++;\n return;\n }\n for (let col = 0; col < n; col++) {\n let diag1 = row - col;\n let diag2 = row + col;\n if (cols.has(col) || diags1.has(diag1) || diags2.has(diag2)) continue;\n cols.add(col);\n diags1.add(diag1);\n diags2.add(diag2);\n backtrack(row + 1, cols, diags1, diags2);\n cols.delete(col);\n diags1.delete(diag1);\n diags2.delete(diag2);\n }\n }\n backtrack();\n return count;\n}\n",
		"explanation": "This function counts all distinct solutions to the N-Queens problem using backtracking.",
		"category": "Backtracking"
	},
	{
		"id": 106,
		"topic": "Generate Parentheses",
		"code": "// Generate all combinations of well-formed parentheses\nfunction generateParenthesis(n) {\n let result = [];\n function backtrack(s = '', left = 0, right = 0) {\n if (s.length === 2 * n) {\n result.push(s);\n return;\n }\n if (left < n) backtrack(s + '(', left + 1, right);\n if (right < left) backtrack(s + ')', left, right + 1);\n }\n backtrack();\n return result;\n}\n",
		"explanation": "This function generates all combinations of well-formed parentheses.",
		"category": "Backtracking"
	},
	{
		"id": 107,
		"topic": "Word Search",
		"code": "// Find if a word exists in the board\nfunction exist(board, word) {\n function dfs(i, j, k) {\n if (k === word.length) return true;\n if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] !== word[k]) return false;\n let temp = board[i][j];\n board[i][j] = '#';\n let found = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n board[i][j] = temp;\n return found;\n }\n for (let i = 0; i < board.length; i++) {\n for (let j = 0; j < board[0].length; j++) {\n if (dfs(i, j, 0)) return true;\n }\n }\n return false;\n}\n",
		"explanation": "This function finds if a word exists in the board using DFS.",
		"category": "Backtracking"
	},
	{
		"id": 108,
		"topic": "Convert Sorted Array to Binary Search Tree",
		"code": "// Convert sorted array to binary search tree\nfunction sortedArrayToBST(nums) {\n if (!nums.length) return null;\n function convert(left, right) {\n if (left > right) return null;\n let mid = Math.floor((left + right) / 2);\n let node = new TreeNode(nums[mid]);\n node.left = convert(left, mid - 1);\n node.right = convert(mid + 1, right);\n return node;\n }\n return convert(0, nums.length - 1);\n}\n",
		"explanation": "This function converts a sorted array to a binary search tree.",
		"category": "Divide & Conquer"
	},
	{
		"id": 109,
		"topic": "Sort List",
		"code": "// Sort a linked list in O(n log n) time\nfunction sortList(head) {\n if (!head || !head.next) return head;\n let slow = head, fast = head, prev = null;\n while (fast && fast.next) {\n prev = slow;\n slow = slow.next;\n fast = fast.next.next;\n }\n prev.next = null;\n let l1 = sortList(head);\n let l2 = sortList(slow);\n return merge(l1, l2);\n}\nfunction merge(l1, l2) {\n let dummy = new ListNode(0), current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n}\n",
		"explanation": "This function sorts a linked list in O(n log n) time using merge sort.",
		"category": "Divide & Conquer"
	},
	{
		"id": 110,
		"topic": "Construct Quad Tree",
		"code": "// Construct a quad tree\nfunction construct(grid) {\n function build(x, y, length) {\n if (length === 1) return new Node(grid[x][y] === 1, true);\n let half = length / 2;\n let topLeft = build(x, y, half);\n let topRight = build(x, y + half, half);\n let bottomLeft = build(x + half, y, half);\n let bottomRight = build(x + half, y + half, half);\n if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf && topLeft.val === topRight.val && topRight.val === bottomLeft.val && bottomLeft.val === bottomRight.val) {\n return new Node(topLeft.val, true);\n }\n return new Node('*', false, topLeft, topRight, bottomLeft, bottomRight);\n }\n return build(0, 0, grid.length);\n}\n",
		"explanation": "This function constructs a quad tree from a grid.",
		"category": "Divide & Conquer"
	},
	{
		"id": 111,
		"topic": "Merge k Sorted Lists",
		"code": "// Merge k sorted linked lists\nfunction mergeKLists(lists) {\n if (!lists.length) return null;\n function mergeTwoLists(l1, l2) {\n let dummy = new ListNode(0), current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n }\n while (lists.length > 1) {\n let l1 = lists.shift();\n let l2 = lists.shift();\n let merged = mergeTwoLists(l1, l2);\n lists.push(merged);\n }\n return lists[0];\n}\n",
		"explanation": "This function merges k sorted linked lists into one sorted linked list.",
		"category": "Divide & Conquer"
	},
	{
		"id": 112,
		"topic": "Maximum Subarray",
		"code": "// Find the contiguous subarray with the maximum sum\nfunction maxSubArray(nums) {\n let maxSum = nums[0], currentSum = nums[0];\n for (let i = 1; i < nums.length; i++) {\n currentSum = Math.max(nums[i], currentSum + nums[i]);\n maxSum = Math.max(maxSum, currentSum);\n }\n return maxSum;\n}\n",
		"explanation": "This function finds the contiguous subarray with the maximum sum using Kadane's Algorithm.",
		"category": "Kadane's Algorithm"
	},
	{
		"id": 113,
		"topic": "Maximum Sum Circular Subarray",
		"code": "// Find the maximum sum of a circular subarray\nfunction maxSubarraySumCircular(A) {\n let total = 0, maxSum = A[0], currentMax = 0, minSum = A[0], currentMin = 0;\n for (let a of A) {\n currentMax = Math.max(currentMax + a, a);\n maxSum = Math.max(maxSum, currentMax);\n currentMin = Math.min(currentMin + a, a);\n minSum = Math.min(minSum, currentMin);\n total += a;\n }\n return maxSum > 0 ? Math.max(maxSum, total - minSum) : maxSum;\n}\n",
		"explanation": "This function finds the maximum sum of a circular subarray.",
		"category": "Kadane's Algorithm"
	},
	{
		"id": 114,
		"topic": "Search Insert Position",
		"code": "// Find the index where a target should be inserted\nfunction searchInsert(nums, target) {\n let left = 0, right = nums.length - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] === target) return mid;\n if (nums[mid] < target) left = mid + 1;\n else right = mid - 1;\n }\n return left;\n}\n",
		"explanation": "This function finds the index where a target should be inserted in a sorted array.",
		"category": "Binary Search"
	},
	{
		"id": 115,
		"topic": "Search a 2D Matrix",
		"code": "// Search a target in a 2D matrix\nfunction searchMatrix(matrix, target) {\n if (!matrix.length || !matrix[0].length) return false;\n let rows = matrix.length, cols = matrix[0].length;\n let left = 0, right = rows * cols - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n let midVal = matrix[Math.floor(mid / cols)][mid % cols];\n if (midVal === target) return true;\n if (midVal < target) left = mid + 1;\n else right = mid - 1;\n }\n return false;\n}\n",
		"explanation": "This function searches for a target in a 2D matrix.",
		"category": "Binary Search"
	},
	{
		"id": 116,
		"topic": "Find Peak Element",
		"code": "// Find peak element\nfunction findPeakElement(nums) {\n let left = 0, right = nums.length - 1;\n while (left < right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] > nums[mid + 1]) right = mid;\n else left = mid + 1;\n }\n return left;\n}\n",
		"explanation": "This function finds a peak element in an array.",
		"category": "Binary Search"
	},
	{
		"id": 117,
		"topic": "Search in Rotated Sorted Array",
		"code": "// Search in rotated sorted array\nfunction search(nums, target) {\n let left = 0, right = nums.length - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] === target) return mid;\n if (nums[left] <= nums[mid]) {\n if (nums[left] <= target && target < nums[mid]) right = mid - 1;\n else left = mid + 1;\n } else {\n if (nums[mid] < target && target <= nums[right]) left = mid + 1;\n else right = mid - 1;\n }\n }\n return -1;\n}\n",
		"explanation": "This function searches for a target in a rotated sorted array.",
		"category": "Binary Search"
	},
	{
		"id": 118,
		"topic": "Find First and Last Position of Element in Sorted Array",
		"code": "// Find first and last position of element in sorted array\nfunction searchRange(nums, target) {\n function findBound(isFirst) {\n let left = 0, right = nums.length - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] === target) {\n if (isFirst) {\n if (mid === left || nums[mid - 1] !== target) return mid;\n right = mid - 1;\n } else {\n if (mid === right || nums[mid + 1] !== target) return mid;\n left = mid + 1;\n }\n } else if (nums[mid] < target) left = mid + 1;\n else right = mid - 1;\n }\n return -1;\n }\n return [findBound(true), findBound(false)];\n}\n",
		"explanation": "This function finds the first and last position of an element in a sorted array.",
		"category": "Binary Search"
	},
	{
		"id": 119,
		"topic": "Find Minimum in Rotated Sorted Array",
		"code": "// Find minimum in rotated sorted array\nfunction findMin(nums) {\n let left = 0, right = nums.length - 1;\n while (left < right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] > nums[right]) left = mid + 1;\n else right = mid;\n }\n return nums[left];\n}\n",
		"explanation": "This function finds the minimum element in a rotated sorted array.",
		"category": "Binary Search"
	},
	{
		"id": 120,
		"topic": "Median of Two Sorted Arrays",
		"code": "// Find median of two sorted arrays\nfunction findMedianSortedArrays(nums1, nums2) {\n let m = nums1.length, n = nums2.length;\n if (m > n) [nums1, nums2, m, n] = [nums2, nums1, n, m];\n let imin = 0, imax = m, halfLen = Math.floor((m + n + 1) / 2);\n while (imin <= imax) {\n let i = Math.floor((imin + imax) / 2);\n let j = halfLen - i;\n if (i < m && nums1[i] < nums2[j - 1]) imin = i + 1;\n else if (i > 0 && nums1[i - 1] > nums2[j]) imax = i - 1;\n else {\n let maxOfLeft = 0;\n if (i === 0) maxOfLeft = nums2[j - 1];\n else if (j === 0) maxOfLeft = nums1[i - 1];\n else maxOfLeft = Math.max(nums1[i - 1], nums2[j - 1]);\n if ((m + n) % 2 === 1) return maxOfLeft;\n let minOfRight = 0;\n if (i === m) minOfRight = nums2[j];\n else if (j === n) minOfRight = nums1[i];\n else minOfRight = Math.min(nums1[i], nums2[j]);\n return (maxOfLeft + minOfRight) / 2;\n }\n }\n return 0;\n}\n",
		"explanation": "This function finds the median of two sorted arrays.",
		"category": "Binary Search"
	},
	{
		"id": 121,
		"topic": "Kth Largest Element in an Array",
		"code": "// Find kth largest element in an array\nfunction findKthLargest(nums, k) {\n let heap = new MinHeap();\n for (let num of nums) {\n heap.add(num);\n if (heap.size() > k) heap.poll();\n }\n return heap.peek();\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] >= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild < element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild < element) || (swap !== null && rightChild < leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the kth largest element in an array using a min heap.",
		"category": "Heap"
	},
	{
		"id": 122,
		"topic": "IPO",
		"code": "// Find the maximum capital after k projects\nfunction findMaximizedCapital(k, W, Profits, Capital) {\n let minCapital = new MinHeap(), maxProfit = new MaxHeap();\n for (let i = 0; i < Capital.length; i++) minCapital.add([Capital[i], Profits[i]]);\n for (let i = 0; i < k; i++) {\n while (minCapital.size() && minCapital.peek()[0] <= W) maxProfit.add(minCapital.poll()[1]);\n if (!maxProfit.size()) break;\n W += maxProfit.poll();\n }\n return W;\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index][0] >= this.heap[parentIndex][0]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild[0] < element[0]) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild[0] < element[0]) || (swap !== null && rightChild[0] < leftChild[0])) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\nclass MaxHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] <= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild > element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the maximum capital after k projects.",
		"category": "Heap"
	},
	{
		"id": 123,
		"topic": "Find K Pairs with Smallest Sums",
		"code": "// Find k pairs with smallest sums\nfunction kSmallestPairs(nums1, nums2, k) {\n let heap = new MinHeap();\n for (let i = 0; i < Math.min(nums1.length, k); i++) heap.add([nums1[i] + nums2[0], i, 0]);\n let result = [];\n while (k-- > 0 && heap.size()) {\n let [sum, i, j] = heap.poll();\n result.push([nums1[i], nums2[j]]);\n if (j + 1 < nums2.length) heap.add([nums1[i] + nums2[j + 1], i, j + 1]);\n }\n return result;\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index][0] >= this.heap[parentIndex][0]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild[0] < element[0]) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild[0] < element[0]) || (swap !== null && rightChild[0] < leftChild[0])) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds k pairs with the smallest sums.",
		"category": "Heap"
	},
	{
		"id": 124,
		"topic": "Find Median from Data Stream",
		"code": "// Find median from data stream\nclass MedianFinder {\n constructor() {\n this.small = new MaxHeap();\n this.large = new MinHeap();\n }\n addNum(num) {\n this.small.add(num);\n this.large.add(this.small.poll());\n if (this.small.size() < this.large.size()) this.small.add(this.large.poll());\n }\n findMedian() {\n return this.small.size() > this.large.size() ? this.small.peek() : (this.small.peek() + this.large.peek()) / 2;\n }\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] >= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild < element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild < element) || (swap !== null && rightChild < leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\nclass MaxHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] <= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild > element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the median from a data stream.",
		"category": "Heap"
	},
	{
		"id": 125,
		"topic": "Add Binary",
		"code": "// Add two binary numbers\nfunction addBinary(a, b) {\n let result = '', carry = 0, i = a.length - 1, j = b.length - 1;\n while (i >= 0 || j >= 0 || carry) {\n let sum = carry;\n if (i >= 0) sum += parseInt(a[i--], 2);\n if (j >= 0) sum += parseInt(b[j--], 2);\n result = (sum % 2) + result;\n carry = Math.floor(sum / 2);\n }\n return result;\n}\n",
		"explanation": "This function adds two binary numbers and returns the result as a binary string.",
		"category": "Bit Manipulation"
	},
	{
		"id": 126,
		"topic": "Reverse Bits",
		"code": "// Reverse bits of a given 32 bits unsigned integer\nfunction reverseBits(n) {\n let result = 0;\n for (let i = 0; i < 32; i++) {\n result = (result << 1) | (n & 1);\n n >>>= 1;\n }\n return result >>> 0;\n}\n",
		"explanation": "This function reverses the bits of a given 32 bits unsigned integer.",
		"category": "Bit Manipulation"
	},
	{
		"id": 127,
		"topic": "Number of 1 Bits",
		"code": "// Count the number of 1 bits\nfunction hammingWeight(n) {\n let count = 0;\n while (n !== 0) {\n count += n & 1;\n n >>>= 1;\n }\n return count;\n}\n",
		"explanation": "This function counts the number of 1 bits in a given integer.",
		"category": "Bit Manipulation"
	},
	{
		"id": 128,
		"topic": "Single Number",
		"code": "// Find the single number\nfunction singleNumber(nums) {\n let result = 0;\n for (let num of nums) {\n result ^= num;\n }\n return result;\n}\n",
		"explanation": "This function finds the single number in an array where every other number appears twice.",
		"category": "Bit Manipulation"
	},
	{
		"id": 129,
		"topic": "Single Number II",
		"code": "// Find the single number that appears only once\nfunction singleNumber(nums) {\n let ones = 0, twos = 0;\n for (let num of nums) {\n ones = (ones ^ num) & ~twos;\n twos = (twos ^ num) & ~ones;\n }\n return ones;\n}\n",
		"explanation": "This function finds the single number that appears only once in an array where every other number appears three times.",
		"category": "Bit Manipulation"
	},
	{
		"id": 130,
		"topic": "Bitwise AND of Numbers Range",
		"code": "// Find the bitwise AND of numbers range\nfunction rangeBitwiseAnd(m, n) {\n let shift = 0;\n while (m < n) {\n m >>= 1;\n n >>= 1;\n shift++;\n }\n return m << shift;\n}\n",
		"explanation": "This function finds the bitwise AND of all numbers in a given range.",
		"category": "Bit Manipulation"
	},
	{
		"id": 131,
		"topic": "Palindrome Number",
		"code": "// Check if a number is a palindrome\nfunction isPalindrome(x) {\n if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n let revertedNumber = 0;\n while (x > revertedNumber) {\n revertedNumber = revertedNumber * 10 + x % 10;\n x = Math.floor(x / 10);\n }\n return x === revertedNumber || x === Math.floor(revertedNumber / 10);\n}\n",
		"explanation": "This function checks if a number is a palindrome.",
		"category": "Math"
	},
	{
		"id": 132,
		"topic": "Plus One",
		"code": "// Increment a number represented as an array\nfunction plusOne(digits) {\n for (let i = digits.length - 1; i >= 0; i--) {\n if (digits[i] < 9) {\n digits[i]++;\n return digits;\n }\n digits[i] = 0;\n }\n digits.unshift(1);\n return digits;\n}\n",
		"explanation": "This function increments a number represented as an array of digits by one.",
		"category": "Math"
	},
	{
		"id": 133,
		"topic": "Factorial Trailing Zeroes",
		"code": "// Find the number of trailing zeroes in factorial\nfunction trailingZeroes(n) {\n let count = 0;\n while (n > 0) {\n n = Math.floor(n / 5);\n count += n;\n }\n return count;\n}\n",
		"explanation": "This function finds the number of trailing zeroes in the factorial of a given number.",
		"category": "Math"
	},
	{
		"id": 134,
		"topic": "Sqrt(x)",
		"code": "// Calculate the square root of x\nfunction mySqrt(x) {\n if (x === 0) return 0;\n let left = 1, right = x;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (mid * mid === x) return mid;\n if (mid * mid < x) left = mid + 1;\n else right = mid - 1;\n }\n return right;\n}\n",
		"explanation": "This function calculates the square root of x using binary search.",
		"category": "Math"
	},
	{
		"id": 135,
		"topic": "Pow(x, n)",
		"code": "// Calculate x raised to the power n\nfunction myPow(x, n) {\n if (n === 0) return 1;\n if (n < 0) return 1 / myPow(x, -n);\n if (n % 2 === 0) return myPow(x * x, n / 2);\n return x * myPow(x * x, (n - 1) / 2);\n}\n",
		"explanation": "This function calculates x raised to the power n using recursion.",
		"category": "Math"
	},
	{
		"id": 136,
		"topic": "Max Points on a Line",
		"code": "// Find the maximum number of points on a line\nfunction maxPoints(points) {\n if (points.length < 3) return points.length;\n let max = 0;\n for (let i = 0; i < points.length; i++) {\n let map = new Map(), duplicates = 1;\n for (let j = i + 1; j < points.length; j++) {\n let dx = points[j][0] - points[i][0];\n let dy = points[j][1] - points[i][1];\n if (dx === 0 && dy === 0) {\n duplicates++;\n continue;\n }\n let gcd = getGCD(dx, dy);\n dx /= gcd;\n dy /= gcd;\n let key = `${dx}/${dy}`;\n map.set(key, (map.get(key) || 0) + 1);\n }\n max = Math.max(max, duplicates);\n for (let count of map.values()) {\n max = Math.max(max, count + duplicates);\n }\n }\n return max;\n}\nfunction getGCD(a, b) {\n if (b === 0) return a;\n return getGCD(b, a % b);\n}\n",
		"explanation": "This function finds the maximum number of points on a line.",
		"category": "Math"
	},
	{
		"id": 137,
		"topic": "Climbing Stairs",
		"code": "// Find the number of ways to climb stairs\nfunction climbStairs(n) {\n if (n <= 2) return n;\n let a = 1, b = 2;\n for (let i = 3; i <= n; i++) {\n let temp = a + b;\n a = b;\n b = temp;\n }\n return b;\n}\n",
		"explanation": "This function finds the number of ways to climb a staircase with n steps.",
		"category": "1D DP"
	},
	{
		"id": 138,
		"topic": "House Robber",
		"code": "// Find the maximum amount of money you can rob\nfunction rob(nums) {\n if (nums.length === 0) return 0;\n if (nums.length === 1) return nums[0];\n let dp = [nums[0], Math.max(nums[0], nums[1])];\n for (let i = 2; i < nums.length; i++) {\n dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n }\n return dp[nums.length - 1];\n}\n",
		"explanation": "This function finds the maximum amount of money you can rob from houses without robbing two adjacent houses.",
		"category": "1D DP"
	},
	{
		"id": 139,
		"topic": "Word Break",
		"code": "// Determine if you can segment the string into words\nfunction wordBreak(s, wordDict) {\n let dp = Array(s.length + 1).fill(false);\n dp[0] = true;\n for (let i = 1; i <= s.length; i++) {\n for (let j = 0; j < i; j++) {\n if (dp[j] && wordDict.includes(s.slice(j, i))) {\n dp[i] = true;\n break;\n }\n }\n }\n return dp[s.length];\n}\n",
		"explanation": "This function determines if you can segment the string into words from the dictionary.",
		"category": "1D DP"
	},
	{
		"id": 140,
		"topic": "Coin Change",
		"code": "// Find the minimum number of coins to make up a given amount\nfunction coinChange(coins, amount) {\n let dp = Array(amount + 1).fill(Infinity);\n dp[0] = 0;\n for (let coin of coins) {\n for (let i = coin; i <= amount; i++) {\n dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n }\n }\n return dp[amount] === Infinity ? -1 : dp[amount];\n}\n",
		"explanation": "This function finds the minimum number of coins needed to make up a given amount.",
		"category": "1D DP"
	},
	{
		"id": 141,
		"topic": "Longest Increasing Subsequence",
		"code": "// Find the length of the longest increasing subsequence\nfunction lengthOfLIS(nums) {\n let dp = Array(nums.length).fill(1);\n for (let i = 1; i < nums.length; i++) {\n for (let j = 0; j < i; j++) {\n if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);\n }\n }\n return Math.max(...dp);\n}\n",
		"explanation": "This function finds the length of the longest increasing subsequence in an array.",
		"category": "1D DP"
	},
	{
		"id": 142,
		"topic": "Triangle",
		"code": "// Find the minimum path sum from top to bottom\nfunction minimumTotal(triangle) {\n let dp = triangle[triangle.length - 1];\n for (let i = triangle.length - 2; i >= 0; i--) {\n for (let j = 0; j < triangle[i].length; j++) {\n dp[j] = triangle[i][j] + Math.min(dp[j], dp[j + 1]);\n }\n }\n return dp[0];\n}\n",
		"explanation": "This function finds the minimum path sum from top to bottom in a triangle.",
		"category": "Multidimensional DP"
	},
	{
		"id": 143,
		"topic": "Minimum Path Sum",
		"code": "// Find the minimum path sum in a grid\nfunction minPathSum(grid) {\n let m = grid.length, n = grid[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n dp[0][0] = grid[0][0];\n for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];\n for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];\n for (let i = 1; i < m; i++) {\n for (let j = 1; j < n; j++) {\n dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);\n }\n }\n return dp[m - 1][n - 1];\n}\n",
		"explanation": "This function finds the minimum path sum in a grid from top-left to bottom-right.",
		"category": "Multidimensional DP"
	},
	{
		"id": 144,
		"topic": "Unique Paths II",
		"code": "// Find the number of unique paths in a grid with obstacles\nfunction uniquePathsWithObstacles(obstacleGrid) {\n let m = obstacleGrid.length, n = obstacleGrid[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n dp[0][0] = obstacleGrid[0][0] === 1 ? 0 : 1;\n for (let i = 1; i < m; i++) dp[i][0] = obstacleGrid[i][0] === 1 ? 0 : dp[i - 1][0];\n for (let j = 1; j < n; j++) dp[0][j] = obstacleGrid[0][j] === 1 ? 0 : dp[0][j - 1];\n for (let i = 1; i < m; i++) {\n for (let j = 1; j < n; j++) {\n if (obstacleGrid[i][j] === 1) dp[i][j] = 0;\n else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n }\n }\n return dp[m - 1][n - 1];\n}\n",
		"explanation": "This function finds the number of unique paths in a grid with obstacles from top-left to bottom-right.",
		"category": "Multidimensional DP"
	},
	{
		"id": 145,
		"topic": "Longest Palindromic Substring",
		"code": "// Find the longest palindromic substring\nfunction longestPalindrome(s) {\n let n = s.length;\n let dp = Array(n).fill().map(() => Array(n).fill(false));\n let maxLength = 1, start = 0;\n for (let i = 0; i < n; i++) dp[i][i] = true;\n for (let i = 0; i < n - 1; i++) {\n if (s[i] === s[i + 1]) {\n dp[i][i + 1] = true;\n start = i;\n maxLength = 2;\n }\n }\n for (let k = 3; k <= n; k++) {\n for (let i = 0; i < n - k + 1; i++) {\n let j = i + k - 1;\n if (dp[i + 1][j - 1] && s[i] === s[j]) {\n dp[i][j] = true;\n if (k > maxLength) {\n start = i;\n maxLength = k;\n }\n }\n }\n }\n return s.substring(start, start + maxLength);\n}\n",
		"explanation": "This function finds the longest palindromic substring in a given string.",
		"category": "Multidimensional DP"
	},
	{
		"id": 146,
		"topic": "Interleaving String",
		"code": "// Determine if s3 is an interleaving of s1 and s2\nfunction isInterleave(s1, s2, s3) {\n if (s1.length + s2.length !== s3.length) return false;\n let dp = Array(s1.length + 1).fill().map(() => Array(s2.length + 1).fill(false));\n dp[0][0] = true;\n for (let i = 1; i <= s1.length; i++) dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\n for (let j = 1; j <= s2.length; j++) dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\n for (let i = 1; i <= s1.length; i++) {\n for (let j = 1; j <= s2.length; j++) {\n dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n }\n }\n return dp[s1.length][s2.length];\n}\n",
		"explanation": "This function determines if s3 is an interleaving of s1 and s2.",
		"category": "Multidimensional DP"
	},
	{
		"id": 147,
		"topic": "Edit Distance",
		"code": "// Find the minimum edit distance between two strings\nfunction minDistance(word1, word2) {\n let m = word1.length, n = word2.length;\n let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n for (let i = 0; i <= m; i++) dp[i][0] = i;\n for (let j = 0; j <= n; j++) dp[0][j] = j;\n for (let i = 1; i <= m; i++) {\n for (let j = 1; j <= n; j++) {\n if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n else dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;\n }\n }\n return dp[m][n];\n}\n",
		"explanation": "This function finds the minimum edit distance between two strings.",
		"category": "Multidimensional DP"
	},
	{
		"id": 148,
		"topic": "Best Time to Buy and Sell Stock III",
		"code": "// Find the maximum profit with at most two transactions\nfunction maxProfit(prices) {\n let t1Cost = Infinity, t2Cost = Infinity;\n let t1Profit = 0, t2Profit = 0;\n for (let price of prices) {\n t1Cost = Math.min(t1Cost, price);\n t1Profit = Math.max(t1Profit, price - t1Cost);\n t2Cost = Math.min(t2Cost, price - t1Profit);\n t2Profit = Math.max(t2Profit, price - t2Cost);\n }\n return t2Profit;\n}\n",
		"explanation": "This function finds the maximum profit with at most two transactions.",
		"category": "Multidimensional DP"
	},
	{
		"id": 149,
		"topic": "Best Time to Buy and Sell Stock IV",
		"code": "// Find the maximum profit with at most k transactions\nfunction maxProfit(k, prices) {\n if (prices.length === 0) return 0;\n if (k >= prices.length / 2) {\n let profit = 0;\n for (let i = 1; i < prices.length; i++) {\n if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\n }\n return profit;\n }\n let dp = Array(k + 1).fill().map(() => Array(prices.length).fill(0));\n for (let i = 1; i <= k; i++) {\n let maxDiff = -prices[0];\n for (let j = 1; j < prices.length; j++) {\n dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n }\n }\n return dp[k][prices.length - 1];\n}\n",
		"explanation": "This function finds the maximum profit with at most k transactions.",
		"category": "Multidimensional DP"
	},
	{
		"id": 150,
		"topic": "Maximal Square",
		"code": "// Find the largest square containing only 1's\nfunction maximalSquare(matrix) {\n if (matrix.length === 0) return 0;\n let m = matrix.length, n = matrix[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n let maxSide = 0;\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n if (matrix[i][j] === '1') {\n if (i === 0 || j === 0) dp[i][j] = 1;\n else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n maxSide = Math.max(maxSide, dp[i][j]);\n }\n }\n }\n return maxSide * maxSide;\n}\n",
		"explanation": "This function finds the largest square containing only 1's in a binary matrix.",
		"category": "Multidimensional DP"
	}
]
