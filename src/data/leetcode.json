[
	{
		"topic": "Merge Sorted Array",
		"code": "// Merge two sorted arrays\nfunction merge(nums1, m, nums2, n) {\n let i = m - 1, j = n - 1, k = m + n - 1;\n while (i >= 0 && j >= 0) {\n nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n }\n while (j >= 0) {\n nums1[k--] = nums2[j--];\n }\n}\n",
		"explanation": "This function merges two sorted arrays into one sorted array in-place.",
		"category": "Array / String"
	},
	{
		"topic": "Remove Element",
		"code": "// Remove element from array\nfunction removeElement(nums, val) {\n let k = 0;\n for (let i = 0; i < nums.length; i++) {\n if (nums[i] !== val) {\n nums[k++] = nums[i];\n }\n }\n return k;\n}\n",
		"explanation": "This function removes all instances of a value in-place and returns the new length of the array.",
		"category": "Array / String"
	},
	{
		"topic": "Remove Duplicates from Sorted Array",
		"code": "// Remove duplicates from sorted array\nfunction removeDuplicates(nums) {\n if (nums.length === 0) return 0;\n let k = 1;\n for (let i = 1; i < nums.length; i++) {\n if (nums[i] !== nums[i - 1]) {\n nums[k++] = nums[i];\n }\n }\n return k;\n}\n",
		"explanation": "This function removes duplicates from a sorted array in-place and returns the new length.",
		"category": "Array / String"
	},
	{
		"topic": "Remove Duplicates from Sorted Array II",
		"code": "// Remove duplicates from sorted array allowing at most two occurrences\nfunction removeDuplicates(nums) {\n let k = 0;\n for (let num of nums) {\n if (k < 2 || num > nums[k - 2]) {\n nums[k++] = num;\n }\n }\n return k;\n}\n",
		"explanation": "This function removes duplicates from a sorted array allowing at most two occurrences and returns the new length.",
		"category": "Array / String"
	},
	{
		"topic": "Majority Element",
		"code": "// Find majority element\nfunction majorityElement(nums) {\n let count = 0, candidate = null;\n for (let num of nums) {\n if (count === 0) {\n candidate = num;\n }\n count += (num === candidate) ? 1 : -1;\n }\n return candidate;\n}\n",
		"explanation": "This function finds the majority element in an array using the Boyer-Moore Voting Algorithm.",
		"category": "Array / String"
	},
	{
		"topic": "Rotate Array",
		"code": "// Rotate array to the right by k steps\nfunction rotate(nums, k) {\n k = k % nums.length;\n nums.reverse();\n reverse(nums, 0, k - 1);\n reverse(nums, k, nums.length - 1);\n}\nfunction reverse(nums, start, end) {\n while (start < end) {\n [nums[start], nums[end]] = [nums[end], nums[start]];\n start++;\n end--;\n }\n}\n",
		"explanation": "This function rotates an array to the right by k steps using array reversal.",
		"category": "Array / String"
	},
	{
		"topic": "Best Time to Buy and Sell Stock",
		"code": "// Find the maximum profit\nfunction maxProfit(prices) {\n let minPrice = Infinity, maxProfit = 0;\n for (let price of prices) {\n if (price < minPrice) minPrice = price;\n else if (price - minPrice > maxProfit) maxProfit = price - minPrice;\n }\n return maxProfit;\n}\n",
		"explanation": "This function finds the maximum profit from buying and selling a stock once.",
		"category": "Array / String"
	},
	{
		"topic": "Best Time to Buy and Sell Stock II",
		"code": "// Find the maximum profit with multiple transactions\nfunction maxProfit(prices) {\n let profit = 0;\n for (let i = 1; i < prices.length; i++) {\n if (prices[i] > prices[i - 1]) {\n profit += prices[i] - prices[i - 1];\n }\n }\n return profit;\n}\n",
		"explanation": "This function finds the maximum profit from multiple transactions.",
		"category": "Array / String"
	},
	{
		"topic": "Jump Game",
		"code": "// Determine if you can reach the last index\nfunction canJump(nums) {\n let maxReach = 0;\n for (let i = 0; i < nums.length; i++) {\n if (i > maxReach) return false;\n maxReach = Math.max(maxReach, i + nums[i]);\n }\n return true;\n}\n",
		"explanation": "This function determines if you can reach the last index of the array.",
		"category": "Array / String"
	},
	{
		"topic": "Jump Game II",
		"code": "// Find the minimum number of jumps to reach the last index\nfunction jump(nums) {\n let jumps = 0, currentEnd = 0, farthest = 0;\n for (let i = 0; i < nums.length - 1; i++) {\n farthest = Math.max(farthest, i + nums[i]);\n if (i === currentEnd) {\n jumps++;\n currentEnd = farthest;\n }\n }\n return jumps;\n}\n",
		"explanation": "This function finds the minimum number of jumps to reach the last index of the array.",
		"category": "Array / String"
	},
	{
		"topic": "H-Index",
		"code": "// Calculate H-Index\nfunction hIndex(citations) {\n citations.sort((a, b) => b - a);\n let h = 0;\n while (h < citations.length && citations[h] > h) {\n h++;\n }\n return h;\n}\n",
		"explanation": "This function calculates the H-Index given an array of citations.",
		"category": "Array / String"
	},
	{
		"topic": "Insert Delete GetRandom O(1)",
		"code": "// Implement Insert Delete GetRandom O(1)\nclass RandomizedSet {\n constructor() {\n this.map = new Map();\n this.list = [];\n }\n insert(val) {\n if (this.map.has(val)) return false;\n this.map.set(val, this.list.length);\n this.list.push(val);\n return true;\n }\n remove(val) {\n if (!this.map.has(val)) return false;\n let index = this.map.get(val);\n let lastElement = this.list.pop();\n if (index < this.list.length) {\n this.list[index] = lastElement;\n this.map.set(lastElement, index);\n }\n this.map.delete(val);\n return true;\n }\n getRandom() {\n return this.list[Math.floor(Math.random() * this.list.length)];\n }\n}\n",
		"explanation": "This class implements a data structure that supports insert, delete, and getRandom operations in O(1) time.",
		"category": "Array / String"
	},
	{
		"topic": "Product of Array Except Self",
		"code": "// Calculate product of array except self\nfunction productExceptSelf(nums) {\n let output = Array(nums.length).fill(1);\n let left = 1, right = 1;\n for (let i = 0; i < nums.length; i++) {\n output[i] *= left;\n left *= nums[i];\n }\n for (let i = nums.length - 1; i >= 0; i--) {\n output[i] *= right;\n right *= nums[i];\n }\n return output;\n}\n",
		"explanation": "This function returns an array where each element is the product of all the elements of the input array except itself.",
		"category": "Array / String"
	},
	{
		"topic": "Gas Station",
		"code": "// Find the starting gas station\nfunction canCompleteCircuit(gas, cost) {\n let total = 0, tank = 0, start = 0;\n for (let i = 0; i < gas.length; i++) {\n total += gas[i] - cost[i];\n tank += gas[i] - cost[i];\n if (tank < 0) {\n start = i + 1;\n tank = 0;\n }\n }\n return total >= 0 ? start : -1;\n}\n",
		"explanation": "This function finds the starting gas station index from which you can complete the circuit.",
		"category": "Array / String"
	},
	{
		"topic": "Candy",
		"code": "// Distribute candies\nfunction candy(ratings) {\n let candies = Array(ratings.length).fill(1);\n for (let i = 1; i < ratings.length; i++) {\n if (ratings[i] > ratings[i - 1]) {\n candies[i] = candies[i - 1] + 1;\n }\n }\n for (let i = ratings.length - 2; i >= 0; i--) {\n if (ratings[i] > ratings[i + 1]) {\n candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n }\n }\n return candies.reduce((a, b) => a + b, 0);\n}\n",
		"explanation": "This function distributes candies to children such that each child must have at least one candy and children with a higher rating get more candies than their neighbors.",
		"category": "Array / String"
	},
	{
		"topic": "Trapping Rain Water",
		"code": "// Calculate trapped rain water\nfunction trap(height) {\n let left = 0, right = height.length - 1;\n let leftMax = 0, rightMax = 0, water = 0;\n while (left < right) {\n if (height[left] < height[right]) {\n height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n left++;\n } else {\n height[right] >= rightMax ? rightMax = height[right] : water += rightMax - height[right];\n right--;\n }\n }\n return water;\n}\n",
		"explanation": "This function calculates the amount of water that can be trapped after raining given an array of heights.",
		"category": "Array / String"
	},
	{
		"topic": "Roman to Integer",
		"code": "// Convert Roman numeral to integer\nfunction romanToInt(s) {\n const map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };\n let num = 0;\n for (let i = 0; i < s.length; i++) {\n if (i < s.length - 1 && map[s[i]] < map[s[i + 1]]) {\n num -= map[s[i]];\n } else {\n num += map[s[i]];\n }\n }\n return num;\n}\n",
		"explanation": "This function converts a Roman numeral to an integer.",
		"category": "Array / String"
	},
	{
		"topic": "Integer to Roman",
		"code": "// Convert integer to Roman numeral\nfunction intToRoman(num) {\n const map = [\n ['M', 1000], ['CM', 900], ['D', 500], ['CD', 400],\n ['C', 100], ['XC', 90], ['L', 50], ['XL', 40],\n ['X', 10], ['IX', 9], ['V', 5], ['IV', 4], ['I', 1]\n ];\n let roman = '';\n for (let [symbol, value] of map) {\n while (num >= value) {\n roman += symbol;\n num -= value;\n }\n }\n return roman;\n}\n",
		"explanation": "This function converts an integer to a Roman numeral.",
		"category": "Array / String"
	},
	{
		"topic": "Length of Last Word",
		"code": "// Find length of last word\nfunction lengthOfLastWord(s) {\n return s.trim().split(' ').pop().length;\n}\n",
		"explanation": "This function returns the length of the last word in a given string.",
		"category": "Array / String"
	},
	{
		"topic": "Longest Common Prefix",
		"code": "// Find longest common prefix\nfunction longestCommonPrefix(strs) {\n if (!strs.length) return '';\n let prefix = strs[0];\n for (let i = 1; i < strs.length; i++) {\n while (strs[i].indexOf(prefix) !== 0) {\n prefix = prefix.slice(0, -1);\n if (!prefix) return '';\n }\n }\n return prefix;\n}\n",
		"explanation": "This function finds the longest common prefix string amongst an array of strings.",
		"category": "Array / String"
	},
	{
		"topic": "Reverse Words in a String",
		"code": "// Reverse words in a string\nfunction reverseWords(s) {\n return s.trim().split(/s+/).reverse().join(' ');\n}\n",
		"explanation": "This function reverses the words in a given string.",
		"category": "Array / String"
	},
	{
		"topic": "Zigzag Conversion",
		"code": "// Convert string to zigzag pattern\nfunction convert(s, numRows) {\n if (numRows === 1) return s;\n let rows = Array(Math.min(numRows, s.length)).fill('');\n let curRow = 0, goingDown = false;\n for (let c of s) {\n rows[curRow] += c;\n if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown;\n curRow += goingDown ? 1 : -1;\n }\n return rows.join('');\n}\n",
		"explanation": "This function converts a string to a zigzag pattern on a given number of rows.",
		"category": "Array / String"
	},
	{
		"topic": "Find the Index of the First Occurrence in a String",
		"code": "// Find the index of the first occurrence in a string\nfunction strStr(haystack, needle) {\n if (!needle) return 0;\n for (let i = 0; i <= haystack.length - needle.length; i++) {\n if (haystack.slice(i, i + needle.length) === needle) return i;\n }\n return -1;\n}\n",
		"explanation": "This function finds the index of the first occurrence of a substring in a string.",
		"category": "Array / String"
	},
	{
		"topic": "Text Justification",
		"code": "// Justify text\nfunction fullJustify(words, maxWidth) {\n let result = [], line = [], lineLength = 0;\n for (let word of words) {\n if (lineLength + word.length + line.length > maxWidth) {\n for (let i = 0; i < maxWidth - lineLength; i++) {\n line[i % (line.length - 1 || 1)] += ' ';\n }\n result.push(line.join(''));\n line = [];\n lineLength = 0;\n }\n line.push(word);\n lineLength += word.length;\n }\n result.push(line.join(' ') + ' '.repeat(maxWidth - lineLength - line.length + 1));\n return result;\n}\n",
		"explanation": "This function justifies text to a given width.",
		"category": "Array / String"
	},
	{
		"topic": "Valid Palindrome",
		"code": "// Check if a string is a valid palindrome\nfunction isPalindrome(s) {\n s = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase();\n let left = 0, right = s.length - 1;\n while (left < right) {\n if (s[left] !== s[right]) return false;\n left++;\n right--;\n }\n return true;\n}\n",
		"explanation": "This function checks if a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases.",
		"category": "Two Pointers"
	},
	{
		"topic": "Is Subsequence",
		"code": "// Check if s is a subsequence of t\nfunction isSubsequence(s, t) {\n let i = 0, j = 0;\n while (i < s.length && j < t.length) {\n if (s[i] === t[j]) i++;\n j++;\n }\n return i === s.length;\n}\n",
		"explanation": "This function checks if string s is a subsequence of string t.",
		"category": "Two Pointers"
	},
	{
		"topic": "Two Sum II - Input Array Is Sorted",
		"code": "// Find two numbers that add up to a specific target\nfunction twoSum(numbers, target) {\n let left = 0, right = numbers.length - 1;\n while (left < right) {\n let sum = numbers[left] + numbers[right];\n if (sum === target) return [left + 1, right + 1];\n else if (sum < target) left++;\n else right--;\n }\n return [];\n}\n",
		"explanation": "This function finds two numbers in a sorted array that add up to a specific target and returns their indices.",
		"category": "Two Pointers"
	},
	{
		"topic": "Container With Most Water",
		"code": "// Find the container with the most water\nfunction maxArea(height) {\n let left = 0, right = height.length - 1, maxArea = 0;\n while (left < right) {\n let width = right - left;\n let h = Math.min(height[left], height[right]);\n maxArea = Math.max(maxArea, width * h);\n if (height[left] < height[right]) left++;\n else right--;\n }\n return maxArea;\n}\n",
		"explanation": "This function finds the container that can hold the most water given an array of heights.",
		"category": "Two Pointers"
	},
	{
		"topic": "3Sum",
		"code": "// Find all unique triplets that sum up to zero\nfunction threeSum(nums) {\n nums.sort((a, b) => a - b);\n let result = [];\n for (let i = 0; i < nums.length - 2; i++) {\n if (i > 0 && nums[i] === nums[i - 1]) continue;\n let left = i + 1, right = nums.length - 1;\n while (left < right) {\n let sum = nums[i] + nums[left] + nums[right];\n if (sum === 0) {\n result.push([nums[i], nums[left], nums[right]]);\n while (nums[left] === nums[left + 1]) left++;\n while (nums[right] === nums[right - 1]) right--;\n left++;\n right--;\n } else if (sum < 0) left++;\n else right--;\n }\n }\n return result;\n}\n",
		"explanation": "This function finds all unique triplets in the array that sum up to zero.",
		"category": "Two Pointers"
	},
	{
		"topic": "Minimum Size Subarray Sum",
		"code": "// Find the minimum size subarray sum\nfunction minSubArrayLen(target, nums) {\n let left = 0, sum = 0, minLength = Infinity;\n for (let right = 0; right < nums.length; right++) {\n sum += nums[right];\n while (sum >= target) {\n minLength = Math.min(minLength, right - left + 1);\n sum -= nums[left++];\n }\n }\n return minLength === Infinity ? 0 : minLength;\n}\n",
		"explanation": "This function finds the minimal length of a contiguous subarray of which the sum is at least the target.",
		"category": "Sliding Window"
	},
	{
		"topic": "Longest Substring Without Repeating Characters",
		"code": "// Find the length of the longest substring without repeating characters\nfunction lengthOfLongestSubstring(s) {\n let map = new Map(), left = 0, maxLength = 0;\n for (let right = 0; right < s.length; right++) {\n if (map.has(s[right])) left = Math.max(map.get(s[right]) + 1, left);\n map.set(s[right], right);\n maxLength = Math.max(maxLength, right - left + 1);\n }\n return maxLength;\n}\n",
		"explanation": "This function finds the length of the longest substring without repeating characters.",
		"category": "Sliding Window"
	},
	{
		"topic": "Substring with Concatenation of All Words",
		"code": "// Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once\nfunction findSubstring(s, words) {\n if (!s || !words || !words.length) return [];\n let wordLength = words[0].length, wordCount = words.length, totalLength = wordLength * wordCount;\n let wordMap = new Map();\n for (let word of words) wordMap.set(word, (wordMap.get(word) || 0) + 1);\n let result = [];\n for (let i = 0; i < wordLength; i++) {\n let left = i, right = i, count = 0, currentMap = new Map();\n while (right + wordLength <= s.length) {\n let word = s.slice(right, right + wordLength);\n right += wordLength;\n if (wordMap.has(word)) {\n currentMap.set(word, (currentMap.get(word) || 0) + 1);\n count++;\n while (currentMap.get(word) > wordMap.get(word)) {\n let leftWord = s.slice(left, left + wordLength);\n currentMap.set(leftWord, currentMap.get(leftWord) - 1);\n count--;\n left += wordLength;\n }\n if (count === wordCount) result.push(left);\n } else {\n currentMap.clear();\n count = 0;\n left = right;\n }\n }\n }\n return result;\n}\n",
		"explanation": "This function finds all starting indices of substring(s) in s that is a concatenation of each word in words exactly once.",
		"category": "Sliding Window"
	},
	{
		"topic": "Minimum Window Substring",
		"code": "// Find the minimum window substring\nfunction minWindow(s, t) {\n let map = new Map();\n for (let char of t) map.set(char, (map.get(char) || 0) + 1);\n let left = 0, right = 0, count = t.length, minLength = Infinity, minStart = 0;\n while (right < s.length) {\n if (map.get(s[right]) > 0) count--;\n map.set(s[right], (map.get(s[right]) || 0) - 1);\n right++;\n while (count === 0) {\n if (right - left < minLength) {\n minLength = right - left;\n minStart = left;\n }\n map.set(s[left], (map.get(s[left]) || 0) + 1);\n if (map.get(s[left]) > 0) count++;\n left++;\n }\n }\n return minLength === Infinity ? '' : s.slice(minStart, minStart + minLength);\n}\n",
		"explanation": "This function finds the minimum window substring in s that contains all the characters in t.",
		"category": "Sliding Window"
	},
	{
		"topic": "Valid Sudoku",
		"code": "// Check if a Sudoku board is valid\nfunction isValidSudoku(board) {\n let rows = Array(9).fill().map(() => new Set());\n let cols = Array(9).fill().map(() => new Set());\n let boxes = Array(9).fill().map(() => new Set());\n for (let r = 0; r < 9; r++) {\n for (let c = 0; c < 9; c++) {\n let val = board[r][c];\n if (val === '.') continue;\n let boxIndex = Math.floor(r / 3) * 3 + Math.floor(c / 3);\n if (rows[r].has(val) || cols[c].has(val) || boxes[boxIndex].has(val)) return false;\n rows[r].add(val);\n cols[c].add(val);\n boxes[boxIndex].add(val);\n }\n }\n return true;\n}\n",
		"explanation": "This function checks if a given Sudoku board is valid.",
		"category": "Matrix"
	},
	{
		"topic": "Spiral Matrix",
		"code": "// Return all elements of the matrix in spiral order\nfunction spiralOrder(matrix) {\n let result = [];\n if (matrix.length === 0) return result;\n let top = 0, bottom = matrix.length - 1;\n let left = 0, right = matrix[0].length - 1;\n while (top <= bottom && left <= right) {\n for (let i = left; i <= right; i++) result.push(matrix[top][i]);\n top++;\n for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n right--;\n if (top <= bottom) {\n for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);\n bottom--;\n }\n if (left <= right) {\n for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n left++;\n }\n }\n return result;\n}\n",
		"explanation": "This function returns all elements of the matrix in spiral order.",
		"category": "Matrix"
	},
	{
		"topic": "Rotate Image",
		"code": "// Rotate the image by 90 degrees (clockwise)\nfunction rotate(matrix) {\n let n = matrix.length;\n for (let i = 0; i < n; i++) {\n for (let j = i; j < n; j++) {\n [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n }\n }\n for (let i = 0; i < n; i++) {\n matrix[i].reverse();\n }\n}\n",
		"explanation": "This function rotates the image (matrix) by 90 degrees clockwise.",
		"category": "Matrix"
	},
	{
		"topic": "Set Matrix Zeroes",
		"code": "// Set matrix zeroes\nfunction setZeroes(matrix) {\n let rows = new Set(), cols = new Set();\n for (let r = 0; r < matrix.length; r++) {\n for (let c = 0; c < matrix[0].length; c++) {\n if (matrix[r][c] === 0) {\n rows.add(r);\n cols.add(c);\n }\n }\n }\n for (let r of rows) {\n for (let c = 0; c < matrix[0].length; c++) {\n matrix[r][c] = 0;\n }\n }\n for (let c of cols) {\n for (let r = 0; r < matrix.length; r++) {\n matrix[r][c] = 0;\n }\n }\n}\n",
		"explanation": "This function sets the entire row and column to zeroes if an element is zero.",
		"category": "Matrix"
	},
	{
		"topic": "Game of Life",
		"code": "// Implement the Game of Life\nfunction gameOfLife(board) {\n const directions = [[0, 1], [1, 0], [1, 1], [1, -1], [-1, 0], [-1, 1], [-1, -1], [0, -1]];\n const copyBoard = board.map(arr => [...arr]);\n for (let r = 0; r < board.length; r++) {\n for (let c = 0; c < board[0].length; c++) {\n let liveNeighbors = 0;\n for (let [dr, dc] of directions) {\n let nr = r + dr, nc = c + dc;\n if (nr >= 0 && nr < board.length && nc >= 0 && nc < board[0].length && copyBoard[nr][nc] === 1) {\n liveNeighbors++;\n }\n }\n if (copyBoard[r][c] === 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n board[r][c] = 0;\n }\n if (copyBoard[r][c] === 0 && liveNeighbors === 3) {\n board[r][c] = 1;\n }\n }\n }\n}\n",
		"explanation": "This function implements the Game of Life according to the rules.",
		"category": "Matrix"
	},
	{
		"topic": "Ransom Note",
		"code": "// Check if ransom note can be constructed from magazine\nfunction canConstruct(ransomNote, magazine) {\n let map = new Map();\n for (let char of magazine) {\n map.set(char, (map.get(char) || 0) + 1);\n }\n for (let char of ransomNote) {\n if (!map.has(char) || map.get(char) === 0) return false;\n map.set(char, map.get(char) - 1);\n }\n return true;\n}\n",
		"explanation": "This function checks if a ransom note can be constructed from the letters in a magazine.",
		"category": "Hashmap"
	},
	{
		"topic": "Isomorphic Strings",
		"code": "// Check if two strings are isomorphic\nfunction isIsomorphic(s, t) {\n let mapS = new Map(), mapT = new Map();\n for (let i = 0; i < s.length; i++) {\n let charS = s[i], charT = t[i];\n if ((mapS.has(charS) && mapS.get(charS) !== charT) || (mapT.has(charT) && mapT.get(charT) !== charS)) return false;\n mapS.set(charS, charT);\n mapT.set(charT, charS);\n }\n return true;\n}\n",
		"explanation": "This function checks if two strings are isomorphic.",
		"category": "Hashmap"
	},
	{
		"topic": "Word Pattern",
		"code": "// Check if a pattern matches a string\nfunction wordPattern(pattern, s) {\n let words = s.split(' ');\n if (pattern.length !== words.length) return false;\n let mapP = new Map(), mapW = new Map();\n for (let i = 0; i < pattern.length; i++) {\n let charP = pattern[i], word = words[i];\n if ((mapP.has(charP) && mapP.get(charP) !== word) || (mapW.has(word) && mapW.get(word) !== charP)) return false;\n mapP.set(charP, word);\n mapW.set(word, charP);\n }\n return true;\n}\n",
		"explanation": "This function checks if a pattern matches a string.",
		"category": "Hashmap"
	},
	{
		"topic": "Valid Anagram",
		"code": "// Check if two strings are anagrams\nfunction isAnagram(s, t) {\n if (s.length !== t.length) return false;\n let map = new Map();\n for (let char of s) {\n map.set(char, (map.get(char) || 0) + 1);\n }\n for (let char of t) {\n if (!map.has(char) || map.get(char) === 0) return false;\n map.set(char, map.get(char) - 1);\n }\n return true;\n}\n",
		"explanation": "This function checks if two strings are anagrams.",
		"category": "Hashmap"
	},
	{
		"topic": "Group Anagrams",
		"code": "// Group anagrams\nfunction groupAnagrams(strs) {\n let map = new Map();\n for (let str of strs) {\n let sortedStr = str.split('').sort().join('');\n if (!map.has(sortedStr)) map.set(sortedStr, []);\n map.get(sortedStr).push(str);\n }\n return Array.from(map.values());\n}\n",
		"explanation": "This function groups anagrams together.",
		"category": "Hashmap"
	},
	{
		"topic": "Two Sum",
		"code": "// Find two numbers that add up to a specific target\nfunction twoSum(nums, target) {\n let map = new Map();\n for (let i = 0; i < nums.length; i++) {\n let complement = target - nums[i];\n if (map.has(complement)) return [map.get(complement), i];\n map.set(nums[i], i);\n }\n return [];\n}\n",
		"explanation": "This function finds two numbers in an array that add up to a specific target and returns their indices.",
		"category": "Hashmap"
	},
	{
		"topic": "Happy Number",
		"code": "// Check if a number is a happy number\nfunction isHappy(n) {\n let seen = new Set();\n while (n !== 1 && !seen.has(n)) {\n seen.add(n);\n n = n.toString().split('').reduce((sum, num) => sum + Math.pow(num, 2), 0);\n }\n return n === 1;\n}\n",
		"explanation": "This function checks if a number is a happy number.",
		"category": "Hashmap"
	},
	{
		"topic": "Contains Duplicate II",
		"code": "// Check if the array contains duplicates within k distance\nfunction containsNearbyDuplicate(nums, k) {\n let map = new Map();\n for (let i = 0; i < nums.length; i++) {\n if (map.has(nums[i]) && i - map.get(nums[i]) <= k) return true;\n map.set(nums[i], i);\n }\n return false;\n}\n",
		"explanation": "This function checks if the array contains duplicates within k distance.",
		"category": "Hashmap"
	},
	{
		"topic": "Longest Consecutive Sequence",
		"code": "// Find the length of the longest consecutive sequence\nfunction longestConsecutive(nums) {\n let set = new Set(nums);\n let maxLength = 0;\n for (let num of nums) {\n if (!set.has(num - 1)) {\n let length = 0;\n while (set.has(num + length)) length++;\n maxLength = Math.max(maxLength, length);\n }\n }\n return maxLength;\n}\n",
		"explanation": "This function finds the length of the longest consecutive sequence in an array.",
		"category": "Hashmap"
	},
	{
		"topic": "Summary Ranges",
		"code": "// Find summary ranges\nfunction summaryRanges(nums) {\n let ranges = [];\n for (let i = 0; i < nums.length; i++) {\n let start = nums[i];\n while (i + 1 < nums.length && nums[i + 1] === nums[i] + 1) i++;\n if (start !== nums[i]) ranges.push(`${start}->${nums[i]}`);\n else ranges.push(`${start}`);\n }\n return ranges;\n}\n",
		"explanation": "This function finds the summary ranges in a sorted array without duplicates.",
		"category": "Intervals"
	},
	{
		"topic": "Merge Intervals",
		"code": "// Merge overlapping intervals\nfunction merge(intervals) {\n if (!intervals.length) return [];\n intervals.sort((a, b) => a[0] - b[0]);\n let merged = [intervals[0]];\n for (let i = 1; i < intervals.length; i++) {\n let [prevStart, prevEnd] = merged[merged.length - 1];\n let [currStart, currEnd] = intervals[i];\n if (currStart <= prevEnd) {\n merged[merged.length - 1][1] = Math.max(prevEnd, currEnd);\n } else {\n merged.push(intervals[i]);\n }\n }\n return merged;\n}\n",
		"explanation": "This function merges overlapping intervals in an array.",
		"category": "Intervals"
	},
	{
		"topic": "Insert Interval",
		"code": "// Insert a new interval into a list of non-overlapping intervals\nfunction insert(intervals, newInterval) {\n let result = [];\n let i = 0;\n while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n result.push(intervals[i++]);\n }\n while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n i++;\n }\n result.push(newInterval);\n while (i < intervals.length) {\n result.push(intervals[i++]);\n }\n return result;\n}\n",
		"explanation": "This function inserts a new interval into a list of non-overlapping intervals and merges if necessary.",
		"category": "Intervals"
	},
	{
		"topic": "Minimum Number of Arrows to Burst Balloons",
		"code": "// Find the minimum number of arrows to burst all balloons\nfunction findMinArrowShots(points) {\n if (!points.length) return 0;\n points.sort((a, b) => a[1] - b[1]);\n let arrows = 1, end = points[0][1];\n for (let i = 1; i < points.length; i++) {\n if (points[i][0] > end) {\n arrows++;\n end = points[i][1];\n }\n }\n return arrows;\n}\n",
		"explanation": "This function finds the minimum number of arrows required to burst all balloons represented as intervals.",
		"category": "Intervals"
	},
	{
		"topic": "Valid Parentheses",
		"code": "// Check if the parentheses are valid\nfunction isValid(s) {\n let stack = [];\n let map = { '(': ')', '{': '}', '[': ']' };\n for (let char of s) {\n if (map[char]) stack.push(map[char]);\n else if (stack.length === 0 || stack.pop() !== char) return false;\n }\n return stack.length === 0;\n}\n",
		"explanation": "This function checks if the parentheses in a string are valid.",
		"category": "Stack"
	},
	{
		"topic": "Simplify Path",
		"code": "// Simplify the file path\nfunction simplifyPath(path) {\n let stack = [];\n let parts = path.split('/');\n for (let part of parts) {\n if (part === '' || part === '.') continue;\n if (part === '..') stack.pop();\n else stack.push(part);\n }\n return '/' + stack.join('/');\n}\n",
		"explanation": "This function simplifies a given file path.",
		"category": "Stack"
	},
	{
		"topic": "Min Stack",
		"code": "// Implement a stack that supports push, pop, top, and retrieving the minimum element\nclass MinStack {\n constructor() {\n this.stack = [];\n this.minStack = [];\n }\n push(val) {\n this.stack.push(val);\n if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {\n this.minStack.push(val);\n }\n }\n pop() {\n let val = this.stack.pop();\n if (val === this.minStack[this.minStack.length - 1]) {\n this.minStack.pop();\n }\n }\n top() {\n return this.stack[this.stack.length - 1];\n }\n getMin() {\n return this.minStack[this.minStack.length - 1];\n }\n}\n",
		"explanation": "This class implements a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
		"category": "Stack"
	},
	{
		"topic": "Evaluate Reverse Polish Notation",
		"code": "// Evaluate the value of an arithmetic expression in Reverse Polish Notation\nfunction evalRPN(tokens) {\n let stack = [];\n for (let token of tokens) {\n if (!isNaN(token)) stack.push(Number(token));\n else {\n let b = stack.pop(), a = stack.pop();\n switch (token) {\n case '+': stack.push(a + b); break;\n case '-': stack.push(a - b); break;\n case '*': stack.push(a * b); break;\n case '/': stack.push(Math.trunc(a / b)); break;\n }\n }\n }\n return stack[0];\n}\n",
		"explanation": "This function evaluates the value of an arithmetic expression in Reverse Polish Notation.",
		"category": "Stack"
	},
	{
		"topic": "Basic Calculator",
		"code": "// Implement a basic calculator to evaluate a simple expression string\nfunction calculate(s) {\n let stack = [], num = 0, sign = 1, result = 0;\n for (let char of s) {\n if (!isNaN(char) && char !== ' ') num = num * 10 + Number(char);\n else if (char === '+') {\n result += sign * num;\n num = 0;\n sign = 1;\n } else if (char === '-') {\n result += sign * num;\n num = 0;\n sign = -1;\n } else if (char === '(') {\n stack.push(result);\n stack.push(sign);\n result = 0;\n sign = 1;\n } else if (char === ')') {\n result += sign * num;\n num = 0;\n result *= stack.pop();\n result += stack.pop();\n }\n }\n return result + (sign * num);\n}\n",
		"explanation": "This function implements a basic calculator to evaluate a simple expression string.",
		"category": "Stack"
	},
	{
		"topic": "Linked List Cycle",
		"code": "// Check if a linked list has a cycle\nfunction hasCycle(head) {\n let slow = head, fast = head;\n while (fast && fast.next) {\n slow = slow.next;\n fast = fast.next.next;\n if (slow === fast) return true;\n }\n return false;\n}\n",
		"explanation": "This function checks if a linked list has a cycle using the two-pointer technique.",
		"category": "Linked List"
	},
	{
		"topic": "Add Two Numbers",
		"code": "// Add two numbers represented by linked lists\nfunction addTwoNumbers(l1, l2) {\n let dummy = new ListNode(0);\n let p = l1, q = l2, current = dummy;\n let carry = 0;\n while (p || q) {\n let x = p ? p.val : 0;\n let y = q ? q.val : 0;\n let sum = carry + x + y;\n carry = Math.floor(sum / 10);\n current.next = new ListNode(sum % 10);\n current = current.next;\n if (p) p = p.next;\n if (q) q = q.next;\n }\n if (carry > 0) {\n current.next = new ListNode(carry);\n }\n return dummy.next;\n}\n",
		"explanation": "This function adds two numbers represented by linked lists and returns the sum as a linked list.",
		"category": "Linked List"
	},
	{
		"topic": "Merge Two Sorted Lists",
		"code": "// Merge two sorted linked lists\nfunction mergeTwoLists(l1, l2) {\n let dummy = new ListNode(0);\n let current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n}\n",
		"explanation": "This function merges two sorted linked lists and returns the merged list.",
		"category": "Linked List"
	},
	{
		"topic": "Copy List with Random Pointer",
		"code": "// Copy a linked list with random pointer\nfunction copyRandomList(head) {\n if (!head) return null;\n let map = new Map();\n let current = head;\n while (current) {\n map.set(current, new ListNode(current.val));\n current = current.next;\n }\n current = head;\n while (current) {\n map.get(current).next = map.get(current.next) || null;\n map.get(current).random = map.get(current.random) || null;\n current = current.next;\n }\n return map.get(head);\n}\n",
		"explanation": "This function copies a linked list with random pointers and returns the deep copy.",
		"category": "Linked List"
	},
	{
		"topic": "Reverse Linked List II",
		"code": "// Reverse a linked list from position m to n\nfunction reverseBetween(head, m, n) {\n if (!head) return null;\n let dummy = new ListNode(0);\n dummy.next = head;\n let prev = dummy;\n for (let i = 1; i < m; i++) prev = prev.next;\n let start = prev.next;\n let then = start.next;\n for (let i = 0; i < n - m; i++) {\n start.next = then.next;\n then.next = prev.next;\n prev.next = then;\n then = start.next;\n }\n return dummy.next;\n}\n",
		"explanation": "This function reverses a linked list from position m to n.",
		"category": "Linked List"
	},
	{
		"topic": "Reverse Nodes in k-Group",
		"code": "// Reverse nodes in k-group\nfunction reverseKGroup(head, k) {\n let count = 0;\n let node = head;\n while (node && count < k) {\n node = node.next;\n count++;\n }\n if (count === k) {\n let reversedHead = reverse(head, k);\n head.next = reverseKGroup(node, k);\n return reversedHead;\n }\n return head;\n}\nfunction reverse(head, k) {\n let prev = null, current = head;\n while (k--) {\n let next = current.next;\n current.next = prev;\n prev = current;\n current = next;\n }\n return prev;\n}\n",
		"explanation": "This function reverses nodes in k-group in a linked list.",
		"category": "Linked List"
	},
	{
		"topic": "Remove Nth Node From End of List",
		"code": "// Remove the nth node from the end of the list\nfunction removeNthFromEnd(head, n) {\n let dummy = new ListNode(0);\n dummy.next = head;\n let first = dummy, second = dummy;\n for (let i = 0; i <= n; i++) first = first.next;\n while (first) {\n first = first.next;\n second = second.next;\n }\n second.next = second.next.next;\n return dummy.next;\n}\n",
		"explanation": "This function removes the nth node from the end of the list.",
		"category": "Linked List"
	},
	{
		"topic": "Remove Duplicates from Sorted List II",
		"code": "// Remove duplicates from sorted list\nfunction deleteDuplicates(head) {\n let dummy = new ListNode(0);\n dummy.next = head;\n let prev = dummy;\n while (head) {\n if (head.next && head.val === head.next.val) {\n while (head.next && head.val === head.next.val) head = head.next;\n prev.next = head.next;\n } else {\n prev = prev.next;\n }\n head = head.next;\n }\n return dummy.next;\n}\n",
		"explanation": "This function removes duplicates from a sorted linked list.",
		"category": "Linked List"
	},
	{
		"topic": "Rotate List",
		"code": "// Rotate a linked list to the right by k places\nfunction rotateRight(head, k) {\n if (!head || !head.next) return head;\n let length = 1;\n let tail = head;\n while (tail.next) {\n tail = tail.next;\n length++;\n }\n k = k % length;\n if (k === 0) return head;\n tail.next = head;\n for (let i = 0; i < length - k; i++) tail = tail.next;\n let newHead = tail.next;\n tail.next = null;\n return newHead;\n}\n",
		"explanation": "This function rotates a linked list to the right by k places.",
		"category": "Linked List"
	},
	{
		"topic": "Partition List",
		"code": "// Partition a linked list around a value x\nfunction partition(head, x) {\n let before = new ListNode(0), after = new ListNode(0);\n let beforeHead = before, afterHead = after;\n while (head) {\n if (head.val < x) {\n before.next = head;\n before = before.next;\n } else {\n after.next = head;\n after = after.next;\n }\n head = head.next;\n }\n after.next = null;\n before.next = afterHead.next;\n return beforeHead.next;\n}\n",
		"explanation": "This function partitions a linked list around a value x.",
		"category": "Linked List"
	},
	{
		"topic": "LRU Cache",
		"code": "// Implement LRU Cache\nclass LRUCache {\n constructor(capacity) {\n this.capacity = capacity;\n this.cache = new Map();\n }\n get(key) {\n if (!this.cache.has(key)) return -1;\n let value = this.cache.get(key);\n this.cache.delete(key);\n this.cache.set(key, value);\n return value;\n }\n put(key, value) {\n if (this.cache.has(key)) this.cache.delete(key);\n this.cache.set(key, value);\n if (this.cache.size > this.capacity) this.cache.delete(this.cache.keys().next().value);\n }\n}\n",
		"explanation": "This class implements an LRU Cache.",
		"category": "Linked List"
	},
	{
		"topic": "Course Schedule",
		"code": "// Determine if you can finish all courses\nfunction canFinish(numCourses, prerequisites) {\n let graph = new Map();\n let indegree = Array(numCourses).fill(0);\n for (let [course, prereq] of prerequisites) {\n if (!graph.has(prereq)) graph.set(prereq, []);\n graph.get(prereq).push(course);\n indegree[course]++;\n }\n let queue = [];\n for (let i = 0; i < numCourses; i++) {\n if (indegree[i] === 0) queue.push(i);\n }\n let count = 0;\n while (queue.length) {\n let course = queue.shift();\n count++;\n if (graph.has(course)) {\n for (let nextCourse of graph.get(course)) {\n indegree[nextCourse]--;\n if (indegree[nextCourse] === 0) queue.push(nextCourse);\n }\n }\n }\n return count === numCourses;\n}\n",
		"explanation": "This function determines if you can finish all courses given the prerequisites.",
		"category": "Graph General"
	},
	{
		"topic": "Course Schedule II",
		"code": "// Find the order of courses to finish all courses\nfunction findOrder(numCourses, prerequisites) {\n let graph = new Map();\n let indegree = Array(numCourses).fill(0);\n for (let [course, prereq] of prerequisites) {\n if (!graph.has(prereq)) graph.set(prereq, []);\n graph.get(prereq).push(course);\n indegree[course]++;\n }\n let queue = [];\n for (let i = 0; i < numCourses; i++) {\n if (indegree[i] === 0) queue.push(i);\n }\n let order = [];\n while (queue.length) {\n let course = queue.shift();\n order.push(course);\n if (graph.has(course)) {\n for (let nextCourse of graph.get(course)) {\n indegree[nextCourse]--;\n if (indegree[nextCourse] === 0) queue.push(nextCourse);\n }\n }\n }\n return order.length === numCourses ? order : [];\n}\n",
		"explanation": "This function finds the order of courses to finish all courses given the prerequisites.",
		"category": "Graph General"
	},
	{
		"topic": "Snakes and Ladders",
		"code": "// Find the minimum number of moves to reach the last square\nfunction snakesAndLadders(board) {\n let n = board.length;\n let visited = new Set();\n let queue = [[1, 0]];\n while (queue.length) {\n let [s, moves] = queue.shift();\n for (let i = 1; i <= 6; i++) {\n let next = s + i;\n let [r, c] = [Math.floor((next - 1) / n), (next - 1) % n];\n if (r % 2 === 1) c = n - 1 - c;\n r = n - 1 - r;\n if (board[r][c] !== -1) next = board[r][c];\n if (next === n * n) return moves + 1;\n if (!visited.has(next)) {\n visited.add(next);\n queue.push([next, moves + 1]);\n }\n }\n }\n return -1;\n}\n",
		"explanation": "This function finds the minimum number of moves to reach the last square in a Snakes and Ladders game.",
		"category": "Graph BFS"
	},
	{
		"topic": "Minimum Genetic Mutation",
		"code": "// Find the minimum number of mutations to reach the end gene\nfunction minMutation(start, end, bank) {\n let bankSet = new Set(bank);\n if (!bankSet.has(end)) return -1;\n let queue = [[start, 0]];\n let visited = new Set([start]);\n let chars = ['A', 'C', 'G', 'T'];\n while (queue.length) {\n let [gene, mutations] = queue.shift();\n if (gene === end) return mutations;\n for (let i = 0; i < gene.length; i++) {\n for (let char of chars) {\n let newGene = gene.slice(0, i) + char + gene.slice(i + 1);\n if (bankSet.has(newGene) && !visited.has(newGene)) {\n visited.add(newGene);\n queue.push([newGene, mutations + 1]);\n }\n }\n }\n }\n return -1;\n}\n",
		"explanation": "This function finds the minimum number of mutations needed to reach the end gene from the start gene.",
		"category": "Graph BFS"
	},
	{
		"topic": "Word Ladder",
		"code": "// Find the length of the shortest transformation sequence from beginWord to endWord\nfunction ladderLength(beginWord, endWord, wordList) {\n let wordSet = new Set(wordList);\n if (!wordSet.has(endWord)) return 0;\n let queue = [[beginWord, 1]];\n while (queue.length) {\n let [word, length] = queue.shift();\n if (word === endWord) return length;\n for (let i = 0; i < word.length; i++) {\n for (let char of 'abcdefghijklmnopqrstuvwxyz') {\n let newWord = word.slice(0, i) + char + word.slice(i + 1);\n if (wordSet.has(newWord)) {\n wordSet.delete(newWord);\n queue.push([newWord, length + 1]);\n }\n }\n }\n }\n return 0;\n}\n",
		"explanation": "This function finds the length of the shortest transformation sequence from beginWord to endWord.",
		"category": "Graph BFS"
	},
	{
		"topic": "Pacific Atlantic Water Flow",
		"code": "// Find the cells that can flow to both the Pacific and Atlantic ocean\nfunction pacificAtlantic(matrix) {\n if (!matrix.length) return [];\n let m = matrix.length, n = matrix[0].length;\n let pacific = Array.from({ length: m }, () => Array(n).fill(false));\n let atlantic = Array.from({ length: m }, () => Array(n).fill(false));\n function dfs(i, j, ocean) {\n ocean[i][j] = true;\n for (let [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {\n let x = i + dx, y = j + dy;\n if (x >= 0 && x < m && y >= 0 && y < n && !ocean[x][y] && matrix[x][y] >= matrix[i][j]) {\n dfs(x, y, ocean);\n }\n }\n }\n for (let i = 0; i < m; i++) {\n dfs(i, 0, pacific);\n dfs(i, n - 1, atlantic);\n }\n for (let j = 0; j < n; j++) {\n dfs(0, j, pacific);\n dfs(m - 1, j, atlantic);\n }\n let result = [];\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n if (pacific[i][j] && atlantic[i][j]) result.push([i, j]);\n }\n }\n return result;\n}\n",
		"explanation": "This function finds the cells that can flow to both the Pacific and Atlantic ocean.",
		"category": "Graph BFS"
	},
	{
		"topic": "Shortest Path in Binary Matrix",
		"code": "// Find the shortest path in a binary matrix\nfunction shortestPathBinaryMatrix(grid) {\n if (grid[0][0] === 1 || grid[grid.length - 1][grid[0].length - 1] === 1) return -1;\n let directions = [[1, 0], [0, 1], [1, 1], [-1, 0], [0, -1], [-1, -1], [1, -1], [-1, 1]];\n let queue = [[0, 0, 1]];\n let visited = new Set(['0,0']);\n while (queue.length) {\n let [x, y, dist] = queue.shift();\n if (x === grid.length - 1 && y === grid[0].length - 1) return dist;\n for (let [dx, dy] of directions) {\n let nx = x + dx, ny = y + dy;\n if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length && grid[nx][ny] === 0 && !visited.has(`${nx},${ny}`)) {\n queue.push([nx, ny, dist + 1]);\n visited.add(`${nx},${ny}`);\n }\n }\n }\n return -1;\n}\n",
		"explanation": "This function finds the shortest path in a binary matrix.",
		"category": "Graph BFS"
	},
	{
		"topic": "Rotting Oranges",
		"code": "// Find the minimum time to rot all oranges\nfunction orangesRotting(grid) {\n let fresh = 0, queue = [];\n for (let i = 0; i < grid.length; i++) {\n for (let j = 0; j < grid[0].length; j++) {\n if (grid[i][j] === 1) fresh++;\n if (grid[i][j] === 2) queue.push([i, j]);\n }\n }\n let minutes = 0, directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n while (queue.length && fresh) {\n let size = queue.length;\n for (let i = 0; i < size; i++) {\n let [x, y] = queue.shift();\n for (let [dx, dy] of directions) {\n let nx = x + dx, ny = y + dy;\n if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length && grid[nx][ny] === 1) {\n grid[nx][ny] = 2;\n queue.push([nx, ny]);\n fresh--;\n }\n }\n }\n minutes++;\n }\n return fresh === 0 ? minutes : -1;\n}\n",
		"explanation": "This function finds the minimum time to rot all oranges in a grid.",
		"category": "Graph BFS"
	},
	{
		"topic": "Shortest Path to Get All Keys",
		"code": "// Find the shortest path to get all keys\nfunction shortestPathAllKeys(grid) {\n let m = grid.length, n = grid[0].length;\n let keys = 0, start = null;\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n if (grid[i][j] === '@') start = [i, j];\n if (grid[i][j] >= 'a' && grid[i][j] <= 'f') keys++;\n }\n }\n let queue = [[...start, 0, 0]];\n let visited = new Set([`${start[0]},${start[1]},0`]);\n let directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n while (queue.length) {\n let [x, y, steps, state] = queue.shift();\n for (let [dx, dy] of directions) {\n let nx = x + dx, ny = y + dy;\n if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n let cell = grid[nx][ny];\n if (cell === '#') continue;\n let newState = state;\n if (cell >= 'a' && cell <= 'f') newState |= (1 << (cell.charCodeAt(0) - 'a'.charCodeAt(0)));\n if (newState === (1 << keys) - 1) return steps + 1;\n if (cell >= 'A' && cell <= 'F' && !(state & (1 << (cell.charCodeAt(0) - 'A'.charCodeAt(0))))) continue;\n if (!visited.has(`${nx},${ny},${newState}`)) {\n visited.add(`${nx},${ny},${newState}`);\n queue.push([nx, ny, steps + 1, newState]);\n }\n }\n }\n }\n return -1;\n}\n",
		"explanation": "This function finds the shortest path to get all keys in a grid.",
		"category": "Graph BFS"
	},
	{
		"topic": "Open the Lock",
		"code": "// Find the minimum number of turns to open the lock\nfunction openLock(deadends, target) {\n let dead = new Set(deadends);\n if (dead.has('0000')) return -1;\n let queue = [['0000', 0]];\n let visited = new Set(['0000']);\n while (queue.length) {\n let [node, turns] = queue.shift();\n if (node === target) return turns;\n for (let i = 0; i < 4; i++) {\n for (let d of [-1, 1]) {\n let newDigit = (parseInt(node[i]) + d + 10) % 10;\n let newNode = node.slice(0, i) + newDigit + node.slice(i + 1);\n if (!dead.has(newNode) && !visited.has(newNode)) {\n visited.add(newNode);\n queue.push([newNode, turns + 1]);\n }\n }\n }\n }\n return -1;\n}\n",
		"explanation": "This function finds the minimum number of turns to open the lock.",
		"category": "Graph BFS"
	},
	{
		"topic": "Cut Off Trees for Golf Event",
		"code": "// Find the minimum steps to cut off all trees\nfunction cutOffTree(forest) {\n let trees = [];\n for (let i = 0; i < forest.length; i++) {\n for (let j = 0; j < forest[0].length; j++) {\n if (forest[i][j] > 1) trees.push([forest[i][j], i, j]);\n }\n }\n trees.sort((a, b) => a[0] - b[0]);\n let totalSteps = 0, start = [0, 0];\n for (let [height, x, y] of trees) {\n let steps = bfs(start, [x, y]);\n if (steps === -1) return -1;\n totalSteps += steps;\n start = [x, y];\n }\n return totalSteps;\n function bfs(start, target) {\n let queue = [[...start, 0]];\n let visited = new Set([`${start[0]},${start[1]}`]);\n let directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n while (queue.length) {\n let [x, y, steps] = queue.shift();\n if (x === target[0] && y === target[1]) return steps;\n for (let [dx, dy] of directions) {\n let nx = x + dx, ny = y + dy;\n if (nx >= 0 && nx < forest.length && ny >= 0 && ny < forest[0].length && forest[nx][ny] !== 0 && !visited.has(`${nx},${ny}`)) {\n visited.add(`${nx},${ny}`);\n queue.push([nx, ny, steps + 1]);\n }\n }\n }\n return -1;\n }\n}\n",
		"explanation": "This function finds the minimum steps to cut off all trees in a forest for a golf event.",
		"category": "Graph BFS"
	},
	{
		"topic": "Implement Trie (Prefix Tree)",
		"code": "// Implement a Trie (Prefix Tree)\nclass Trie {\n constructor() {\n this.children = {};\n this.isEndOfWord = false;\n }\n insert(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) node.children[char] = new Trie();\n node = node.children[char];\n }\n node.isEndOfWord = true;\n }\n search(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) return false;\n node = node.children[char];\n }\n return node.isEndOfWord;\n }\n startsWith(prefix) {\n let node = this;\n for (let char of prefix) {\n if (!node.children[char]) return false;\n node = node.children[char];\n }\n return true;\n }\n}\n",
		"explanation": "This class implements a Trie (Prefix Tree) with insert, search, and startsWith methods.",
		"category": "Trie"
	},
	{
		"topic": "Design Add and Search Words Data Structure",
		"code": "// Design a data structure that supports adding and searching words\nclass WordDictionary {\n constructor() {\n this.children = {};\n this.isEndOfWord = false;\n }\n addWord(word) {\n let node = this;\n for (let char of word) {\n if (!node.children[char]) node.children[char] = new WordDictionary();\n node = node.children[char];\n }\n node.isEndOfWord = true;\n }\n search(word) {\n function dfs(node, i) {\n if (i === word.length) return node.isEndOfWord;\n if (word[i] === '.') {\n for (let child in node.children) {\n if (dfs(node.children[child], i + 1)) return true;\n }\n return false;\n }\n if (!node.children[word[i]]) return false;\n return dfs(node.children[word[i]], i + 1);\n }\n return dfs(this, 0);\n }\n}\n",
		"explanation": "This class implements a data structure that supports adding and searching words with '.' as a wildcard character.",
		"category": "Trie"
	},
	{
		"topic": "Word Search II",
		"code": "// Find all words in the board\nfunction findWords(board, words) {\n let result = [];\n let trie = new Trie();\n for (let word of words) trie.insert(word);\n function dfs(node, i, j, path) {\n if (node.isEndOfWord) {\n result.push(path);\n node.isEndOfWord = false;\n }\n if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || !node.children[board[i][j]]) return;\n let char = board[i][j];\n board[i][j] = '#';\n for (let [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {\n dfs(node.children[char], i + dx, j + dy, path + char);\n }\n board[i][j] = char;\n }\n for (let i = 0; i < board.length; i++) {\n for (let j = 0; j < board[0].length; j++) {\n if (trie.children[board[i][j]]) dfs(trie, i, j, '');\n }\n }\n return result;\n}\n",
		"explanation": "This function finds all words in the board using a Trie and DFS.",
		"category": "Trie"
	},
	{
		"topic": "Letter Combinations of a Phone Number",
		"code": "// Find all letter combinations of a phone number\nfunction letterCombinations(digits) {\n if (!digits.length) return [];\n let map = {\n '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n };\n let result = [];\n function backtrack(index, path) {\n if (index === digits.length) {\n result.push(path);\n return;\n }\n for (let char of map[digits[index]]) {\n backtrack(index + 1, path + char);\n }\n }\n backtrack(0, '');\n return result;\n}\n",
		"explanation": "This function finds all letter combinations of a phone number.",
		"category": "Backtracking"
	},
	{
		"topic": "Combinations",
		"code": "// Find all combinations of k numbers out of 1 to n\nfunction combine(n, k) {\n let result = [];\n function backtrack(start, path) {\n if (path.length === k) {\n result.push([...path]);\n return;\n }\n for (let i = start; i <= n; i++) {\n path.push(i);\n backtrack(i + 1, path);\n path.pop();\n }\n }\n backtrack(1, []);\n return result;\n}\n",
		"explanation": "This function finds all combinations of k numbers out of 1 to n.",
		"category": "Backtracking"
	},
	{
		"topic": "Generate Parentheses",
		"code": "// Generate all combinations of well-formed parentheses\nfunction generateParenthesis(n) {\n let result = [];\n function backtrack(s = '', left = 0, right = 0) {\n if (s.length === 2 * n) {\n result.push(s);\n return;\n }\n if (left < n) backtrack(s + '(', left + 1, right);\n if (right < left) backtrack(s + ')', left, right + 1);\n }\n backtrack();\n return result;\n}\n",
		"explanation": "This function generates all combinations of well-formed parentheses.",
		"category": "Backtracking"
	},
	{
		"topic": "Word Search",
		"code": "// Find if a word exists in the board\nfunction exist(board, word) {\n function dfs(i, j, k) {\n if (k === word.length) return true;\n if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] !== word[k]) return false;\n let temp = board[i][j];\n board[i][j] = '#';\n let found = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n board[i][j] = temp;\n return found;\n }\n for (let i = 0; i < board.length; i++) {\n for (let j = 0; j < board[0].length; j++) {\n if (dfs(i, j, 0)) return true;\n }\n }\n return false;\n}\n",
		"explanation": "This function finds if a word exists in the board using DFS.",
		"category": "Backtracking"
	},
	{
		"topic": "Convert Sorted Array to Binary Search Tree",
		"code": "// Convert sorted array to binary search tree\nfunction sortedArrayToBST(nums) {\n if (!nums.length) return null;\n function convert(left, right) {\n if (left > right) return null;\n let mid = Math.floor((left + right) / 2);\n let node = new TreeNode(nums[mid]);\n node.left = convert(left, mid - 1);\n node.right = convert(mid + 1, right);\n return node;\n }\n return convert(0, nums.length - 1);\n}\n",
		"explanation": "This function converts a sorted array to a binary search tree.",
		"category": "Divide & Conquer"
	},
	{
		"topic": "Sort List",
		"code": "// Sort a linked list in O(n log n) time\nfunction sortList(head) {\n if (!head || !head.next) return head;\n let slow = head, fast = head, prev = null;\n while (fast && fast.next) {\n prev = slow;\n slow = slow.next;\n fast = fast.next.next;\n }\n prev.next = null;\n let l1 = sortList(head);\n let l2 = sortList(slow);\n return merge(l1, l2);\n}\nfunction merge(l1, l2) {\n let dummy = new ListNode(0), current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n}\n",
		"explanation": "This function sorts a linked list in O(n log n) time using merge sort.",
		"category": "Divide & Conquer"
	},
	{
		"topic": "Construct Quad Tree",
		"code": "// Construct a quad tree\nfunction construct(grid) {\n function build(x, y, length) {\n if (length === 1) return new Node(grid[x][y] === 1, true);\n let half = length / 2;\n let topLeft = build(x, y, half);\n let topRight = build(x, y + half, half);\n let bottomLeft = build(x + half, y, half);\n let bottomRight = build(x + half, y + half, half);\n if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf && topLeft.val === topRight.val && topRight.val === bottomLeft.val && bottomLeft.val === bottomRight.val) {\n return new Node(topLeft.val, true);\n }\n return new Node('*', false, topLeft, topRight, bottomLeft, bottomRight);\n }\n return build(0, 0, grid.length);\n}\n",
		"explanation": "This function constructs a quad tree from a grid.",
		"category": "Divide & Conquer"
	},
	{
		"topic": "Merge k Sorted Lists",
		"code": "// Merge k sorted linked lists\nfunction mergeKLists(lists) {\n if (!lists.length) return null;\n function mergeTwoLists(l1, l2) {\n let dummy = new ListNode(0), current = dummy;\n while (l1 && l2) {\n if (l1.val < l2.val) {\n current.next = l1;\n l1 = l1.next;\n } else {\n current.next = l2;\n l2 = l2.next;\n }\n current = current.next;\n }\n current.next = l1 ? l1 : l2;\n return dummy.next;\n }\n while (lists.length > 1) {\n let l1 = lists.shift();\n let l2 = lists.shift();\n let merged = mergeTwoLists(l1, l2);\n lists.push(merged);\n }\n return lists[0];\n}\n",
		"explanation": "This function merges k sorted linked lists into one sorted linked list.",
		"category": "Divide & Conquer"
	},
	{
		"topic": "Maximum Subarray",
		"code": "// Find the contiguous subarray with the maximum sum\nfunction maxSubArray(nums) {\n let maxSum = nums[0], currentSum = nums[0];\n for (let i = 1; i < nums.length; i++) {\n currentSum = Math.max(nums[i], currentSum + nums[i]);\n maxSum = Math.max(maxSum, currentSum);\n }\n return maxSum;\n}\n",
		"explanation": "This function finds the contiguous subarray with the maximum sum using Kadane's Algorithm.",
		"category": "Kadane's Algorithm"
	},
	{
		"topic": "Maximum Sum Circular Subarray",
		"code": "// Find the maximum sum of a circular subarray\nfunction maxSubarraySumCircular(A) {\n let total = 0, maxSum = A[0], currentMax = 0, minSum = A[0], currentMin = 0;\n for (let a of A) {\n currentMax = Math.max(currentMax + a, a);\n maxSum = Math.max(maxSum, currentMax);\n currentMin = Math.min(currentMin + a, a);\n minSum = Math.min(minSum, currentMin);\n total += a;\n }\n return maxSum > 0 ? Math.max(maxSum, total - minSum) : maxSum;\n}\n",
		"explanation": "This function finds the maximum sum of a circular subarray.",
		"category": "Kadane's Algorithm"
	},
	{
		"topic": "Search Insert Position",
		"code": "// Find the index where a target should be inserted\nfunction searchInsert(nums, target) {\n let left = 0, right = nums.length - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] === target) return mid;\n if (nums[mid] < target) left = mid + 1;\n else right = mid - 1;\n }\n return left;\n}\n",
		"explanation": "This function finds the index where a target should be inserted in a sorted array.",
		"category": "Binary Search"
	},
	{
		"topic": "Search a 2D Matrix",
		"code": "// Search a target in a 2D matrix\nfunction searchMatrix(matrix, target) {\n if (!matrix.length || !matrix[0].length) return false;\n let rows = matrix.length, cols = matrix[0].length;\n let left = 0, right = rows * cols - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n let midVal = matrix[Math.floor(mid / cols)][mid % cols];\n if (midVal === target) return true;\n if (midVal < target) left = mid + 1;\n else right = mid - 1;\n }\n return false;\n}\n",
		"explanation": "This function searches for a target in a 2D matrix.",
		"category": "Binary Search"
	},
	{
		"topic": "Find Peak Element",
		"code": "// Find peak element\nfunction findPeakElement(nums) {\n let left = 0, right = nums.length - 1;\n while (left < right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] > nums[mid + 1]) right = mid;\n else left = mid + 1;\n }\n return left;\n}\n",
		"explanation": "This function finds a peak element in an array.",
		"category": "Binary Search"
	},
	{
		"topic": "Search in Rotated Sorted Array",
		"code": "// Search in rotated sorted array\nfunction search(nums, target) {\n let left = 0, right = nums.length - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] === target) return mid;\n if (nums[left] <= nums[mid]) {\n if (nums[left] <= target && target < nums[mid]) right = mid - 1;\n else left = mid + 1;\n } else {\n if (nums[mid] < target && target <= nums[right]) left = mid + 1;\n else right = mid - 1;\n }\n }\n return -1;\n}\n",
		"explanation": "This function searches for a target in a rotated sorted array.",
		"category": "Binary Search"
	},
	{
		"topic": "Find First and Last Position of Element in Sorted Array",
		"code": "// Find first and last position of element in sorted array\nfunction searchRange(nums, target) {\n function findBound(isFirst) {\n let left = 0, right = nums.length - 1;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] === target) {\n if (isFirst) {\n if (mid === left || nums[mid - 1] !== target) return mid;\n right = mid - 1;\n } else {\n if (mid === right || nums[mid + 1] !== target) return mid;\n left = mid + 1;\n }\n } else if (nums[mid] < target) left = mid + 1;\n else right = mid - 1;\n }\n return -1;\n }\n return [findBound(true), findBound(false)];\n}\n",
		"explanation": "This function finds the first and last position of an element in a sorted array.",
		"category": "Binary Search"
	},
	{
		"topic": "Find Minimum in Rotated Sorted Array",
		"code": "// Find minimum in rotated sorted array\nfunction findMin(nums) {\n let left = 0, right = nums.length - 1;\n while (left < right) {\n let mid = Math.floor((left + right) / 2);\n if (nums[mid] > nums[right]) left = mid + 1;\n else right = mid;\n }\n return nums[left];\n}\n",
		"explanation": "This function finds the minimum element in a rotated sorted array.",
		"category": "Binary Search"
	},
	{
		"topic": "Median of Two Sorted Arrays",
		"code": "// Find median of two sorted arrays\nfunction findMedianSortedArrays(nums1, nums2) {\n let m = nums1.length, n = nums2.length;\n if (m > n) [nums1, nums2, m, n] = [nums2, nums1, n, m];\n let imin = 0, imax = m, halfLen = Math.floor((m + n + 1) / 2);\n while (imin <= imax) {\n let i = Math.floor((imin + imax) / 2);\n let j = halfLen - i;\n if (i < m && nums1[i] < nums2[j - 1]) imin = i + 1;\n else if (i > 0 && nums1[i - 1] > nums2[j]) imax = i - 1;\n else {\n let maxOfLeft = 0;\n if (i === 0) maxOfLeft = nums2[j - 1];\n else if (j === 0) maxOfLeft = nums1[i - 1];\n else maxOfLeft = Math.max(nums1[i - 1], nums2[j - 1]);\n if ((m + n) % 2 === 1) return maxOfLeft;\n let minOfRight = 0;\n if (i === m) minOfRight = nums2[j];\n else if (j === n) minOfRight = nums1[i];\n else minOfRight = Math.min(nums1[i], nums2[j]);\n return (maxOfLeft + minOfRight) / 2;\n }\n }\n return 0;\n}\n",
		"explanation": "This function finds the median of two sorted arrays.",
		"category": "Binary Search"
	},
	{
		"topic": "Kth Largest Element in an Array",
		"code": "// Find kth largest element in an array\nfunction findKthLargest(nums, k) {\n let heap = new MinHeap();\n for (let num of nums) {\n heap.add(num);\n if (heap.size() > k) heap.poll();\n }\n return heap.peek();\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] >= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild < element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild < element) || (swap !== null && rightChild < leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the kth largest element in an array using a min heap.",
		"category": "Heap"
	},
	{
		"topic": "IPO",
		"code": "// Find the maximum capital after k projects\nfunction findMaximizedCapital(k, W, Profits, Capital) {\n let minCapital = new MinHeap(), maxProfit = new MaxHeap();\n for (let i = 0; i < Capital.length; i++) minCapital.add([Capital[i], Profits[i]]);\n for (let i = 0; i < k; i++) {\n while (minCapital.size() && minCapital.peek()[0] <= W) maxProfit.add(minCapital.poll()[1]);\n if (!maxProfit.size()) break;\n W += maxProfit.poll();\n }\n return W;\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index][0] >= this.heap[parentIndex][0]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild[0] < element[0]) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild[0] < element[0]) || (swap !== null && rightChild[0] < leftChild[0])) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\nclass MaxHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] <= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild > element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the maximum capital after k projects.",
		"category": "Heap"
	},
	{
		"topic": "Find K Pairs with Smallest Sums",
		"code": "// Find k pairs with smallest sums\nfunction kSmallestPairs(nums1, nums2, k) {\n let heap = new MinHeap();\n for (let i = 0; i < Math.min(nums1.length, k); i++) heap.add([nums1[i] + nums2[0], i, 0]);\n let result = [];\n while (k-- > 0 && heap.size()) {\n let [sum, i, j] = heap.poll();\n result.push([nums1[i], nums2[j]]);\n if (j + 1 < nums2.length) heap.add([nums1[i] + nums2[j + 1], i, j + 1]);\n }\n return result;\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index][0] >= this.heap[parentIndex][0]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild[0] < element[0]) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild[0] < element[0]) || (swap !== null && rightChild[0] < leftChild[0])) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds k pairs with the smallest sums.",
		"category": "Heap"
	},
	{
		"topic": "Find Median from Data Stream",
		"code": "// Find median from data stream\nclass MedianFinder {\n constructor() {\n this.small = new MaxHeap();\n this.large = new MinHeap();\n }\n addNum(num) {\n this.small.add(num);\n this.large.add(this.small.poll());\n if (this.small.size() < this.large.size()) this.small.add(this.large.poll());\n }\n findMedian() {\n return this.small.size() > this.large.size() ? this.small.peek() : (this.small.peek() + this.large.peek()) / 2;\n }\n}\nclass MinHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] >= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild < element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild < element) || (swap !== null && rightChild < leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\nclass MaxHeap {\n constructor() {\n this.heap = [];\n }\n add(val) {\n this.heap.push(val);\n this.bubbleUp();\n }\n poll() {\n if (this.size() === 1) return this.heap.pop();\n let root = this.heap[0];\n this.heap[0] = this.heap.pop();\n this.bubbleDown();\n return root;\n }\n peek() {\n return this.heap[0];\n }\n size() {\n return this.heap.length;\n }\n bubbleUp() {\n let index = this.heap.length - 1;\n while (index > 0) {\n let parentIndex = Math.floor((index - 1) / 2);\n if (this.heap[index] <= this.heap[parentIndex]) break;\n [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n index = parentIndex;\n }\n }\n bubbleDown() {\n let index = 0;\n let length = this.heap.length;\n let element = this.heap[0];\n while (true) {\n let leftChildIndex = 2 * index + 1;\n let rightChildIndex = 2 * index + 2;\n let leftChild, rightChild;\n let swap = null;\n if (leftChildIndex < length) {\n leftChild = this.heap[leftChildIndex];\n if (leftChild > element) swap = leftChildIndex;\n }\n if (rightChildIndex < length) {\n rightChild = this.heap[rightChildIndex];\n if ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild)) swap = rightChildIndex;\n }\n if (swap === null) break;\n this.heap[index] = this.heap[swap];\n this.heap[swap] = element;\n index = swap;\n }\n }\n}\n",
		"explanation": "This function finds the median from a data stream.",
		"category": "Heap"
	},
	{
		"topic": "Add Binary",
		"code": "// Add two binary numbers\nfunction addBinary(a, b) {\n let result = '', carry = 0, i = a.length - 1, j = b.length - 1;\n while (i >= 0 || j >= 0 || carry) {\n let sum = carry;\n if (i >= 0) sum += parseInt(a[i--], 2);\n if (j >= 0) sum += parseInt(b[j--], 2);\n result = (sum % 2) + result;\n carry = Math.floor(sum / 2);\n }\n return result;\n}\n",
		"explanation": "This function adds two binary numbers and returns the result as a binary string.",
		"category": "Bit Manipulation"
	},
	{
		"topic": "Reverse Bits",
		"code": "// Reverse bits of a given 32 bits unsigned integer\nfunction reverseBits(n) {\n let result = 0;\n for (let i = 0; i < 32; i++) {\n result = (result << 1) | (n & 1);\n n >>>= 1;\n }\n return result >>> 0;\n}\n",
		"explanation": "This function reverses the bits of a given 32 bits unsigned integer.",
		"category": "Bit Manipulation"
	},
	{
		"topic": "Number of 1 Bits",
		"code": "// Count the number of 1 bits\nfunction hammingWeight(n) {\n let count = 0;\n while (n !== 0) {\n count += n & 1;\n n >>>= 1;\n }\n return count;\n}\n",
		"explanation": "This function counts the number of 1 bits in a given integer.",
		"category": "Bit Manipulation"
	},
	{
		"topic": "Single Number",
		"code": "// Find the single number\nfunction singleNumber(nums) {\n let result = 0;\n for (let num of nums) {\n result ^= num;\n }\n return result;\n}\n",
		"explanation": "This function finds the single number in an array where every other number appears twice.",
		"category": "Bit Manipulation"
	},
	{
		"topic": "Single Number II",
		"code": "// Find the single number that appears only once\nfunction singleNumber(nums) {\n let ones = 0, twos = 0;\n for (let num of nums) {\n ones = (ones ^ num) & ~twos;\n twos = (twos ^ num) & ~ones;\n }\n return ones;\n}\n",
		"explanation": "This function finds the single number that appears only once in an array where every other number appears three times.",
		"category": "Bit Manipulation"
	},
	{
		"topic": "Bitwise AND of Numbers Range",
		"code": "// Find the bitwise AND of numbers range\nfunction rangeBitwiseAnd(m, n) {\n let shift = 0;\n while (m < n) {\n m >>= 1;\n n >>= 1;\n shift++;\n }\n return m << shift;\n}\n",
		"explanation": "This function finds the bitwise AND of all numbers in a given range.",
		"category": "Bit Manipulation"
	},
	{
		"topic": "Palindrome Number",
		"code": "// Check if a number is a palindrome\nfunction isPalindrome(x) {\n if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n let revertedNumber = 0;\n while (x > revertedNumber) {\n revertedNumber = revertedNumber * 10 + x % 10;\n x = Math.floor(x / 10);\n }\n return x === revertedNumber || x === Math.floor(revertedNumber / 10);\n}\n",
		"explanation": "This function checks if a number is a palindrome.",
		"category": "Math"
	},
	{
		"topic": "Plus One",
		"code": "// Increment a number represented as an array\nfunction plusOne(digits) {\n for (let i = digits.length - 1; i >= 0; i--) {\n if (digits[i] < 9) {\n digits[i]++;\n return digits;\n }\n digits[i] = 0;\n }\n digits.unshift(1);\n return digits;\n}\n",
		"explanation": "This function increments a number represented as an array of digits by one.",
		"category": "Math"
	},
	{
		"topic": "Factorial Trailing Zeroes",
		"code": "// Find the number of trailing zeroes in factorial\nfunction trailingZeroes(n) {\n let count = 0;\n while (n > 0) {\n n = Math.floor(n / 5);\n count += n;\n }\n return count;\n}\n",
		"explanation": "This function finds the number of trailing zeroes in the factorial of a given number.",
		"category": "Math"
	},
	{
		"topic": "Sqrt(x)",
		"code": "// Calculate the square root of x\nfunction mySqrt(x) {\n if (x === 0) return 0;\n let left = 1, right = x;\n while (left <= right) {\n let mid = Math.floor((left + right) / 2);\n if (mid * mid === x) return mid;\n if (mid * mid < x) left = mid + 1;\n else right = mid - 1;\n }\n return right;\n}\n",
		"explanation": "This function calculates the square root of x using binary search.",
		"category": "Math"
	},
	{
		"topic": "Pow(x, n)",
		"code": "// Calculate x raised to the power n\nfunction myPow(x, n) {\n if (n === 0) return 1;\n if (n < 0) return 1 / myPow(x, -n);\n if (n % 2 === 0) return myPow(x * x, n / 2);\n return x * myPow(x * x, (n - 1) / 2);\n}\n",
		"explanation": "This function calculates x raised to the power n using recursion.",
		"category": "Math"
	},
	{
		"topic": "Max Points on a Line",
		"code": "// Find the maximum number of points on a line\nfunction maxPoints(points) {\n if (points.length < 3) return points.length;\n let max = 0;\n for (let i = 0; i < points.length; i++) {\n let map = new Map(), duplicates = 1;\n for (let j = i + 1; j < points.length; j++) {\n let dx = points[j][0] - points[i][0];\n let dy = points[j][1] - points[i][1];\n if (dx === 0 && dy === 0) {\n duplicates++;\n continue;\n }\n let gcd = getGCD(dx, dy);\n dx /= gcd;\n dy /= gcd;\n let key = `${dx}/${dy}`;\n map.set(key, (map.get(key) || 0) + 1);\n }\n max = Math.max(max, duplicates);\n for (let count of map.values()) {\n max = Math.max(max, count + duplicates);\n }\n }\n return max;\n}\nfunction getGCD(a, b) {\n if (b === 0) return a;\n return getGCD(b, a % b);\n}\n",
		"explanation": "This function finds the maximum number of points on a line.",
		"category": "Math"
	},
	{
		"topic": "Climbing Stairs",
		"code": "// Find the number of ways to climb stairs\nfunction climbStairs(n) {\n if (n <= 2) return n;\n let a = 1, b = 2;\n for (let i = 3; i <= n; i++) {\n let temp = a + b;\n a = b;\n b = temp;\n }\n return b;\n}\n",
		"explanation": "This function finds the number of ways to climb a staircase with n steps.",
		"category": "1D DP"
	},
	{
		"topic": "House Robber",
		"code": "// Find the maximum amount of money you can rob\nfunction rob(nums) {\n if (nums.length === 0) return 0;\n if (nums.length === 1) return nums[0];\n let dp = [nums[0], Math.max(nums[0], nums[1])];\n for (let i = 2; i < nums.length; i++) {\n dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n }\n return dp[nums.length - 1];\n}\n",
		"explanation": "This function finds the maximum amount of money you can rob from houses without robbing two adjacent houses.",
		"category": "1D DP"
	},
	{
		"topic": "Word Break",
		"code": "// Determine if you can segment the string into words\nfunction wordBreak(s, wordDict) {\n let dp = Array(s.length + 1).fill(false);\n dp[0] = true;\n for (let i = 1; i <= s.length; i++) {\n for (let j = 0; j < i; j++) {\n if (dp[j] && wordDict.includes(s.slice(j, i))) {\n dp[i] = true;\n break;\n }\n }\n }\n return dp[s.length];\n}\n",
		"explanation": "This function determines if you can segment the string into words from the dictionary.",
		"category": "1D DP"
	},
	{
		"topic": "Coin Change",
		"code": "// Find the minimum number of coins to make up a given amount\nfunction coinChange(coins, amount) {\n let dp = Array(amount + 1).fill(Infinity);\n dp[0] = 0;\n for (let coin of coins) {\n for (let i = coin; i <= amount; i++) {\n dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n }\n }\n return dp[amount] === Infinity ? -1 : dp[amount];\n}\n",
		"explanation": "This function finds the minimum number of coins needed to make up a given amount.",
		"category": "1D DP"
	},
	{
		"topic": "Longest Increasing Subsequence",
		"code": "// Find the length of the longest increasing subsequence\nfunction lengthOfLIS(nums) {\n let dp = Array(nums.length).fill(1);\n for (let i = 1; i < nums.length; i++) {\n for (let j = 0; j < i; j++) {\n if (nums[i] > nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);\n }\n }\n return Math.max(...dp);\n}\n",
		"explanation": "This function finds the length of the longest increasing subsequence in an array.",
		"category": "1D DP"
	},
	{
		"topic": "Triangle",
		"code": "// Find the minimum path sum from top to bottom\nfunction minimumTotal(triangle) {\n let dp = triangle[triangle.length - 1];\n for (let i = triangle.length - 2; i >= 0; i--) {\n for (let j = 0; j < triangle[i].length; j++) {\n dp[j] = triangle[i][j] + Math.min(dp[j], dp[j + 1]);\n }\n }\n return dp[0];\n}\n",
		"explanation": "This function finds the minimum path sum from top to bottom in a triangle.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Minimum Path Sum",
		"code": "// Find the minimum path sum in a grid\nfunction minPathSum(grid) {\n let m = grid.length, n = grid[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n dp[0][0] = grid[0][0];\n for (let i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];\n for (let j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];\n for (let i = 1; i < m; i++) {\n for (let j = 1; j < n; j++) {\n dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);\n }\n }\n return dp[m - 1][n - 1];\n}\n",
		"explanation": "This function finds the minimum path sum in a grid from top-left to bottom-right.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Unique Paths II",
		"code": "// Find the number of unique paths in a grid with obstacles\nfunction uniquePathsWithObstacles(obstacleGrid) {\n let m = obstacleGrid.length, n = obstacleGrid[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n dp[0][0] = obstacleGrid[0][0] === 1 ? 0 : 1;\n for (let i = 1; i < m; i++) dp[i][0] = obstacleGrid[i][0] === 1 ? 0 : dp[i - 1][0];\n for (let j = 1; j < n; j++) dp[0][j] = obstacleGrid[0][j] === 1 ? 0 : dp[0][j - 1];\n for (let i = 1; i < m; i++) {\n for (let j = 1; j < n; j++) {\n if (obstacleGrid[i][j] === 1) dp[i][j] = 0;\n else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n }\n }\n return dp[m - 1][n - 1];\n}\n",
		"explanation": "This function finds the number of unique paths in a grid with obstacles from top-left to bottom-right.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Longest Palindromic Substring",
		"code": "// Find the longest palindromic substring\nfunction longestPalindrome(s) {\n let n = s.length;\n let dp = Array(n).fill().map(() => Array(n).fill(false));\n let maxLength = 1, start = 0;\n for (let i = 0; i < n; i++) dp[i][i] = true;\n for (let i = 0; i < n - 1; i++) {\n if (s[i] === s[i + 1]) {\n dp[i][i + 1] = true;\n start = i;\n maxLength = 2;\n }\n }\n for (let k = 3; k <= n; k++) {\n for (let i = 0; i < n - k + 1; i++) {\n let j = i + k - 1;\n if (dp[i + 1][j - 1] && s[i] === s[j]) {\n dp[i][j] = true;\n if (k > maxLength) {\n start = i;\n maxLength = k;\n }\n }\n }\n }\n return s.substring(start, start + maxLength);\n}\n",
		"explanation": "This function finds the longest palindromic substring in a given string.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Interleaving String",
		"code": "// Determine if s3 is an interleaving of s1 and s2\nfunction isInterleave(s1, s2, s3) {\n if (s1.length + s2.length !== s3.length) return false;\n let dp = Array(s1.length + 1).fill().map(() => Array(s2.length + 1).fill(false));\n dp[0][0] = true;\n for (let i = 1; i <= s1.length; i++) dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\n for (let j = 1; j <= s2.length; j++) dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\n for (let i = 1; i <= s1.length; i++) {\n for (let j = 1; j <= s2.length; j++) {\n dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n }\n }\n return dp[s1.length][s2.length];\n}\n",
		"explanation": "This function determines if s3 is an interleaving of s1 and s2.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Edit Distance",
		"code": "// Find the minimum edit distance between two strings\nfunction minDistance(word1, word2) {\n let m = word1.length, n = word2.length;\n let dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n for (let i = 0; i <= m; i++) dp[i][0] = i;\n for (let j = 0; j <= n; j++) dp[0][j] = j;\n for (let i = 1; i <= m; i++) {\n for (let j = 1; j <= n; j++) {\n if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];\n else dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;\n }\n }\n return dp[m][n];\n}\n",
		"explanation": "This function finds the minimum edit distance between two strings.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Best Time to Buy and Sell Stock III",
		"code": "// Find the maximum profit with at most two transactions\nfunction maxProfit(prices) {\n let t1Cost = Infinity, t2Cost = Infinity;\n let t1Profit = 0, t2Profit = 0;\n for (let price of prices) {\n t1Cost = Math.min(t1Cost, price);\n t1Profit = Math.max(t1Profit, price - t1Cost);\n t2Cost = Math.min(t2Cost, price - t1Profit);\n t2Profit = Math.max(t2Profit, price - t2Cost);\n }\n return t2Profit;\n}\n",
		"explanation": "This function finds the maximum profit with at most two transactions.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Best Time to Buy and Sell Stock IV",
		"code": "// Find the maximum profit with at most k transactions\nfunction maxProfit(k, prices) {\n if (prices.length === 0) return 0;\n if (k >= prices.length / 2) {\n let profit = 0;\n for (let i = 1; i < prices.length; i++) {\n if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];\n }\n return profit;\n }\n let dp = Array(k + 1).fill().map(() => Array(prices.length).fill(0));\n for (let i = 1; i <= k; i++) {\n let maxDiff = -prices[0];\n for (let j = 1; j < prices.length; j++) {\n dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n }\n }\n return dp[k][prices.length - 1];\n}\n",
		"explanation": "This function finds the maximum profit with at most k transactions.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Maximal Square",
		"code": "// Find the largest square containing only 1's\nfunction maximalSquare(matrix) {\n if (matrix.length === 0) return 0;\n let m = matrix.length, n = matrix[0].length;\n let dp = Array(m).fill().map(() => Array(n).fill(0));\n let maxSide = 0;\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n if (matrix[i][j] === '1') {\n if (i === 0 || j === 0) dp[i][j] = 1;\n else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n maxSide = Math.max(maxSide, dp[i][j]);\n }\n }\n }\n return maxSide * maxSide;\n}\n",
		"explanation": "This function finds the largest square containing only 1's in a binary matrix.",
		"category": "Multidimensional DP"
	},
	{
		"topic": "Maximum Depth of Binary Tree",
		"code": "// Find the maximum depth of a binary tree\nfunction maxDepth(root) {\n if (!root) return 0;\n return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n",
		"explanation": "This function finds the maximum depth of a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Same Tree",
		"code": "// Check if two binary trees are the same\nfunction isSameTree(p, q) {\n if (!p && !q) return true;\n if (!p || !q || p.val !== q.val) return false;\n return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n",
		"explanation": "This function checks if two binary trees are the same.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Invert Binary Tree",
		"code": "// Invert a binary tree\nfunction invertTree(root) {\n if (!root) return null;\n let left = invertTree(root.left);\n let right = invertTree(root.right);\n root.left = right;\n root.right = left;\n return root;\n}\n",
		"explanation": "This function inverts a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Symmetric Tree",
		"code": "// Check if a binary tree is symmetric\nfunction isSymmetric(root) {\n if (!root) return true;\n function isMirror(t1, t2) {\n if (!t1 && !t2) return true;\n if (!t1 || !t2 || t1.val !== t2.val) return false;\n return isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\n }\n return isMirror(root.left, root.right);\n}\n",
		"explanation": "This function checks if a binary tree is symmetric.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Construct Binary Tree from Preorder and Inorder Traversal",
		"code": "// Construct binary tree from preorder and inorder traversal\nfunction buildTree(preorder, inorder) {\n if (!preorder.length || !inorder.length) return null;\n let root = new TreeNode(preorder[0]);\n let mid = inorder.indexOf(preorder[0]);\n root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n return root;\n}\n",
		"explanation": "This function constructs a binary tree from preorder and inorder traversal.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Construct Binary Tree from Inorder and Postorder Traversal",
		"code": "// Construct binary tree from inorder and postorder traversal\nfunction buildTree(inorder, postorder) {\n if (!inorder.length || !postorder.length) return null;\n let root = new TreeNode(postorder.pop());\n let mid = inorder.indexOf(root.val);\n root.right = buildTree(inorder.slice(mid + 1), postorder);\n root.left = buildTree(inorder.slice(0, mid), postorder);\n return root;\n}\n",
		"explanation": "This function constructs a binary tree from inorder and postorder traversal.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Populating Next Right Pointers in Each Node II",
		"code": "// Populate next right pointers in each node\nfunction connect(root) {\n if (!root) return null;\n let queue = [root];\n while (queue.length) {\n let size = queue.length;\n for (let i = 0; i < size; i++) {\n let node = queue.shift();\n if (i < size - 1) node.next = queue[0];\n if (node.left) queue.push(node.left);\n if (node.right) queue.push(node.right);\n }\n }\n return root;\n}\n",
		"explanation": "This function populates each next pointer to point to its next right node.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Flatten Binary Tree to Linked List",
		"code": "// Flatten binary tree to linked list\nfunction flatten(root) {\n if (!root) return;\n flatten(root.left);\n flatten(root.right);\n let left = root.left;\n let right = root.right;\n root.left = null;\n root.right = left;\n let current = root;\n while (current.right) current = current.right;\n current.right = right;\n}\n",
		"explanation": "This function flattens a binary tree to a linked list in-place.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Path Sum",
		"code": "// Find if there is a root-to-leaf path with a given sum\nfunction hasPathSum(root, sum) {\n if (!root) return false;\n if (!root.left && !root.right) return root.val === sum;\n return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n}\n",
		"explanation": "This function checks if there is a root-to-leaf path with a given sum.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Sum Root to Leaf Numbers",
		"code": "// Find the sum of all root-to-leaf numbers\nfunction sumNumbers(root) {\n function dfs(node, currentSum) {\n if (!node) return 0;\n currentSum = currentSum * 10 + node.val;\n if (!node.left && !node.right) return currentSum;\n return dfs(node.left, currentSum) + dfs(node.right, currentSum);\n }\n return dfs(root, 0);\n}\n",
		"explanation": "This function finds the sum of all root-to-leaf numbers.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Binary Tree Maximum Path Sum",
		"code": "// Find the maximum path sum in a binary tree\nfunction maxPathSum(root) {\n let maxSum = -Infinity;\n function dfs(node) {\n if (!node) return 0;\n let left = Math.max(dfs(node.left), 0);\n let right = Math.max(dfs(node.right), 0);\n let newPathSum = node.val + left + right;\n maxSum = Math.max(maxSum, newPathSum);\n return node.val + Math.max(left, right);\n }\n dfs(root);\n return maxSum;\n}\n",
		"explanation": "This function finds the maximum path sum in a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Binary Search Tree Iterator",
		"code": "// Implement a binary search tree iterator\nclass BSTIterator {\n constructor(root) {\n this.stack = [];\n this.pushAll(root);\n }\n next() {\n let node = this.stack.pop();\n this.pushAll(node.right);\n return node.val;\n }\n hasNext() {\n return this.stack.length > 0;\n }\n pushAll(node) {\n while (node) {\n this.stack.push(node);\n node = node.left;\n }\n }\n}\n",
		"explanation": "This class implements a binary search tree iterator with next and hasNext methods.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Count Complete Tree Nodes",
		"code": "// Count the number of nodes in a complete binary tree\nfunction countNodes(root) {\n if (!root) return 0;\n let leftDepth = getDepth(root.left);\n let rightDepth = getDepth(root.right);\n if (leftDepth === rightDepth) {\n return (1 << leftDepth) + countNodes(root.right);\n } else {\n return (1 << rightDepth) + countNodes(root.left);\n }\n}\nfunction getDepth(node) {\n let depth = 0;\n while (node) {\n depth++;\n node = node.left;\n }\n return depth;\n}\n",
		"explanation": "This function counts the number of nodes in a complete binary tree.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Lowest Common Ancestor of a Binary Tree",
		"code": "// Find the lowest common ancestor of two nodes in a binary tree\nfunction lowestCommonAncestor(root, p, q) {\n if (!root || root === p || root === q) return root;\n let left = lowestCommonAncestor(root.left, p, q);\n let right = lowestCommonAncestor(root.right, p, q);\n if (left && right) return root;\n return left ? left : right;\n}\n",
		"explanation": "This function finds the lowest common ancestor of two nodes in a binary tree.",
		"category": "Binary Tree General"
	},
	{
		"topic": "Binary Tree Right Side View",
		"code": "// Find the right side view of a binary tree\nfunction rightSideView(root) {\n let result = [];\n function dfs(node, level) {\n if (!node) return;\n if (result.length === level) result.push(node.val);\n dfs(node.right, level + 1);\n dfs(node.left, level + 1);\n }\n dfs(root, 0);\n return result;\n}\n",
		"explanation": "This function finds the right side view of a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"topic": "Average of Levels in Binary Tree",
		"code": "// Find the average of levels in a binary tree\nfunction averageOfLevels(root) {\n let result = [], queue = [root];\n while (queue.length) {\n let sum = 0, count = 0, nextQueue = [];\n for (let node of queue) {\n sum += node.val;\n count++;\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(sum / count);\n queue = nextQueue;\n }\n return result;\n}\n",
		"explanation": "This function finds the average of levels in a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"topic": "Binary Tree Level Order Traversal",
		"code": "// Perform level order traversal of a binary tree\nfunction levelOrder(root) {\n let result = [], queue = [root];\n while (queue.length) {\n let level = [], nextQueue = [];\n for (let node of queue) {\n level.push(node.val);\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(level);\n queue = nextQueue;\n }\n return result;\n}\n",
		"explanation": "This function performs level order traversal of a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"topic": "Binary Tree Zigzag Level Order Traversal",
		"code": "// Perform zigzag level order traversal of a binary tree\nfunction zigzagLevelOrder(root) {\n let result = [], queue = [root], leftToRight = true;\n while (queue.length) {\n let level = [], nextQueue = [];\n for (let node of queue) {\n if (leftToRight) level.push(node.val);\n else level.unshift(node.val);\n if (node.left) nextQueue.push(node.left);\n if (node.right) nextQueue.push(node.right);\n }\n result.push(level);\n queue = nextQueue;\n leftToRight = !leftToRight;\n }\n return result;\n}\n",
		"explanation": "This function performs zigzag level order traversal of a binary tree.",
		"category": "Binary Tree BFS"
	},
	{
		"topic": "Minimum Absolute Difference in BST",
		"code": "// Find the minimum absolute difference in a BST\nfunction getMinimumDifference(root) {\n let prev = null, minDiff = Infinity;\n function inorder(node) {\n if (!node) return;\n inorder(node.left);\n if (prev !== null) minDiff = Math.min(minDiff, node.val - prev);\n prev = node.val;\n inorder(root);\n return minDiff;\n}\n",
		"explanation": "This function finds the minimum absolute difference between values of any two nodes in a BST.",
		"category": "Binary Search Tree"
	},
	{
		"topic": "Kth Smallest Element in a BST",
		"code": "// Find the kth smallest element in a BST\nfunction kthSmallest(root, k) {\n let stack = [];\n while (true) {\n while (root) {\n stack.push(root);\n root = root.left;\n }\n root = stack.pop();\n if (--k === 0) return root.val;\n root = root.right;\n }\n}\n",
		"explanation": "This function finds the kth smallest element in a BST.",
		"category": "Binary Search Tree"
	},
	{
		"topic": "Validate Binary Search Tree",
		"code": "// Validate if a tree is a binary search tree\nfunction isValidBST(root) {\n function validate(node, low = -Infinity, high = Infinity) {\n if (!node) return true;\n if (node.val <= low || node.val >= high) return false;\n return validate(node.left, low, node.val) && validate(node.right, node.val, high);\n }\n return validate(root);\n}\n",
		"explanation": "This function validates if a tree is a binary search tree.",
		"category": "Binary Search Tree"
	},
	{
		"topic": "Convert Sorted Array to Binary Search Tree",
		"code": "// Convert sorted array to binary search tree\nfunction sortedArrayToBST(nums) {\n if (!nums.length) return null;\n function convert(left, right) {\n if (left > right) return null;\n let mid = Math.floor((left + right) / 2);\n let node = new TreeNode(nums[mid]);\n node.left = convert(left, mid - 1);\n node.right = convert(mid + 1, right);\n return node;\n }\n return convert(0, nums.length - 1);\n}\n",
		"explanation": "This function converts a sorted array to a binary search tree.",
		"category": "Binary Search Tree"
	},
	{
		"topic": "Convert Sorted List to Binary Search Tree",
		"code": "// Convert sorted list to binary search tree\nfunction sortedListToBST(head) {\n if (!head) return null;\n function findMiddle(left, right) {\n let slow = left, fast = left;\n while (fast !== right && fast.next !== right) {\n slow = slow.next;\n fast = fast.next.next;\n }\n return slow;\n }\n function convert(left, right) {\n if (left === right) return null;\n let mid = findMiddle(left, right);\n let node = new TreeNode(mid.val);\n node.left = convert(left, mid);\n node.right = convert(mid.next, right);\n return node;\n }\n return convert(head, null);\n}\n",
		"explanation": "This function converts a sorted linked list to a binary search tree.",
		"category": "Binary Search Tree"
	},
	{
		"topic": "Binary Search Tree to Greater Sum Tree",
		"code": "// Convert BST to Greater Sum Tree\nfunction bstToGst(root) {\n let sum = 0;\n function dfs(node) {\n if (!node) return;\n dfs(node.right);\n sum += node.val;\n node.val = sum;\n dfs(node.left);\n }\n dfs(root);\n return root;\n}\n",
		"explanation": "This function converts a BST to a Greater Sum Tree where each node's value is replaced by the sum of all greater values.",
		"category": "Binary Search Tree"
	},
	{
		"topic": "Number of Islands",
		"code": "// Find the number of islands\nfunction numIslands(grid) {\n if (!grid.length) return 0;\n let count = 0;\n function dfs(i, j) {\n if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return;\n grid[i][j] = '0';\n dfs(i + 1, j);\n dfs(i - 1, j);\n dfs(i, j + 1);\n dfs(i, j - 1);\n }\n for (let i = 0; i < grid.length; i++) {\n for (let j = 0; j < grid[0].length; j++) {\n if (grid[i][j] === '1') {\n count++;\n dfs(i, j);\n }\n }\n }\n return count;\n}\n",
		"explanation": "This function finds the number of islands in a grid using DFS.",
		"category": "Graph General"
	},
	{
		"topic": "Surrounded Regions",
		"code": "// Capture all regions surrounded by 'X'\nfunction solve(board) {\n if (!board.length) return;\n let m = board.length, n = board[0].length;\n function dfs(i, j) {\n if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] !== 'O') return;\n board[i][j] = 'T';\n dfs(i + 1, j);\n dfs(i - 1, j);\n dfs(i, j + 1);\n dfs(i, j - 1);\n }\n for (let i = 0; i < m; i++) {\n if (board[i][0] === 'O') dfs(i, 0);\n if (board[i][n - 1] === 'O') dfs(i, n - 1);\n }\n for (let j = 0; j < n; j++) {\n if (board[0][j] === 'O') dfs(0, j);\n if (board[m - 1][j] === 'O') dfs(m - 1, j);\n }\n for (let i = 0; i < m; i++) {\n for (let j = 0; j < n; j++) {\n if (board[i][j] === 'O') board[i][j] = 'X';\n if (board[i][j] === 'T') board[i][j] = 'O';\n }\n }\n}\n",
		"explanation": "This function captures all regions surrounded by 'X' in a board.",
		"category": "Graph General"
	},
	{
		"topic": "Clone Graph",
		"code": "// Clone a graph\nfunction cloneGraph(node) {\n if (!node) return null;\n let map = new Map();\n function clone(node) {\n if (!map.has(node)) {\n map.set(node, new Node(node.val));\n map.get(node).neighbors = node.neighbors.map(clone);\n }\n return map.get(node);\n }\n return clone(node);\n}\n",
		"explanation": "This function clones a graph using DFS.",
		"category": "Graph General"
	},
	{
		"topic": "Evaluate Division",
		"code": "// Evaluate division\nfunction calcEquation(equations, values, queries) {\n let graph = new Map();\n function buildGraph(equations, values) {\n for (let i = 0; i < equations.length; i++) {\n let [a, b] = equations[i];\n if (!graph.has(a)) graph.set(a, new Map());\n if (!graph.has(b)) graph.set(b, new Map());\n graph.get(a).set(b, values[i]);\n graph.get(b).set(a, 1 / values[i]);\n }\n }\n function dfs(start, end, visited) {\n if (!graph.has(start) || !graph.has(end)) return -1;\n if (start === end) return 1;\n visited.add(start);\n for (let [neighbor, value] of graph.get(start)) {\n if (!visited.has(neighbor)) {\n let product = dfs(neighbor, end, visited);\n if (product !== -1) return product * value;\n }\n }\n return -1;\n }\n buildGraph(equations, values);\n let results = [];\n for (let [a, b] of queries) {\n results.push(dfs(a, b, new Set()));\n }\n return results;\n}\n",
		"explanation": "This function evaluates division using a graph and DFS.",
		"category": "Graph General"
	},
	{
		"topic": "Graph Valid Tree",
		"code": "// Check if a graph is a valid tree\nfunction validTree(n, edges) {\n if (n === 0) return true;\n let graph = new Map();\n for (let [a, b] of edges) {\n if (!graph.has(a)) graph.set(a, []);\n if (!graph.has(b)) graph.set(b, []);\n graph.get(a).push(b);\n graph.get(b).push(a);\n }\n let visited = new Set();\n function dfs(node, parent) {\n if (visited.has(node)) return false;\n visited.add(node);\n for (let neighbor of graph.get(node)) {\n if (neighbor !== parent && !dfs(neighbor, node)) return false;\n }\n return true;\n }\n return dfs(0, -1) && visited.size === n;\n}\n",
		"explanation": "This function checks if a graph is a valid tree.",
		"category": "Graph General"
	},
	{
		"topic": "Redundant Connection",
		"code": "// Find the redundant connection\nfunction findRedundantConnection(edges) {\n let parent = Array.from({ length: edges.length + 1 }, (_, i) => i);\n function find(x) {\n if (parent[x] !== x) parent[x] = find(parent[x]);\n return parent[x];\n }\n function union(x, y) {\n let rootX = find(x);\n let rootY = find(y);\n if (rootX !== rootY) parent[rootX] = rootY;\n else return [x, y];\n }\n for (let [x, y] of edges) {\n let result = union(x, y);\n if (result) return result;\n }\n}\n",
		"explanation": "This function finds the redundant connection in a graph.",
		"category": "Graph General"
	}
]
